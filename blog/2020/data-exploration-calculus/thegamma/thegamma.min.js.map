{"version":3,"file":"thegamma.min.js","sources":["../node_modules/fable-core/Symbol.js","../node_modules/fable-core/Util.js","../node_modules/fable-core/Array.js","../node_modules/fable-core/ListClass.js","../node_modules/fable-core/Seq.js","../node_modules/fable-core/RegExp.js","../node_modules/fable-core/Long.js","../node_modules/fable-core/TimeSpan.js","../node_modules/fable-core/Date.js","../node_modules/fable-core/String.js","../node_modules/fable-core/Map.js","../node_modules/fable-core/List.js","../node_modules/fable-core/Set.js","../node_modules/fable-core/AsyncBuilder.js","../node_modules/fable-core/Async.js","../src/libraries/common.fs","../src/thegamma/codegen/runtime.fs","../src/libraries/google/extensions.fs","../node_modules/x-is-array/index.js","../node_modules/virtual-dom/vnode/vpatch.js","../node_modules/virtual-dom/vnode/is-vnode.js","../node_modules/virtual-dom/vnode/is-vtext.js","../node_modules/virtual-dom/vnode/is-widget.js","../node_modules/virtual-dom/vnode/is-thunk.js","../node_modules/virtual-dom/vnode/handle-thunk.js","../node_modules/virtual-dom/vnode/is-vhook.js","../node_modules/virtual-dom/vtree/diff-props.js","../node_modules/virtual-dom/vtree/diff.js","../node_modules/dom-walk/index.js","../node_modules/min-document/dom-comment.js","../node_modules/min-document/dom-text.js","../node_modules/min-document/event/dispatch-event.js","../node_modules/min-document/event/add-event-listener.js","../node_modules/min-document/event/remove-event-listener.js","../node_modules/min-document/serialize.js","../node_modules/min-document/dom-element.js","../node_modules/min-document/dom-fragment.js","../node_modules/min-document/event.js","../node_modules/min-document/document.js","../node_modules/virtual-dom/vdom/apply-properties.js","../node_modules/virtual-dom/vdom/create-element.js","../node_modules/virtual-dom/vdom/dom-index.js","../node_modules/virtual-dom/vdom/update-widget.js","../node_modules/virtual-dom/vdom/patch-op.js","../node_modules/virtual-dom/vdom/patch.js","../node_modules/virtual-dom/vnode/vnode.js","../node_modules/virtual-dom/vnode/vtext.js","../node_modules/virtual-dom/virtual-hyperscript/parse-tag.js","../node_modules/virtual-dom/virtual-hyperscript/hooks/soft-set-hook.js","../node_modules/individual/index.js","../node_modules/individual/one-version.js","../node_modules/ev-store/index.js","../node_modules/virtual-dom/virtual-hyperscript/hooks/ev-hook.js","../node_modules/virtual-dom/virtual-hyperscript/index.js","../node_modules/fable-core/Observable.js","../src/libraries/html.fs","../src/thegamma/ast/astops.fs","../src/thegamma/analyzer/interpreter.fs","../src/thegamma/ast/typeops.fs","../src/thegamma/providers/fsharp.fs","../src/thegamma/providers/rest.fs","../src/thegamma/providers/pivot.fs","../src/thegamma/analyzer/binder.fs","../node_modules/fable-core/MailboxProcessor.js","../src/thegamma/parser/tokenizer.fs","../src/thegamma/parser/parser.fs","../src/thegamma/analyzer/typechecker.fs","../src/thegamma/live/live.fs","../src/thegamma/services.fs","../src/thegamma/codegen/codegen.fs","../src/thegamma/live/pivot.fs","../src/thegamma/live/showable.fs","../src/thegamma/blocks.fs","../src/thegamma/monaco.fs","../src/thegamma/main.fs","../node_modules/core-js/library/modules/_defined.js","../node_modules/core-js/library/modules/_to-object.js","../node_modules/core-js/library/modules/_has.js","../node_modules/core-js/library/modules/_cof.js","../node_modules/core-js/library/modules/_iobject.js","../node_modules/core-js/library/modules/_to-iobject.js","../node_modules/core-js/library/modules/_to-integer.js","../node_modules/core-js/library/modules/_to-length.js","../node_modules/core-js/library/modules/_to-absolute-index.js","../node_modules/core-js/library/modules/_array-includes.js","../node_modules/core-js/library/modules/_global.js","../node_modules/core-js/library/modules/_shared.js","../node_modules/core-js/library/modules/_uid.js","../node_modules/core-js/library/modules/_shared-key.js","../node_modules/core-js/library/modules/_object-keys-internal.js","../node_modules/core-js/library/modules/_enum-bug-keys.js","../node_modules/core-js/library/modules/_object-keys.js","../node_modules/core-js/library/modules/_core.js","../node_modules/core-js/library/modules/_a-function.js","../node_modules/core-js/library/modules/_ctx.js","../node_modules/core-js/library/modules/_is-object.js","../node_modules/core-js/library/modules/_an-object.js","../node_modules/core-js/library/modules/_fails.js","../node_modules/core-js/library/modules/_descriptors.js","../node_modules/core-js/library/modules/_dom-create.js","../node_modules/core-js/library/modules/_ie8-dom-define.js","../node_modules/core-js/library/modules/_to-primitive.js","../node_modules/core-js/library/modules/_object-dp.js","../node_modules/core-js/library/modules/_property-desc.js","../node_modules/core-js/library/modules/_hide.js","../node_modules/core-js/library/modules/_export.js","../node_modules/core-js/library/modules/_object-sap.js","../node_modules/core-js/library/modules/es6.object.keys.js","../node_modules/core-js/library/fn/object/keys.js","../node_modules/babel-runtime/core-js/object/keys.js","../node_modules/core-js/library/modules/_string-at.js","../node_modules/core-js/library/modules/_library.js","../node_modules/core-js/library/modules/_redefine.js","../node_modules/core-js/library/modules/_object-dps.js","../node_modules/core-js/library/modules/_html.js","../node_modules/core-js/library/modules/_object-create.js","../node_modules/core-js/library/modules/_wks.js","../node_modules/core-js/library/modules/_set-to-string-tag.js","../node_modules/core-js/library/modules/_iter-create.js","../node_modules/core-js/library/modules/_object-gpo.js","../node_modules/core-js/library/modules/_iter-define.js","../node_modules/core-js/library/modules/es6.string.iterator.js","../node_modules/core-js/library/modules/_iter-call.js","../node_modules/core-js/library/modules/_is-array-iter.js","../node_modules/core-js/library/modules/_create-property.js","../node_modules/core-js/library/modules/_classof.js","../node_modules/core-js/library/modules/core.get-iterator-method.js","../node_modules/core-js/library/modules/_iter-detect.js","../node_modules/core-js/library/modules/es6.array.from.js","../node_modules/core-js/library/fn/array/from.js","../node_modules/babel-runtime/core-js/array/from.js","../node_modules/core-js/library/modules/_meta.js","../node_modules/core-js/library/modules/_wks-ext.js","../node_modules/core-js/library/modules/_wks-define.js","../node_modules/core-js/library/modules/_object-gops.js","../node_modules/core-js/library/modules/_object-pie.js","../node_modules/core-js/library/modules/_enum-keys.js","../node_modules/core-js/library/modules/_is-array.js","../node_modules/core-js/library/modules/_object-gopn.js","../node_modules/core-js/library/modules/_object-gopn-ext.js","../node_modules/core-js/library/modules/_object-gopd.js","../node_modules/core-js/library/modules/es6.symbol.js","../node_modules/core-js/library/modules/es7.symbol.async-iterator.js","../node_modules/core-js/library/modules/es7.symbol.observable.js","../node_modules/core-js/library/fn/symbol/index.js","../node_modules/babel-runtime/core-js/symbol.js","../node_modules/babel-runtime/helpers/classCallCheck.js","../node_modules/core-js/library/modules/es6.object.define-property.js","../node_modules/core-js/library/fn/object/define-property.js","../node_modules/babel-runtime/core-js/object/define-property.js","../node_modules/babel-runtime/helpers/createClass.js","../node_modules/core-js/library/modules/_add-to-unscopables.js","../node_modules/core-js/library/modules/_iter-step.js","../node_modules/core-js/library/modules/es6.array.iterator.js","../node_modules/core-js/library/modules/web.dom.iterable.js","../node_modules/core-js/library/fn/symbol/iterator.js","../node_modules/babel-runtime/core-js/symbol/iterator.js","../node_modules/babel-runtime/helpers/typeof.js","../node_modules/core-js/library/modules/_redefine-all.js","../node_modules/core-js/library/modules/_an-instance.js","../node_modules/core-js/library/modules/_for-of.js","../node_modules/core-js/library/modules/_set-species.js","../node_modules/core-js/library/modules/_validate-collection.js","../node_modules/core-js/library/modules/_collection-strong.js","../node_modules/core-js/library/modules/_array-species-constructor.js","../node_modules/core-js/library/modules/_array-species-create.js","../node_modules/core-js/library/modules/_array-methods.js","../node_modules/core-js/library/modules/_collection.js","../node_modules/core-js/library/modules/es6.map.js","../node_modules/core-js/library/modules/_array-from-iterable.js","../node_modules/core-js/library/modules/_collection-to-json.js","../node_modules/core-js/library/modules/es7.map.to-json.js","../node_modules/core-js/library/modules/_set-collection-of.js","../node_modules/core-js/library/modules/es7.map.of.js","../node_modules/core-js/library/modules/_set-collection-from.js","../node_modules/core-js/library/modules/es7.map.from.js","../node_modules/core-js/library/fn/map.js","../node_modules/babel-runtime/core-js/map.js","../node_modules/babel-runtime/helpers/defineProperty.js","../node_modules/core-js/library/modules/core.get-iterator.js","../node_modules/core-js/library/fn/get-iterator.js","../node_modules/babel-runtime/core-js/get-iterator.js","../node_modules/fable-core/GenericComparer.js","../node_modules/fable-core/Choice.js","../src/thegamma/common/babel.fs","../src/thegamma/ast/ast.fs","../src/thegamma/providers/providers.fs","../src/bindings/babel.fs","../src/libraries/general.fs","../src/libraries/series.fs","../src/libraries/google/core.fs","../src/libraries/google/options.fs","../src/libraries/google/charts.fs","../node_modules/virtual-dom/vnode/version.js","../node_modules/is-object/index.js","../node_modules/virtual-dom/diff.js","../node_modules/min-document/index.js","../node_modules/global/document.js","../node_modules/virtual-dom/patch.js","../node_modules/browser-split/index.js","../node_modules/virtual-dom/h.js","../node_modules/virtual-dom/create-element.js","../node_modules/virtual-dom/index.js","../node_modules/fable-core/Event.js","../src/libraries/tables.fs","../node_modules/core-js/library/modules/es6.math.log10.js","../node_modules/core-js/library/fn/math/log10.js","../node_modules/babel-runtime/core-js/math/log10.js","../src/libraries/compost.fs","../src/libraries/interactive.fs","../node_modules/fable-core/Lazy.js","../src/thegamma/ast/errors.fs","../node_modules/core-js/library/modules/_string-ws.js","../node_modules/core-js/library/modules/_string-trim.js","../node_modules/core-js/library/modules/_parse-float.js","../node_modules/core-js/library/modules/es6.number.parse-float.js","../node_modules/core-js/library/fn/number/parse-float.js","../node_modules/babel-runtime/core-js/number/parse-float.js","../src/thegamma/common/locations.fs"],"sourcesContent":["var fableGlobal = function () {\r\n    var globalObj = typeof window !== \"undefined\" ? window\r\n        : (typeof global !== \"undefined\" ? global\r\n            : (typeof self !== \"undefined\" ? self : {}));\r\n    if (typeof globalObj.__FABLE_CORE__ === \"undefined\") {\r\n        globalObj.__FABLE_CORE__ = {\r\n            types: new Map(),\r\n            symbols: {\r\n                reflection: Symbol(\"reflection\"),\r\n            }\r\n        };\r\n    }\r\n    return globalObj.__FABLE_CORE__;\r\n}();\r\nexport function setType(fullName, cons) {\r\n    fableGlobal.types.set(fullName, cons);\r\n}\r\nexport function getType(fullName) {\r\n    return fableGlobal.types.get(fullName);\r\n}\r\nexport default (fableGlobal.symbols);\r\n","import FSymbol from \"./Symbol\";\r\nvar NonDeclaredType = (function () {\r\n    function NonDeclaredType(kind, definition, generics) {\r\n        this.kind = kind;\r\n        this.definition = definition;\r\n        this.generics = generics;\r\n    }\r\n    NonDeclaredType.prototype.Equals = function (other) {\r\n        if (this.kind === other.kind && this.definition === other.definition) {\r\n            return typeof this.generics === \"object\"\r\n                ? equalsRecords(this.generics, other.generics)\r\n                : this.generics === other.generics;\r\n        }\r\n        return false;\r\n    };\r\n    return NonDeclaredType;\r\n}());\r\nexport { NonDeclaredType };\r\nexport var Any = new NonDeclaredType(\"Any\");\r\nexport var Unit = new NonDeclaredType(\"Unit\");\r\nexport function Option(t) {\r\n    return new NonDeclaredType(\"Option\", null, t);\r\n}\r\nfunction FableArray(t, isTypedArray) {\r\n    if (isTypedArray === void 0) { isTypedArray = false; }\r\n    var def = null, genArg = null;\r\n    if (isTypedArray) {\r\n        def = t;\r\n    }\r\n    else {\r\n        genArg = t;\r\n    }\r\n    return new NonDeclaredType(\"Array\", def, genArg);\r\n}\r\nexport { FableArray as Array };\r\nexport function Tuple(ts) {\r\n    return new NonDeclaredType(\"Tuple\", null, ts);\r\n}\r\nexport function GenericParam(definition) {\r\n    return new NonDeclaredType(\"GenericParam\", definition);\r\n}\r\nexport function Interface(definition) {\r\n    return new NonDeclaredType(\"Interface\", definition);\r\n}\r\nexport function makeGeneric(typeDef, genArgs) {\r\n    return new NonDeclaredType(\"GenericType\", typeDef, genArgs);\r\n}\r\nexport function isGeneric(typ) {\r\n    return typ instanceof NonDeclaredType && typ.kind === \"GenericType\";\r\n}\r\nexport function getDefinition(typ) {\r\n    return isGeneric(typ) ? typ.definition : typ;\r\n}\r\nexport function extendInfo(cons, info) {\r\n    var parent = Object.getPrototypeOf(cons.prototype);\r\n    if (typeof parent[FSymbol.reflection] === \"function\") {\r\n        var newInfo_1 = {}, parentInfo_1 = parent[FSymbol.reflection]();\r\n        Object.getOwnPropertyNames(info).forEach(function (k) {\r\n            var i = info[k];\r\n            if (typeof i === \"object\") {\r\n                newInfo_1[k] = Array.isArray(i)\r\n                    ? (parentInfo_1[k] || []).concat(i)\r\n                    : Object.assign(parentInfo_1[k] || {}, i);\r\n            }\r\n            else {\r\n                newInfo_1[k] = i;\r\n            }\r\n        });\r\n        return newInfo_1;\r\n    }\r\n    return info;\r\n}\r\nexport function hasInterface(obj, interfaceName) {\r\n    if (interfaceName === \"System.Collections.Generic.IEnumerable\") {\r\n        return typeof obj[Symbol.iterator] === \"function\";\r\n    }\r\n    else if (typeof obj[FSymbol.reflection] === \"function\") {\r\n        var interfaces = obj[FSymbol.reflection]().interfaces;\r\n        return Array.isArray(interfaces) && interfaces.indexOf(interfaceName) > -1;\r\n    }\r\n    return false;\r\n}\r\nexport function getPropertyNames(obj) {\r\n    if (obj == null) {\r\n        return [];\r\n    }\r\n    var propertyMap = typeof obj[FSymbol.reflection] === \"function\" ? obj[FSymbol.reflection]().properties || [] : obj;\r\n    return Object.getOwnPropertyNames(propertyMap);\r\n}\r\nexport function isArray(obj) {\r\n    return Array.isArray(obj) || ArrayBuffer.isView(obj);\r\n}\r\nexport function getRestParams(args, idx) {\r\n    for (var _len = args.length, restArgs = Array(_len > idx ? _len - idx : 0), _key = idx; _key < _len; _key++)\r\n        restArgs[_key - idx] = args[_key];\r\n    return restArgs;\r\n}\r\nexport function toString(o) {\r\n    return o != null && typeof o.ToString == \"function\" ? o.ToString() : String(o);\r\n}\r\nexport function hash(x) {\r\n    var s = JSON.stringify(x);\r\n    var h = 5381, i = 0, len = s.length;\r\n    while (i < len) {\r\n        h = (h * 33) ^ s.charCodeAt(i++);\r\n    }\r\n    return h;\r\n}\r\nexport function equals(x, y) {\r\n    if (x === y)\r\n        return true;\r\n    else if (x == null)\r\n        return y == null;\r\n    else if (y == null)\r\n        return false;\r\n    else if (Object.getPrototypeOf(x) !== Object.getPrototypeOf(y))\r\n        return false;\r\n    else if (typeof x.Equals === \"function\")\r\n        return x.Equals(y);\r\n    else if (Array.isArray(x)) {\r\n        if (x.length != y.length)\r\n            return false;\r\n        for (var i = 0; i < x.length; i++)\r\n            if (!equals(x[i], y[i]))\r\n                return false;\r\n        return true;\r\n    }\r\n    else if (ArrayBuffer.isView(x)) {\r\n        if (x.byteLength !== y.byteLength)\r\n            return false;\r\n        var dv1 = new DataView(x.buffer), dv2 = new DataView(y.buffer);\r\n        for (var i = 0; i < x.byteLength; i++)\r\n            if (dv1.getUint8(i) !== dv2.getUint8(i))\r\n                return false;\r\n        return true;\r\n    }\r\n    else if (x instanceof Date)\r\n        return x.getTime() == y.getTime();\r\n    else\r\n        return false;\r\n}\r\nexport function compare(x, y) {\r\n    if (x === y)\r\n        return 0;\r\n    if (x == null)\r\n        return y == null ? 0 : -1;\r\n    else if (y == null)\r\n        return 1;\r\n    else if (Object.getPrototypeOf(x) !== Object.getPrototypeOf(y))\r\n        return -1;\r\n    else if (typeof x.CompareTo === \"function\")\r\n        return x.CompareTo(y);\r\n    else if (Array.isArray(x)) {\r\n        if (x.length != y.length)\r\n            return x.length < y.length ? -1 : 1;\r\n        for (var i = 0, j = 0; i < x.length; i++)\r\n            if ((j = compare(x[i], y[i])) !== 0)\r\n                return j;\r\n        return 0;\r\n    }\r\n    else if (ArrayBuffer.isView(x)) {\r\n        if (x.byteLength != y.byteLength)\r\n            return x.byteLength < y.byteLength ? -1 : 1;\r\n        var dv1 = new DataView(x.buffer), dv2 = new DataView(y.buffer);\r\n        for (var i = 0, b1 = 0, b2 = 0; i < x.byteLength; i++) {\r\n            b1 = dv1.getUint8(i), b2 = dv2.getUint8(i);\r\n            if (b1 < b2)\r\n                return -1;\r\n            if (b1 > b2)\r\n                return 1;\r\n        }\r\n        return 0;\r\n    }\r\n    else if (x instanceof Date)\r\n        return compare(x.getTime(), y.getTime());\r\n    else\r\n        return x < y ? -1 : 1;\r\n}\r\nexport function equalsRecords(x, y) {\r\n    if (x === y) {\r\n        return true;\r\n    }\r\n    else {\r\n        var keys = getPropertyNames(x);\r\n        for (var i = 0; i < keys.length; i++) {\r\n            if (!equals(x[keys[i]], y[keys[i]]))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\nexport function compareRecords(x, y) {\r\n    if (x === y) {\r\n        return 0;\r\n    }\r\n    else {\r\n        var keys = getPropertyNames(x);\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var res = compare(x[keys[i]], y[keys[i]]);\r\n            if (res !== 0)\r\n                return res;\r\n        }\r\n        return 0;\r\n    }\r\n}\r\nexport function equalsUnions(x, y) {\r\n    if (x === y) {\r\n        return true;\r\n    }\r\n    else if (x.Case !== y.Case) {\r\n        return false;\r\n    }\r\n    else {\r\n        for (var i = 0; i < x.Fields.length; i++) {\r\n            if (!equals(x.Fields[i], y.Fields[i]))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\nexport function compareUnions(x, y) {\r\n    if (x === y) {\r\n        return 0;\r\n    }\r\n    else {\r\n        var res = compare(x.Case, y.Case);\r\n        if (res !== 0)\r\n            return res;\r\n        for (var i = 0; i < x.Fields.length; i++) {\r\n            res = compare(x.Fields[i], y.Fields[i]);\r\n            if (res !== 0)\r\n                return res;\r\n        }\r\n        return 0;\r\n    }\r\n}\r\nexport function createDisposable(f) {\r\n    return _a = {\r\n            Dispose: f\r\n        },\r\n        _a[FSymbol.reflection] = function () { return { interfaces: [\"System.IDisposable\"] }; },\r\n        _a;\r\n    var _a;\r\n}\r\nexport function createObj(fields) {\r\n    var iter = fields[Symbol.iterator]();\r\n    var cur = iter.next(), o = {};\r\n    while (!cur.done) {\r\n        o[cur.value[0]] = cur.value[1];\r\n        cur = iter.next();\r\n    }\r\n    return o;\r\n}\r\nexport function toPlainJsObj(source) {\r\n    if (source != null && source.constructor != Object) {\r\n        var target = {};\r\n        var props = Object.getOwnPropertyNames(source);\r\n        for (var i = 0; i < props.length; i++) {\r\n            target[props[i]] = source[props[i]];\r\n        }\r\n        var proto = Object.getPrototypeOf(source);\r\n        if (proto != null) {\r\n            props = Object.getOwnPropertyNames(proto);\r\n            for (var i = 0; i < props.length; i++) {\r\n                var prop = Object.getOwnPropertyDescriptor(proto, props[i]);\r\n                if (prop.value) {\r\n                    target[props[i]] = prop.value;\r\n                }\r\n                else if (prop.get) {\r\n                    target[props[i]] = prop.get.apply(source);\r\n                }\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n    else {\r\n        return source;\r\n    }\r\n}\r\nexport function round(value, digits) {\r\n    if (digits === void 0) { digits = 0; }\r\n    var m = Math.pow(10, digits);\r\n    var n = +(digits ? value * m : value).toFixed(8);\r\n    var i = Math.floor(n), f = n - i;\r\n    var e = 1e-8;\r\n    var r = (f > 0.5 - e && f < 0.5 + e) ? ((i % 2 == 0) ? i : i + 1) : Math.round(n);\r\n    return digits ? r / m : r;\r\n}\r\nexport function randomNext(min, max) {\r\n    return Math.floor(Math.random() * (max - min)) + min;\r\n}\r\nexport function defaultArg(arg, defaultValue, f) {\r\n    return arg == null ? defaultValue : (f != null ? f(arg) : arg);\r\n}\r\n","export function addRangeInPlace(range, xs) {\r\n    var iter = range[Symbol.iterator]();\r\n    var cur = iter.next();\r\n    while (!cur.done) {\r\n        xs.push(cur.value);\r\n        cur = iter.next();\r\n    }\r\n}\r\nexport function copyTo(source, sourceIndex, target, targetIndex, count) {\r\n    while (count--)\r\n        target[targetIndex++] = source[sourceIndex++];\r\n}\r\nexport function partition(f, xs) {\r\n    var ys = [], zs = [], j = 0, k = 0;\r\n    for (var i = 0; i < xs.length; i++)\r\n        if (f(xs[i]))\r\n            ys[j++] = xs[i];\r\n        else\r\n            zs[k++] = xs[i];\r\n    return [ys, zs];\r\n}\r\nexport function permute(f, xs) {\r\n    var ys = xs.map(function () { return null; });\r\n    var checkFlags = new Array(xs.length);\r\n    for (var i = 0; i < xs.length; i++) {\r\n        var j = f(i);\r\n        if (j < 0 || j >= xs.length)\r\n            throw new Error(\"Not a valid permutation\");\r\n        ys[j] = xs[i];\r\n        checkFlags[j] = 1;\r\n    }\r\n    for (var i = 0; i < xs.length; i++)\r\n        if (checkFlags[i] != 1)\r\n            throw new Error(\"Not a valid permutation\");\r\n    return ys;\r\n}\r\nexport function removeInPlace(item, xs) {\r\n    var i = xs.indexOf(item);\r\n    if (i > -1) {\r\n        xs.splice(i, 1);\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nexport function setSlice(target, lower, upper, source) {\r\n    var length = (upper || target.length - 1) - lower;\r\n    if (ArrayBuffer.isView(target) && source.length <= length)\r\n        target.set(source, lower);\r\n    else\r\n        for (var i = lower | 0, j = 0; j <= length; i++, j++)\r\n            target[i] = source[j];\r\n}\r\nexport function sortInPlaceBy(f, xs, dir) {\r\n    if (dir === void 0) { dir = 1; }\r\n    return xs.sort(function (x, y) {\r\n        x = f(x);\r\n        y = f(y);\r\n        return (x < y ? -1 : x == y ? 0 : 1) * dir;\r\n    });\r\n}\r\nexport function unzip(xs) {\r\n    var bs = new Array(xs.length), cs = new Array(xs.length);\r\n    for (var i = 0; i < xs.length; i++) {\r\n        bs[i] = xs[i][0];\r\n        cs[i] = xs[i][1];\r\n    }\r\n    return [bs, cs];\r\n}\r\nexport function unzip3(xs) {\r\n    var bs = new Array(xs.length), cs = new Array(xs.length), ds = new Array(xs.length);\r\n    for (var i = 0; i < xs.length; i++) {\r\n        bs[i] = xs[i][0];\r\n        cs[i] = xs[i][1];\r\n        ds[i] = xs[i][2];\r\n    }\r\n    return [bs, cs, ds];\r\n}\r\nexport function getSubArray(xs, startIndex, count) {\r\n    return xs.slice(startIndex, startIndex + count);\r\n}\r\nexport function fill(target, targetIndex, count, value) {\r\n    target.fill(value, targetIndex, targetIndex + count);\r\n}\r\n","import FSymbol from \"./Symbol\";\r\nimport { toString } from \"./Util\";\r\nimport { equals } from \"./Util\";\r\nimport { compare } from \"./Util\";\r\nexport function ofArray(args, base) {\r\n    var acc = base || new List();\r\n    for (var i = args.length - 1; i >= 0; i--) {\r\n        acc = new List(args[i], acc);\r\n    }\r\n    return acc;\r\n}\r\nvar List = (function () {\r\n    function List(head, tail) {\r\n        this.head = head;\r\n        this.tail = tail;\r\n    }\r\n    List.prototype.ToString = function () {\r\n        return \"[\" + Array.from(this).map(toString).join(\"; \") + \"]\";\r\n    };\r\n    List.prototype.Equals = function (x) {\r\n        if (this === x) {\r\n            return true;\r\n        }\r\n        else {\r\n            var iter1 = this[Symbol.iterator](), iter2 = x[Symbol.iterator]();\r\n            for (;;) {\r\n                var cur1 = iter1.next(), cur2 = iter2.next();\r\n                if (cur1.done)\r\n                    return cur2.done ? true : false;\r\n                else if (cur2.done)\r\n                    return false;\r\n                else if (!equals(cur1.value, cur2.value))\r\n                    return false;\r\n            }\r\n        }\r\n    };\r\n    List.prototype.CompareTo = function (x) {\r\n        if (this === x) {\r\n            return 0;\r\n        }\r\n        else {\r\n            var acc = 0;\r\n            var iter1 = this[Symbol.iterator](), iter2 = x[Symbol.iterator]();\r\n            for (;;) {\r\n                var cur1 = iter1.next(), cur2 = iter2.next();\r\n                if (cur1.done)\r\n                    return cur2.done ? acc : -1;\r\n                else if (cur2.done)\r\n                    return 1;\r\n                else {\r\n                    acc = compare(cur1.value, cur2.value);\r\n                    if (acc != 0)\r\n                        return acc;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Object.defineProperty(List.prototype, \"length\", {\r\n        get: function () {\r\n            var cur = this, acc = 0;\r\n            while (cur.tail != null) {\r\n                cur = cur.tail;\r\n                acc++;\r\n            }\r\n            return acc;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    List.prototype[Symbol.iterator] = function () {\r\n        var cur = this;\r\n        return {\r\n            next: function () {\r\n                var tmp = cur;\r\n                cur = cur.tail;\r\n                return { done: tmp.tail == null, value: tmp.head };\r\n            }\r\n        };\r\n    };\r\n    List.prototype[FSymbol.reflection] = function () {\r\n        return {\r\n            type: \"Microsoft.FSharp.Collections.FSharpList\",\r\n            interfaces: [\"System.IEquatable\", \"System.IComparable\"]\r\n        };\r\n    };\r\n    return List;\r\n}());\r\nexport default List;\r\n","import { equals } from \"./Util\";\r\nimport { compare } from \"./Util\";\r\nimport { permute as arrayPermute } from \"./Array\";\r\nimport List from \"./ListClass\";\r\nvar Enumerator = (function () {\r\n    function Enumerator(iter) {\r\n        this.iter = iter;\r\n    }\r\n    Enumerator.prototype.MoveNext = function () {\r\n        var cur = this.iter.next();\r\n        this.current = cur.value;\r\n        return !cur.done;\r\n    };\r\n    Object.defineProperty(Enumerator.prototype, \"Current\", {\r\n        get: function () {\r\n            return this.current;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Enumerator.prototype.Reset = function () {\r\n        throw new Error(\"JS iterators cannot be reset\");\r\n    };\r\n    Enumerator.prototype.Dispose = function () { };\r\n    return Enumerator;\r\n}());\r\nexport { Enumerator };\r\nexport function getEnumerator(o) {\r\n    return typeof o.GetEnumerator === \"function\"\r\n        ? o.GetEnumerator() : new Enumerator(o[Symbol.iterator]());\r\n}\r\nexport function toIterator(en) {\r\n    return {\r\n        next: function () {\r\n            return en.MoveNext()\r\n                ? { done: false, value: en.Current }\r\n                : { done: true, value: null };\r\n        }\r\n    };\r\n}\r\nfunction __failIfNone(res) {\r\n    if (res == null)\r\n        throw new Error(\"Seq did not contain any matching element\");\r\n    return res;\r\n}\r\nexport function toList(xs) {\r\n    return foldBack(function (x, acc) {\r\n        return new List(x, acc);\r\n    }, xs, new List());\r\n}\r\nexport function ofList(xs) {\r\n    return delay(function () { return unfold(function (x) { return x.tail != null ? [x.head, x.tail] : null; }, xs); });\r\n}\r\nexport function ofArray(xs) {\r\n    return delay(function () { return unfold(function (i) { return i < xs.length ? [xs[i], i + 1] : null; }, 0); });\r\n}\r\nexport function append(xs, ys) {\r\n    return delay(function () {\r\n        var firstDone = false;\r\n        var i = xs[Symbol.iterator]();\r\n        var iters = [i, null];\r\n        return unfold(function () {\r\n            var cur;\r\n            if (!firstDone) {\r\n                cur = iters[0].next();\r\n                if (!cur.done) {\r\n                    return [cur.value, iters];\r\n                }\r\n                else {\r\n                    firstDone = true;\r\n                    iters = [null, ys[Symbol.iterator]()];\r\n                }\r\n            }\r\n            cur = iters[1].next();\r\n            return !cur.done ? [cur.value, iters] : null;\r\n        }, iters);\r\n    });\r\n}\r\nexport function average(xs) {\r\n    var count = 1;\r\n    var sum = reduce(function (acc, x) {\r\n        count++;\r\n        return acc + x;\r\n    }, xs);\r\n    return sum / count;\r\n}\r\nexport function averageBy(f, xs) {\r\n    var count = 1;\r\n    var sum = reduce(function (acc, x) {\r\n        count++;\r\n        return (count === 2 ? f(acc) : acc) + f(x);\r\n    }, xs);\r\n    return sum / count;\r\n}\r\nexport function concat(xs) {\r\n    return delay(function () {\r\n        var iter = xs[Symbol.iterator]();\r\n        var output = { value: null };\r\n        return unfold(function (innerIter) {\r\n            var hasFinished = false;\r\n            while (!hasFinished) {\r\n                if (innerIter == null) {\r\n                    var cur = iter.next();\r\n                    if (!cur.done) {\r\n                        innerIter = cur.value[Symbol.iterator]();\r\n                    }\r\n                    else {\r\n                        hasFinished = true;\r\n                    }\r\n                }\r\n                else {\r\n                    var cur = innerIter.next();\r\n                    if (!cur.done) {\r\n                        output = { value: cur.value };\r\n                        hasFinished = true;\r\n                    }\r\n                    else {\r\n                        innerIter = null;\r\n                    }\r\n                }\r\n            }\r\n            return innerIter != null && output != null ? [output.value, innerIter] : null;\r\n        }, null);\r\n    });\r\n}\r\nexport function collect(f, xs) {\r\n    return concat(map(f, xs));\r\n}\r\nexport function choose(f, xs) {\r\n    var trySkipToNext = function (iter) {\r\n        var cur = iter.next();\r\n        if (!cur.done) {\r\n            var y = f(cur.value);\r\n            return y != null ? [y, iter] : trySkipToNext(iter);\r\n        }\r\n        return void 0;\r\n    };\r\n    return delay(function () {\r\n        return unfold(function (iter) {\r\n            return trySkipToNext(iter);\r\n        }, xs[Symbol.iterator]());\r\n    });\r\n}\r\nexport function compareWith(f, xs, ys) {\r\n    var nonZero = tryFind(function (i) { return i != 0; }, map2(function (x, y) { return f(x, y); }, xs, ys));\r\n    return nonZero != null ? nonZero : count(xs) - count(ys);\r\n}\r\nexport function delay(f) {\r\n    return _a = {},\r\n        _a[Symbol.iterator] = function () { return f()[Symbol.iterator](); },\r\n        _a;\r\n    var _a;\r\n}\r\nexport function empty() {\r\n    return unfold(function () { return void 0; });\r\n}\r\nexport function enumerateWhile(cond, xs) {\r\n    return concat(unfold(function () { return cond() ? [xs, true] : null; }));\r\n}\r\nexport function enumerateThenFinally(xs, finalFn) {\r\n    return delay(function () {\r\n        var iter;\r\n        try {\r\n            iter = xs[Symbol.iterator]();\r\n        }\r\n        catch (err) {\r\n            return void 0;\r\n        }\r\n        finally {\r\n            finalFn();\r\n        }\r\n        return unfold(function (iter) {\r\n            try {\r\n                var cur = iter.next();\r\n                return !cur.done ? [cur.value, iter] : null;\r\n            }\r\n            catch (err) {\r\n                return void 0;\r\n            }\r\n            finally {\r\n                finalFn();\r\n            }\r\n        }, iter);\r\n    });\r\n}\r\nexport function enumerateUsing(disp, work) {\r\n    var isDisposed = false;\r\n    var disposeOnce = function () {\r\n        if (!isDisposed) {\r\n            isDisposed = true;\r\n            disp.Dispose();\r\n        }\r\n    };\r\n    try {\r\n        return enumerateThenFinally(work(disp), disposeOnce);\r\n    }\r\n    catch (err) {\r\n        return void 0;\r\n    }\r\n    finally {\r\n        disposeOnce();\r\n    }\r\n}\r\nexport function exactlyOne(xs) {\r\n    var iter = xs[Symbol.iterator]();\r\n    var fst = iter.next();\r\n    if (fst.done)\r\n        throw new Error(\"Seq was empty\");\r\n    var snd = iter.next();\r\n    if (!snd.done)\r\n        throw new Error(\"Seq had multiple items\");\r\n    return fst.value;\r\n}\r\nexport function except(itemsToExclude, source) {\r\n    var exclusionItems = Array.from(itemsToExclude);\r\n    var testIsNotInExclusionItems = function (element) { return !exclusionItems.some(function (excludedItem) { return equals(excludedItem, element); }); };\r\n    return filter(testIsNotInExclusionItems, source);\r\n}\r\nexport function exists(f, xs) {\r\n    function aux(iter) {\r\n        var cur = iter.next();\r\n        return !cur.done && (f(cur.value) || aux(iter));\r\n    }\r\n    return aux(xs[Symbol.iterator]());\r\n}\r\nexport function exists2(f, xs, ys) {\r\n    function aux(iter1, iter2) {\r\n        var cur1 = iter1.next(), cur2 = iter2.next();\r\n        return !cur1.done && !cur2.done && (f(cur1.value, cur2.value) || aux(iter1, iter2));\r\n    }\r\n    return aux(xs[Symbol.iterator](), ys[Symbol.iterator]());\r\n}\r\nexport function filter(f, xs) {\r\n    function trySkipToNext(iter) {\r\n        var cur = iter.next();\r\n        while (!cur.done) {\r\n            if (f(cur.value)) {\r\n                return [cur.value, iter];\r\n            }\r\n            cur = iter.next();\r\n        }\r\n        return void 0;\r\n    }\r\n    return delay(function () { return unfold(trySkipToNext, xs[Symbol.iterator]()); });\r\n}\r\nexport function where(f, xs) {\r\n    return filter(f, xs);\r\n}\r\nexport function fold(f, acc, xs) {\r\n    if (Array.isArray(xs) || ArrayBuffer.isView(xs)) {\r\n        return xs.reduce(f, acc);\r\n    }\r\n    else {\r\n        var cur = void 0;\r\n        for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\r\n            cur = iter.next();\r\n            if (cur.done)\r\n                break;\r\n            acc = f(acc, cur.value, i);\r\n        }\r\n        return acc;\r\n    }\r\n}\r\nexport function foldBack(f, xs, acc) {\r\n    var arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\r\n    for (var i = arr.length - 1; i >= 0; i--) {\r\n        acc = f(arr[i], acc, i);\r\n    }\r\n    return acc;\r\n}\r\nexport function fold2(f, acc, xs, ys) {\r\n    var iter1 = xs[Symbol.iterator](), iter2 = ys[Symbol.iterator]();\r\n    var cur1, cur2;\r\n    for (var i = 0;; i++) {\r\n        cur1 = iter1.next();\r\n        cur2 = iter2.next();\r\n        if (cur1.done || cur2.done) {\r\n            break;\r\n        }\r\n        acc = f(acc, cur1.value, cur2.value, i);\r\n    }\r\n    return acc;\r\n}\r\nexport function foldBack2(f, xs, ys, acc) {\r\n    var ar1 = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\r\n    var ar2 = Array.isArray(ys) || ArrayBuffer.isView(ys) ? ys : Array.from(ys);\r\n    for (var i = ar1.length - 1; i >= 0; i--) {\r\n        acc = f(ar1[i], ar2[i], acc, i);\r\n    }\r\n    return acc;\r\n}\r\nexport function forAll(f, xs) {\r\n    return fold(function (acc, x) { return acc && f(x); }, true, xs);\r\n}\r\nexport function forAll2(f, xs, ys) {\r\n    return fold2(function (acc, x, y) { return acc && f(x, y); }, true, xs, ys);\r\n}\r\nexport function tryHead(xs) {\r\n    var iter = xs[Symbol.iterator]();\r\n    var cur = iter.next();\r\n    return cur.done ? null : cur.value;\r\n}\r\nexport function head(xs) {\r\n    return __failIfNone(tryHead(xs));\r\n}\r\nexport function initialize(n, f) {\r\n    return delay(function () {\r\n        return unfold(function (i) { return i < n ? [f(i), i + 1] : null; }, 0);\r\n    });\r\n}\r\nexport function initializeInfinite(f) {\r\n    return delay(function () {\r\n        return unfold(function (i) { return [f(i), i + 1]; }, 0);\r\n    });\r\n}\r\nexport function tryItem(i, xs) {\r\n    if (i < 0)\r\n        return null;\r\n    if (Array.isArray(xs) || ArrayBuffer.isView(xs))\r\n        return i < xs.length ? xs[i] : null;\r\n    for (var j = 0, iter = xs[Symbol.iterator]();; j++) {\r\n        var cur = iter.next();\r\n        if (cur.done)\r\n            return null;\r\n        if (j === i)\r\n            return cur.value;\r\n    }\r\n}\r\nexport function item(i, xs) {\r\n    return __failIfNone(tryItem(i, xs));\r\n}\r\nexport function iterate(f, xs) {\r\n    fold(function (_, x) { return f(x); }, null, xs);\r\n}\r\nexport function iterate2(f, xs, ys) {\r\n    fold2(function (_, x, y) { return f(x, y); }, null, xs, ys);\r\n}\r\nexport function iterateIndexed(f, xs) {\r\n    fold(function (_, x, i) { return f(i, x); }, null, xs);\r\n}\r\nexport function iterateIndexed2(f, xs, ys) {\r\n    fold2(function (_, x, y, i) { return f(i, x, y); }, null, xs, ys);\r\n}\r\nexport function isEmpty(xs) {\r\n    var i = xs[Symbol.iterator]();\r\n    return i.next().done;\r\n}\r\nexport function tryLast(xs) {\r\n    try {\r\n        return reduce(function (_, x) { return x; }, xs);\r\n    }\r\n    catch (err) {\r\n        return null;\r\n    }\r\n}\r\nexport function last(xs) {\r\n    return __failIfNone(tryLast(xs));\r\n}\r\nexport function count(xs) {\r\n    return Array.isArray(xs) || ArrayBuffer.isView(xs)\r\n        ? xs.length\r\n        : fold(function (acc, x) { return acc + 1; }, 0, xs);\r\n}\r\nexport function map(f, xs) {\r\n    return delay(function () { return unfold(function (iter) {\r\n        var cur = iter.next();\r\n        return !cur.done ? [f(cur.value), iter] : null;\r\n    }, xs[Symbol.iterator]()); });\r\n}\r\nexport function mapIndexed(f, xs) {\r\n    return delay(function () {\r\n        var i = 0;\r\n        return unfold(function (iter) {\r\n            var cur = iter.next();\r\n            return !cur.done ? [f(i++, cur.value), iter] : null;\r\n        }, xs[Symbol.iterator]());\r\n    });\r\n}\r\nexport function map2(f, xs, ys) {\r\n    return delay(function () {\r\n        var iter1 = xs[Symbol.iterator]();\r\n        var iter2 = ys[Symbol.iterator]();\r\n        return unfold(function () {\r\n            var cur1 = iter1.next(), cur2 = iter2.next();\r\n            return !cur1.done && !cur2.done ? [f(cur1.value, cur2.value), null] : null;\r\n        });\r\n    });\r\n}\r\nexport function mapIndexed2(f, xs, ys) {\r\n    return delay(function () {\r\n        var i = 0;\r\n        var iter1 = xs[Symbol.iterator]();\r\n        var iter2 = ys[Symbol.iterator]();\r\n        return unfold(function () {\r\n            var cur1 = iter1.next(), cur2 = iter2.next();\r\n            return !cur1.done && !cur2.done ? [f(i++, cur1.value, cur2.value), null] : null;\r\n        });\r\n    });\r\n}\r\nexport function map3(f, xs, ys, zs) {\r\n    return delay(function () {\r\n        var iter1 = xs[Symbol.iterator]();\r\n        var iter2 = ys[Symbol.iterator]();\r\n        var iter3 = zs[Symbol.iterator]();\r\n        return unfold(function () {\r\n            var cur1 = iter1.next(), cur2 = iter2.next(), cur3 = iter3.next();\r\n            return !cur1.done && !cur2.done && !cur3.done ? [f(cur1.value, cur2.value, cur3.value), null] : null;\r\n        });\r\n    });\r\n}\r\nexport function mapFold(f, acc, xs) {\r\n    var result = [];\r\n    var r;\r\n    var cur;\r\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\r\n        cur = iter.next();\r\n        if (cur.done)\r\n            break;\r\n        _a = f(acc, cur.value), r = _a[0], acc = _a[1];\r\n        result.push(r);\r\n    }\r\n    return [result, acc];\r\n    var _a;\r\n}\r\nexport function mapFoldBack(f, xs, acc) {\r\n    var arr = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\r\n    var result = [];\r\n    var r;\r\n    for (var i = arr.length - 1; i >= 0; i--) {\r\n        _a = f(arr[i], acc), r = _a[0], acc = _a[1];\r\n        result.push(r);\r\n    }\r\n    return [result, acc];\r\n    var _a;\r\n}\r\nexport function max(xs) {\r\n    return reduce(function (acc, x) { return compare(acc, x) === 1 ? acc : x; }, xs);\r\n}\r\nexport function maxBy(f, xs) {\r\n    return reduce(function (acc, x) { return compare(f(acc), f(x)) === 1 ? acc : x; }, xs);\r\n}\r\nexport function min(xs) {\r\n    return reduce(function (acc, x) { return compare(acc, x) === -1 ? acc : x; }, xs);\r\n}\r\nexport function minBy(f, xs) {\r\n    return reduce(function (acc, x) { return compare(f(acc), f(x)) === -1 ? acc : x; }, xs);\r\n}\r\nexport function pairwise(xs) {\r\n    return skip(2, scan(function (last, next) { return [last[1], next]; }, [0, 0], xs));\r\n}\r\nexport function permute(f, xs) {\r\n    return ofArray(arrayPermute(f, Array.from(xs)));\r\n}\r\nexport function rangeStep(first, step, last) {\r\n    if (step === 0)\r\n        throw new Error(\"Step cannot be 0\");\r\n    return delay(function () { return unfold(function (x) { return step > 0 && x <= last || step < 0 && x >= last ? [x, x + step] : null; }, first); });\r\n}\r\nexport function rangeChar(first, last) {\r\n    return delay(function () { return unfold(function (x) { return x <= last ? [x, String.fromCharCode(x.charCodeAt(0) + 1)] : null; }, first); });\r\n}\r\nexport function range(first, last) {\r\n    return rangeStep(first, 1, last);\r\n}\r\nexport function readOnly(xs) {\r\n    return map(function (x) { return x; }, xs);\r\n}\r\nexport function reduce(f, xs) {\r\n    if (Array.isArray(xs) || ArrayBuffer.isView(xs))\r\n        return xs.reduce(f);\r\n    var iter = xs[Symbol.iterator]();\r\n    var cur = iter.next();\r\n    if (cur.done)\r\n        throw new Error(\"Seq was empty\");\r\n    var acc = cur.value;\r\n    for (;;) {\r\n        cur = iter.next();\r\n        if (cur.done)\r\n            break;\r\n        acc = f(acc, cur.value);\r\n    }\r\n    return acc;\r\n}\r\nexport function reduceBack(f, xs) {\r\n    var ar = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs : Array.from(xs);\r\n    if (ar.length === 0)\r\n        throw new Error(\"Seq was empty\");\r\n    var acc = ar[ar.length - 1];\r\n    for (var i = ar.length - 2; i >= 0; i--)\r\n        acc = f(ar[i], acc, i);\r\n    return acc;\r\n}\r\nexport function replicate(n, x) {\r\n    return initialize(n, function () { return x; });\r\n}\r\nexport function reverse(xs) {\r\n    var ar = Array.isArray(xs) || ArrayBuffer.isView(xs) ? xs.slice(0) : Array.from(xs);\r\n    return ofArray(ar.reverse());\r\n}\r\nexport function scan(f, seed, xs) {\r\n    return delay(function () {\r\n        var iter = xs[Symbol.iterator]();\r\n        return unfold(function (acc) {\r\n            if (acc == null)\r\n                return [seed, seed];\r\n            var cur = iter.next();\r\n            if (!cur.done) {\r\n                acc = f(acc, cur.value);\r\n                return [acc, acc];\r\n            }\r\n            return void 0;\r\n        }, null);\r\n    });\r\n}\r\nexport function scanBack(f, xs, seed) {\r\n    return reverse(scan(function (acc, x) { return f(x, acc); }, seed, reverse(xs)));\r\n}\r\nexport function singleton(x) {\r\n    return unfold(function (x) { return x != null ? [x, null] : null; }, x);\r\n}\r\nexport function skip(n, xs) {\r\n    return _a = {},\r\n        _a[Symbol.iterator] = function () {\r\n            var iter = xs[Symbol.iterator]();\r\n            for (var i = 1; i <= n; i++)\r\n                if (iter.next().done)\r\n                    throw new Error(\"Seq has not enough elements\");\r\n            return iter;\r\n        },\r\n        _a;\r\n    var _a;\r\n}\r\nexport function skipWhile(f, xs) {\r\n    return delay(function () {\r\n        var hasPassed = false;\r\n        return filter(function (x) { return hasPassed || (hasPassed = !f(x)); }, xs);\r\n    });\r\n}\r\nexport function sortWith(f, xs) {\r\n    var ys = Array.from(xs);\r\n    return ofArray(ys.sort(f));\r\n}\r\nexport function sum(xs) {\r\n    return fold(function (acc, x) { return acc + x; }, 0, xs);\r\n}\r\nexport function sumBy(f, xs) {\r\n    return fold(function (acc, x) { return acc + f(x); }, 0, xs);\r\n}\r\nexport function tail(xs) {\r\n    var iter = xs[Symbol.iterator]();\r\n    var cur = iter.next();\r\n    if (cur.done)\r\n        throw new Error(\"Seq was empty\");\r\n    return _a = {},\r\n        _a[Symbol.iterator] = function () { return iter; },\r\n        _a;\r\n    var _a;\r\n}\r\nexport function take(n, xs, truncate) {\r\n    if (truncate === void 0) { truncate = false; }\r\n    return delay(function () {\r\n        var iter = xs[Symbol.iterator]();\r\n        return unfold(function (i) {\r\n            if (i < n) {\r\n                var cur = iter.next();\r\n                if (!cur.done)\r\n                    return [cur.value, i + 1];\r\n                if (!truncate)\r\n                    throw new Error(\"Seq has not enough elements\");\r\n            }\r\n            return void 0;\r\n        }, 0);\r\n    });\r\n}\r\nexport function truncate(n, xs) {\r\n    return take(n, xs, true);\r\n}\r\nexport function takeWhile(f, xs) {\r\n    return delay(function () {\r\n        var iter = xs[Symbol.iterator]();\r\n        return unfold(function (i) {\r\n            var cur = iter.next();\r\n            if (!cur.done && f(cur.value))\r\n                return [cur.value, null];\r\n            return void 0;\r\n        }, 0);\r\n    });\r\n}\r\nexport function tryFind(f, xs, defaultValue) {\r\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\r\n        var cur = iter.next();\r\n        if (cur.done)\r\n            return defaultValue === void 0 ? null : defaultValue;\r\n        if (f(cur.value, i))\r\n            return cur.value;\r\n    }\r\n}\r\nexport function find(f, xs) {\r\n    return __failIfNone(tryFind(f, xs));\r\n}\r\nexport function tryFindBack(f, xs, defaultValue) {\r\n    var match = null;\r\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\r\n        var cur = iter.next();\r\n        if (cur.done)\r\n            return match === null ? (defaultValue === void 0 ? null : defaultValue) : match;\r\n        if (f(cur.value, i))\r\n            match = cur.value;\r\n    }\r\n}\r\nexport function findBack(f, xs) {\r\n    return __failIfNone(tryFindBack(f, xs));\r\n}\r\nexport function tryFindIndex(f, xs) {\r\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\r\n        var cur = iter.next();\r\n        if (cur.done)\r\n            return null;\r\n        if (f(cur.value, i))\r\n            return i;\r\n    }\r\n}\r\nexport function findIndex(f, xs) {\r\n    return __failIfNone(tryFindIndex(f, xs));\r\n}\r\nexport function tryFindIndexBack(f, xs) {\r\n    var match = -1;\r\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\r\n        var cur = iter.next();\r\n        if (cur.done)\r\n            return match === -1 ? null : match;\r\n        if (f(cur.value, i))\r\n            match = i;\r\n    }\r\n}\r\nexport function findIndexBack(f, xs) {\r\n    return __failIfNone(tryFindIndexBack(f, xs));\r\n}\r\nexport function tryPick(f, xs) {\r\n    for (var i = 0, iter = xs[Symbol.iterator]();; i++) {\r\n        var cur = iter.next();\r\n        if (cur.done)\r\n            break;\r\n        var y = f(cur.value, i);\r\n        if (y != null)\r\n            return y;\r\n    }\r\n    return void 0;\r\n}\r\nexport function pick(f, xs) {\r\n    return __failIfNone(tryPick(f, xs));\r\n}\r\nexport function unfold(f, acc) {\r\n    return _a = {},\r\n        _a[Symbol.iterator] = function () {\r\n            return {\r\n                next: function () {\r\n                    var res = f(acc);\r\n                    if (res != null) {\r\n                        acc = res[1];\r\n                        return { done: false, value: res[0] };\r\n                    }\r\n                    return { done: true };\r\n                }\r\n            };\r\n        },\r\n        _a;\r\n    var _a;\r\n}\r\nexport function zip(xs, ys) {\r\n    return map2(function (x, y) { return [x, y]; }, xs, ys);\r\n}\r\nexport function zip3(xs, ys, zs) {\r\n    return map3(function (x, y, z) { return [x, y, z]; }, xs, ys, zs);\r\n}\r\n","export function create(pattern, options) {\r\n    var flags = \"g\";\r\n    flags += options & 1 ? \"i\" : \"\";\r\n    flags += options & 2 ? \"m\" : \"\";\r\n    return new RegExp(pattern, flags);\r\n}\r\nexport function escape(str) {\r\n    return str.replace(/[\\-\\[\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\r\n}\r\nexport function unescape(str) {\r\n    return str.replace(/\\\\([\\-\\[\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|])/g, \"$1\");\r\n}\r\nexport function isMatch(str, pattern, options) {\r\n    if (options === void 0) { options = 0; }\r\n    var reg = str instanceof RegExp\r\n        ? (reg = str, str = pattern, reg.lastIndex = options, reg)\r\n        : reg = create(pattern, options);\r\n    return reg.test(str);\r\n}\r\nexport function match(str, pattern, options) {\r\n    if (options === void 0) { options = 0; }\r\n    var reg = str instanceof RegExp\r\n        ? (reg = str, str = pattern, reg.lastIndex = options, reg)\r\n        : reg = create(pattern, options);\r\n    return reg.exec(str);\r\n}\r\nexport function matches(str, pattern, options) {\r\n    if (options === void 0) { options = 0; }\r\n    var reg = str instanceof RegExp\r\n        ? (reg = str, str = pattern, reg.lastIndex = options, reg)\r\n        : reg = create(pattern, options);\r\n    if (!reg.global)\r\n        throw new Error(\"Non-global RegExp\");\r\n    var m;\r\n    var matches = [];\r\n    while ((m = reg.exec(str)) !== null)\r\n        matches.push(m);\r\n    return matches;\r\n}\r\nexport function options(reg) {\r\n    var options = 256;\r\n    options |= reg.ignoreCase ? 1 : 0;\r\n    options |= reg.multiline ? 2 : 0;\r\n    return options;\r\n}\r\nexport function replace(reg, input, replacement, limit, offset) {\r\n    if (offset === void 0) { offset = 0; }\r\n    function replacer() {\r\n        var res = arguments[0];\r\n        if (limit !== 0) {\r\n            limit--;\r\n            var match_1 = [];\r\n            var len = arguments.length;\r\n            for (var i = 0; i < len - 2; i++)\r\n                match_1.push(arguments[i]);\r\n            match_1.index = arguments[len - 2];\r\n            match_1.input = arguments[len - 1];\r\n            res = replacement(match_1);\r\n        }\r\n        return res;\r\n    }\r\n    if (typeof reg == \"string\") {\r\n        var tmp = reg;\r\n        reg = create(input, limit);\r\n        input = tmp;\r\n        limit = undefined;\r\n    }\r\n    if (typeof replacement == \"function\") {\r\n        limit = limit == null ? -1 : limit;\r\n        return input.substring(0, offset) + input.substring(offset).replace(reg, replacer);\r\n    }\r\n    else {\r\n        if (limit != null) {\r\n            var m = void 0;\r\n            var sub1 = input.substring(offset);\r\n            var _matches = matches(reg, sub1);\r\n            var sub2 = matches.length > limit ? (m = _matches[limit - 1], sub1.substring(0, m.index + m[0].length)) : sub1;\r\n            return input.substring(0, offset) + sub2.replace(reg, replacement) + input.substring(offset + sub2.length);\r\n        }\r\n        else {\r\n            return input.replace(reg, replacement);\r\n        }\r\n    }\r\n}\r\nexport function split(reg, input, limit, offset) {\r\n    if (offset === void 0) { offset = 0; }\r\n    if (typeof reg == \"string\") {\r\n        var tmp = reg;\r\n        reg = create(input, limit);\r\n        input = tmp;\r\n        limit = undefined;\r\n    }\r\n    input = input.substring(offset);\r\n    return input.split(reg, limit);\r\n}\r\n","import _Symbol from \"./Symbol\";\r\nvar Long = (function () {\r\n    function Long(low, high, unsigned) {\r\n        this.eq = this.equals;\r\n        this.neq = this.notEquals;\r\n        this.lt = this.lessThan;\r\n        this.lte = this.lessThanOrEqual;\r\n        this.gt = this.greaterThan;\r\n        this.gte = this.greaterThanOrEqual;\r\n        this.comp = this.compare;\r\n        this.neg = this.negate;\r\n        this.abs = this.absolute;\r\n        this.sub = this.subtract;\r\n        this.mul = this.multiply;\r\n        this.div = this.divide;\r\n        this.mod = this.modulo;\r\n        this.shl = this.shiftLeft;\r\n        this.shr = this.shiftRight;\r\n        this.shru = this.shiftRightUnsigned;\r\n        this.Equals = this.equals;\r\n        this.CompareTo = this.compare;\r\n        this.ToString = this.toString;\r\n        this.low = low | 0;\r\n        this.high = high | 0;\r\n        this.unsigned = !!unsigned;\r\n    }\r\n    Long.prototype.toInt = function () {\r\n        return this.unsigned ? this.low >>> 0 : this.low;\r\n    };\r\n    Long.prototype.toNumber = function () {\r\n        if (this.unsigned)\r\n            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\r\n        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\r\n    };\r\n    Long.prototype.toString = function (radix) {\r\n        if (radix === void 0) { radix = 10; }\r\n        radix = radix || 10;\r\n        if (radix < 2 || 36 < radix)\r\n            throw RangeError('radix');\r\n        if (this.isZero())\r\n            return '0';\r\n        if (this.isNegative()) {\r\n            if (this.eq(MIN_VALUE)) {\r\n                var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\r\n                return div.toString(radix) + rem1.toInt().toString(radix);\r\n            }\r\n            else\r\n                return '-' + this.neg().toString(radix);\r\n        }\r\n        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;\r\n        var result = '';\r\n        while (true) {\r\n            var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);\r\n            rem = remDiv;\r\n            if (rem.isZero())\r\n                return digits + result;\r\n            else {\r\n                while (digits.length < 6)\r\n                    digits = '0' + digits;\r\n                result = '' + digits + result;\r\n            }\r\n        }\r\n    };\r\n    Long.prototype.getHighBits = function () {\r\n        return this.high;\r\n    };\r\n    Long.prototype.getHighBitsUnsigned = function () {\r\n        return this.high >>> 0;\r\n    };\r\n    Long.prototype.getLowBits = function () {\r\n        return this.low;\r\n    };\r\n    Long.prototype.getLowBitsUnsigned = function () {\r\n        return this.low >>> 0;\r\n    };\r\n    Long.prototype.getNumBitsAbs = function () {\r\n        if (this.isNegative())\r\n            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\r\n        var val = this.high != 0 ? this.high : this.low;\r\n        for (var bit = 31; bit > 0; bit--)\r\n            if ((val & (1 << bit)) != 0)\r\n                break;\r\n        return this.high != 0 ? bit + 33 : bit + 1;\r\n    };\r\n    Long.prototype.isZero = function () {\r\n        return this.high === 0 && this.low === 0;\r\n    };\r\n    Long.prototype.isNegative = function () {\r\n        return !this.unsigned && this.high < 0;\r\n    };\r\n    Long.prototype.isPositive = function () {\r\n        return this.unsigned || this.high >= 0;\r\n    };\r\n    Long.prototype.isOdd = function () {\r\n        return (this.low & 1) === 1;\r\n    };\r\n    Long.prototype.isEven = function () {\r\n        return (this.low & 1) === 0;\r\n    };\r\n    Long.prototype.equals = function (other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\r\n            return false;\r\n        return this.high === other.high && this.low === other.low;\r\n    };\r\n    Long.prototype.notEquals = function (other) {\r\n        return !this.eq(other);\r\n    };\r\n    Long.prototype.lessThan = function (other) {\r\n        return this.comp(other) < 0;\r\n    };\r\n    Long.prototype.lessThanOrEqual = function (other) {\r\n        return this.comp(other) <= 0;\r\n    };\r\n    Long.prototype.greaterThan = function (other) {\r\n        return this.comp(other) > 0;\r\n    };\r\n    Long.prototype.greaterThanOrEqual = function (other) {\r\n        return this.comp(other) >= 0;\r\n    };\r\n    Long.prototype.compare = function (other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        if (this.eq(other))\r\n            return 0;\r\n        var thisNeg = this.isNegative(), otherNeg = other.isNegative();\r\n        if (thisNeg && !otherNeg)\r\n            return -1;\r\n        if (!thisNeg && otherNeg)\r\n            return 1;\r\n        if (!this.unsigned)\r\n            return this.sub(other).isNegative() ? -1 : 1;\r\n        return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\r\n    };\r\n    Long.prototype.negate = function () {\r\n        if (!this.unsigned && this.eq(MIN_VALUE))\r\n            return MIN_VALUE;\r\n        return this.not().add(ONE);\r\n    };\r\n    Long.prototype.absolute = function () {\r\n        if (!this.unsigned && this.isNegative())\r\n            return this.negate();\r\n        else\r\n            return this;\r\n    };\r\n    Long.prototype.add = function (addend) {\r\n        if (!isLong(addend))\r\n            addend = fromValue(addend);\r\n        var a48 = this.high >>> 16;\r\n        var a32 = this.high & 0xFFFF;\r\n        var a16 = this.low >>> 16;\r\n        var a00 = this.low & 0xFFFF;\r\n        var b48 = addend.high >>> 16;\r\n        var b32 = addend.high & 0xFFFF;\r\n        var b16 = addend.low >>> 16;\r\n        var b00 = addend.low & 0xFFFF;\r\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n        c00 += a00 + b00;\r\n        c16 += c00 >>> 16;\r\n        c00 &= 0xFFFF;\r\n        c16 += a16 + b16;\r\n        c32 += c16 >>> 16;\r\n        c16 &= 0xFFFF;\r\n        c32 += a32 + b32;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c48 += a48 + b48;\r\n        c48 &= 0xFFFF;\r\n        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n    };\r\n    Long.prototype.subtract = function (subtrahend) {\r\n        if (!isLong(subtrahend))\r\n            subtrahend = fromValue(subtrahend);\r\n        return this.add(subtrahend.neg());\r\n    };\r\n    Long.prototype.multiply = function (multiplier) {\r\n        if (this.isZero())\r\n            return ZERO;\r\n        if (!isLong(multiplier))\r\n            multiplier = fromValue(multiplier);\r\n        if (multiplier.isZero())\r\n            return ZERO;\r\n        if (this.eq(MIN_VALUE))\r\n            return multiplier.isOdd() ? MIN_VALUE : ZERO;\r\n        if (multiplier.eq(MIN_VALUE))\r\n            return this.isOdd() ? MIN_VALUE : ZERO;\r\n        if (this.isNegative()) {\r\n            if (multiplier.isNegative())\r\n                return this.neg().mul(multiplier.neg());\r\n            else\r\n                return this.neg().mul(multiplier).neg();\r\n        }\r\n        else if (multiplier.isNegative())\r\n            return this.mul(multiplier.neg()).neg();\r\n        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\r\n            return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\r\n        var a48 = this.high >>> 16;\r\n        var a32 = this.high & 0xFFFF;\r\n        var a16 = this.low >>> 16;\r\n        var a00 = this.low & 0xFFFF;\r\n        var b48 = multiplier.high >>> 16;\r\n        var b32 = multiplier.high & 0xFFFF;\r\n        var b16 = multiplier.low >>> 16;\r\n        var b00 = multiplier.low & 0xFFFF;\r\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n        c00 += a00 * b00;\r\n        c16 += c00 >>> 16;\r\n        c00 &= 0xFFFF;\r\n        c16 += a16 * b00;\r\n        c32 += c16 >>> 16;\r\n        c16 &= 0xFFFF;\r\n        c16 += a00 * b16;\r\n        c32 += c16 >>> 16;\r\n        c16 &= 0xFFFF;\r\n        c32 += a32 * b00;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c32 += a16 * b16;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c32 += a00 * b32;\r\n        c48 += c32 >>> 16;\r\n        c32 &= 0xFFFF;\r\n        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\r\n        c48 &= 0xFFFF;\r\n        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n    };\r\n    Long.prototype.divide = function (divisor) {\r\n        if (!isLong(divisor))\r\n            divisor = fromValue(divisor);\r\n        if (divisor.isZero())\r\n            throw Error('division by zero');\r\n        if (this.isZero())\r\n            return this.unsigned ? UZERO : ZERO;\r\n        var approx = 0, rem = ZERO, res = ZERO;\r\n        if (!this.unsigned) {\r\n            if (this.eq(MIN_VALUE)) {\r\n                if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\r\n                    return MIN_VALUE;\r\n                else if (divisor.eq(MIN_VALUE))\r\n                    return ONE;\r\n                else {\r\n                    var halfThis = this.shr(1);\r\n                    var approx_1 = halfThis.div(divisor).shl(1);\r\n                    if (approx_1.eq(ZERO)) {\r\n                        return divisor.isNegative() ? ONE : NEG_ONE;\r\n                    }\r\n                    else {\r\n                        rem = this.sub(divisor.mul(approx_1));\r\n                        res = approx_1.add(rem.div(divisor));\r\n                        return res;\r\n                    }\r\n                }\r\n            }\r\n            else if (divisor.eq(MIN_VALUE))\r\n                return this.unsigned ? UZERO : ZERO;\r\n            if (this.isNegative()) {\r\n                if (divisor.isNegative())\r\n                    return this.neg().div(divisor.neg());\r\n                return this.neg().div(divisor).neg();\r\n            }\r\n            else if (divisor.isNegative())\r\n                return this.div(divisor.neg()).neg();\r\n            res = ZERO;\r\n        }\r\n        else {\r\n            if (!divisor.unsigned)\r\n                divisor = divisor.toUnsigned();\r\n            if (divisor.gt(this))\r\n                return UZERO;\r\n            if (divisor.gt(this.shru(1)))\r\n                return UONE;\r\n            res = UZERO;\r\n        }\r\n        rem = this;\r\n        while (rem.gte(divisor)) {\r\n            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\r\n            var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);\r\n            while (approxRem.isNegative() || approxRem.gt(rem)) {\r\n                approx -= delta;\r\n                approxRes = fromNumber(approx, this.unsigned);\r\n                approxRem = approxRes.mul(divisor);\r\n            }\r\n            if (approxRes.isZero())\r\n                approxRes = ONE;\r\n            res = res.add(approxRes);\r\n            rem = rem.sub(approxRem);\r\n        }\r\n        return res;\r\n    };\r\n    Long.prototype.modulo = function (divisor) {\r\n        if (!isLong(divisor))\r\n            divisor = fromValue(divisor);\r\n        return this.sub(this.div(divisor).mul(divisor));\r\n    };\r\n    ;\r\n    Long.prototype.not = function () {\r\n        return fromBits(~this.low, ~this.high, this.unsigned);\r\n    };\r\n    ;\r\n    Long.prototype.and = function (other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\r\n    };\r\n    Long.prototype.or = function (other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\r\n    };\r\n    Long.prototype.xor = function (other) {\r\n        if (!isLong(other))\r\n            other = fromValue(other);\r\n        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\r\n    };\r\n    Long.prototype.shiftLeft = function (numBits) {\r\n        if (isLong(numBits))\r\n            numBits = numBits.toInt();\r\n        numBits = numBits & 63;\r\n        if (numBits === 0)\r\n            return this;\r\n        else if (numBits < 32)\r\n            return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\r\n        else\r\n            return fromBits(0, this.low << (numBits - 32), this.unsigned);\r\n    };\r\n    Long.prototype.shiftRight = function (numBits) {\r\n        if (isLong(numBits))\r\n            numBits = numBits.toInt();\r\n        numBits = numBits & 63;\r\n        if (numBits === 0)\r\n            return this;\r\n        else if (numBits < 32)\r\n            return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\r\n        else\r\n            return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\r\n    };\r\n    Long.prototype.shiftRightUnsigned = function (numBits) {\r\n        if (isLong(numBits))\r\n            numBits = numBits.toInt();\r\n        numBits = numBits & 63;\r\n        if (numBits === 0)\r\n            return this;\r\n        else {\r\n            var high = this.high;\r\n            if (numBits < 32) {\r\n                var low = this.low;\r\n                return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\r\n            }\r\n            else if (numBits === 32)\r\n                return fromBits(high, 0, this.unsigned);\r\n            else\r\n                return fromBits(high >>> (numBits - 32), 0, this.unsigned);\r\n        }\r\n    };\r\n    Long.prototype.toSigned = function () {\r\n        if (!this.unsigned)\r\n            return this;\r\n        return fromBits(this.low, this.high, false);\r\n    };\r\n    Long.prototype.toUnsigned = function () {\r\n        if (this.unsigned)\r\n            return this;\r\n        return fromBits(this.low, this.high, true);\r\n    };\r\n    Long.prototype.toBytes = function (le) {\r\n        return le ? this.toBytesLE() : this.toBytesBE();\r\n    };\r\n    Long.prototype.toBytesLE = function () {\r\n        var hi = this.high, lo = this.low;\r\n        return [\r\n            lo & 0xff,\r\n            (lo >>> 8) & 0xff,\r\n            (lo >>> 16) & 0xff,\r\n            (lo >>> 24) & 0xff,\r\n            hi & 0xff,\r\n            (hi >>> 8) & 0xff,\r\n            (hi >>> 16) & 0xff,\r\n            (hi >>> 24) & 0xff\r\n        ];\r\n    };\r\n    Long.prototype.toBytesBE = function () {\r\n        var hi = this.high, lo = this.low;\r\n        return [\r\n            (hi >>> 24) & 0xff,\r\n            (hi >>> 16) & 0xff,\r\n            (hi >>> 8) & 0xff,\r\n            hi & 0xff,\r\n            (lo >>> 24) & 0xff,\r\n            (lo >>> 16) & 0xff,\r\n            (lo >>> 8) & 0xff,\r\n            lo & 0xff\r\n        ];\r\n    };\r\n    Long.prototype[_Symbol.reflection] = function () {\r\n        return {\r\n            type: \"System.Int64\",\r\n            interfaces: [\"FSharpRecord\", \"System.IComparable\"],\r\n            properties: {\r\n                low: \"number\",\r\n                high: \"number\",\r\n                unsigned: \"boolean\"\r\n            }\r\n        };\r\n    };\r\n    return Long;\r\n}());\r\nexport { Long };\r\nvar INT_CACHE = {};\r\nvar UINT_CACHE = {};\r\nexport function isLong(obj) {\r\n    return (obj && obj instanceof Long);\r\n}\r\nexport function fromInt(value, unsigned) {\r\n    if (unsigned === void 0) { unsigned = false; }\r\n    var obj, cachedObj, cache;\r\n    if (unsigned) {\r\n        value >>>= 0;\r\n        if (cache = (0 <= value && value < 256)) {\r\n            cachedObj = UINT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\r\n        if (cache)\r\n            UINT_CACHE[value] = obj;\r\n        return obj;\r\n    }\r\n    else {\r\n        value |= 0;\r\n        if (cache = (-128 <= value && value < 128)) {\r\n            cachedObj = INT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\r\n        if (cache)\r\n            INT_CACHE[value] = obj;\r\n        return obj;\r\n    }\r\n}\r\nexport function fromNumber(value, unsigned) {\r\n    if (unsigned === void 0) { unsigned = false; }\r\n    if (isNaN(value) || !isFinite(value))\r\n        return unsigned ? UZERO : ZERO;\r\n    if (unsigned) {\r\n        if (value < 0)\r\n            return UZERO;\r\n        if (value >= TWO_PWR_64_DBL)\r\n            return MAX_UNSIGNED_VALUE;\r\n    }\r\n    else {\r\n        if (value <= -TWO_PWR_63_DBL)\r\n            return MIN_VALUE;\r\n        if (value + 1 >= TWO_PWR_63_DBL)\r\n            return MAX_VALUE;\r\n    }\r\n    if (value < 0)\r\n        return fromNumber(-value, unsigned).neg();\r\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\r\n}\r\nexport function fromBits(lowBits, highBits, unsigned) {\r\n    return new Long(lowBits, highBits, unsigned);\r\n}\r\nvar pow_dbl = Math.pow;\r\nexport function fromString(str, unsigned, radix) {\r\n    if (unsigned === void 0) { unsigned = false; }\r\n    if (radix === void 0) { radix = 10; }\r\n    if (str.length === 0)\r\n        throw Error('empty string');\r\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\r\n        return ZERO;\r\n    if (typeof unsigned === 'number') {\r\n        radix = unsigned,\r\n            unsigned = false;\r\n    }\r\n    else {\r\n        unsigned = !!unsigned;\r\n    }\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n    var p = str.indexOf('-');\r\n    if (p > 0)\r\n        throw Error('interior hyphen');\r\n    else if (p === 0) {\r\n        return fromString(str.substring(1), unsigned, radix).neg();\r\n    }\r\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\r\n    var result = ZERO;\r\n    for (var i = 0; i < str.length; i += 8) {\r\n        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\r\n        if (size < 8) {\r\n            var power = fromNumber(pow_dbl(radix, size));\r\n            result = result.mul(power).add(fromNumber(value));\r\n        }\r\n        else {\r\n            result = result.mul(radixToPower);\r\n            result = result.add(fromNumber(value));\r\n        }\r\n    }\r\n    result.unsigned = unsigned;\r\n    return result;\r\n}\r\nexport function fromValue(val) {\r\n    if (val instanceof Long)\r\n        return val;\r\n    if (typeof val === 'number')\r\n        return fromNumber(val);\r\n    if (typeof val === 'string')\r\n        return fromString(val);\r\n    return fromBits(val.low, val.high, val.unsigned);\r\n}\r\nvar TWO_PWR_16_DBL = 1 << 16;\r\nvar TWO_PWR_24_DBL = 1 << 24;\r\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\r\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\r\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\r\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\r\nexport var ZERO = fromInt(0);\r\nexport var UZERO = fromInt(0, true);\r\nexport var ONE = fromInt(1);\r\nexport var UONE = fromInt(1, true);\r\nexport var NEG_ONE = fromInt(-1);\r\nexport var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);\r\nexport var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);\r\nexport var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);\r\n","import { compare as utilCompare } from \"./Util\";\r\nimport * as Long from \"./Long\";\r\nexport function create(d, h, m, s, ms) {\r\n    if (d === void 0) { d = 0; }\r\n    if (h === void 0) { h = 0; }\r\n    if (m === void 0) { m = 0; }\r\n    if (s === void 0) { s = 0; }\r\n    if (ms === void 0) { ms = 0; }\r\n    switch (arguments.length) {\r\n        case 1:\r\n            return fromTicks(arguments[0]);\r\n        case 3:\r\n            d = 0, h = arguments[0], m = arguments[1], s = arguments[2], ms = 0;\r\n            break;\r\n        default:\r\n            d = arguments[0], h = arguments[1], m = arguments[2], s = arguments[3], ms = arguments[4] || 0;\r\n            break;\r\n    }\r\n    return d * 86400000 + h * 3600000 + m * 60000 + s * 1000 + ms;\r\n}\r\nexport function fromTicks(ticks) {\r\n    return ticks.div(10000).toNumber();\r\n}\r\nexport function fromDays(d) {\r\n    return create(d, 0, 0, 0);\r\n}\r\nexport function fromHours(h) {\r\n    return create(h, 0, 0);\r\n}\r\nexport function fromMinutes(m) {\r\n    return create(0, m, 0);\r\n}\r\nexport function fromSeconds(s) {\r\n    return create(0, 0, s);\r\n}\r\nexport function days(ts) {\r\n    return Math.floor(ts / 86400000);\r\n}\r\nexport function hours(ts) {\r\n    return Math.floor(ts % 86400000 / 3600000);\r\n}\r\nexport function minutes(ts) {\r\n    return Math.floor(ts % 3600000 / 60000);\r\n}\r\nexport function seconds(ts) {\r\n    return Math.floor(ts % 60000 / 1000);\r\n}\r\nexport function milliseconds(ts) {\r\n    return Math.floor(ts % 1000);\r\n}\r\nexport function ticks(ts) {\r\n    return Long.fromNumber(ts).mul(10000);\r\n}\r\nexport function totalDays(ts) {\r\n    return ts / 86400000;\r\n}\r\nexport function totalHours(ts) {\r\n    return ts / 3600000;\r\n}\r\nexport function totalMinutes(ts) {\r\n    return ts / 60000;\r\n}\r\nexport function totalSeconds(ts) {\r\n    return ts / 1000;\r\n}\r\nexport function negate(ts) {\r\n    return ts * -1;\r\n}\r\nexport function add(ts1, ts2) {\r\n    return ts1 + ts2;\r\n}\r\nexport function subtract(ts1, ts2) {\r\n    return ts1 - ts2;\r\n}\r\nexport function compare(x, y) {\r\n    return utilCompare(x, y);\r\n}\r\nexport function compareTo(x, y) {\r\n    return utilCompare(x, y);\r\n}\r\nexport function duration(x) {\r\n    return Math.abs(x);\r\n}\r\n","import { create as timeSpanCreate } from \"./TimeSpan\";\r\nimport { compare as utilCompare } from \"./Util\";\r\nimport * as Long from \"./Long\";\r\nexport function minValue() {\r\n    return parse(-8640000000000000, 1);\r\n}\r\nexport function maxValue() {\r\n    return parse(8640000000000000, 1);\r\n}\r\nexport function parse(v, kind) {\r\n    if (kind == null) {\r\n        kind = typeof v == \"string\" && v.slice(-1) == \"Z\" ? 1 : 2;\r\n    }\r\n    var date = (v == null) ? new Date() : new Date(v);\r\n    if (kind === 2) {\r\n        date.kind = kind;\r\n    }\r\n    if (isNaN(date.getTime())) {\r\n        throw new Error(\"The string is not a valid Date.\");\r\n    }\r\n    return date;\r\n}\r\nexport function tryParse(v) {\r\n    try {\r\n        return [true, parse(v)];\r\n    }\r\n    catch (_err) {\r\n        return [false, minValue()];\r\n    }\r\n}\r\nexport function create(year, month, day, h, m, s, ms, kind) {\r\n    if (h === void 0) { h = 0; }\r\n    if (m === void 0) { m = 0; }\r\n    if (s === void 0) { s = 0; }\r\n    if (ms === void 0) { ms = 0; }\r\n    if (kind === void 0) { kind = 2; }\r\n    var date;\r\n    if (kind === 2) {\r\n        date = new Date(year, month - 1, day, h, m, s, ms);\r\n        date.kind = kind;\r\n    }\r\n    else {\r\n        date = new Date(Date.UTC(year, month - 1, day, h, m, s, ms));\r\n    }\r\n    if (isNaN(date.getTime())) {\r\n        throw new Error(\"The parameters describe an unrepresentable Date.\");\r\n    }\r\n    return date;\r\n}\r\nexport function now() {\r\n    return parse();\r\n}\r\nexport function utcNow() {\r\n    return parse(null, 1);\r\n}\r\nexport function today() {\r\n    return date(now());\r\n}\r\nexport function isLeapYear(year) {\r\n    return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;\r\n}\r\nexport function daysInMonth(year, month) {\r\n    return month == 2\r\n        ? isLeapYear(year) ? 29 : 28\r\n        : month >= 8 ? month % 2 == 0 ? 31 : 30 : month % 2 == 0 ? 30 : 31;\r\n}\r\nexport function toUniversalTime(d) {\r\n    return d.kind === 2 ? new Date(d.getTime()) : d;\r\n}\r\nexport function toLocalTime(d) {\r\n    if (d.kind === 2) {\r\n        return d;\r\n    }\r\n    else {\r\n        var d2 = new Date(d.getTime());\r\n        d2.kind = 2;\r\n        return d2;\r\n    }\r\n}\r\nexport function timeOfDay(d) {\r\n    return timeSpanCreate(0, hour(d), minute(d), second(d), millisecond(d));\r\n}\r\nexport function date(d) {\r\n    return create(year(d), month(d), day(d), 0, 0, 0, 0, d.kind || 1);\r\n}\r\nexport function kind(d) {\r\n    return d.kind || 1;\r\n}\r\nexport function day(d) {\r\n    return d.kind === 2 ? d.getDate() : d.getUTCDate();\r\n}\r\nexport function hour(d) {\r\n    return d.kind === 2 ? d.getHours() : d.getUTCHours();\r\n}\r\nexport function millisecond(d) {\r\n    return d.kind === 2 ? d.getMilliseconds() : d.getUTCMilliseconds();\r\n}\r\nexport function minute(d) {\r\n    return d.kind === 2 ? d.getMinutes() : d.getUTCMinutes();\r\n}\r\nexport function month(d) {\r\n    return (d.kind === 2 ? d.getMonth() : d.getUTCMonth()) + 1;\r\n}\r\nexport function second(d) {\r\n    return d.kind === 2 ? d.getSeconds() : d.getUTCSeconds();\r\n}\r\nexport function year(d) {\r\n    return d.kind === 2 ? d.getFullYear() : d.getUTCFullYear();\r\n}\r\nexport function dayOfWeek(d) {\r\n    return d.kind === 2 ? d.getDay() : d.getUTCDay();\r\n}\r\nexport function ticks(d) {\r\n    return Long.fromNumber(d.getTime())\r\n        .add(62135596800000)\r\n        .sub(d.kind == 2 ? d.getTimezoneOffset() * 60 * 1000 : 0)\r\n        .mul(10000);\r\n}\r\nexport function toBinary(d) {\r\n    return ticks(d);\r\n}\r\nexport function dayOfYear(d) {\r\n    var _year = year(d);\r\n    var _month = month(d);\r\n    var _day = day(d);\r\n    for (var i = 1; i < _month; i++)\r\n        _day += daysInMonth(_year, i);\r\n    return _day;\r\n}\r\nexport function add(d, ts) {\r\n    return parse(d.getTime() + ts, d.kind || 1);\r\n}\r\nexport function addDays(d, v) {\r\n    return parse(d.getTime() + v * 86400000, d.kind || 1);\r\n}\r\nexport function addHours(d, v) {\r\n    return parse(d.getTime() + v * 3600000, d.kind || 1);\r\n}\r\nexport function addMinutes(d, v) {\r\n    return parse(d.getTime() + v * 60000, d.kind || 1);\r\n}\r\nexport function addSeconds(d, v) {\r\n    return parse(d.getTime() + v * 1000, d.kind || 1);\r\n}\r\nexport function addMilliseconds(d, v) {\r\n    return parse(d.getTime() + v, d.kind || 1);\r\n}\r\nexport function addTicks(d, t) {\r\n    return parse(Long.fromNumber(d.getTime()).add(t.div(10000)).toNumber(), d.kind || 1);\r\n}\r\nexport function addYears(d, v) {\r\n    var newMonth = month(d);\r\n    var newYear = year(d) + v;\r\n    var _daysInMonth = daysInMonth(newYear, newMonth);\r\n    var newDay = Math.min(_daysInMonth, day(d));\r\n    return create(newYear, newMonth, newDay, hour(d), minute(d), second(d), millisecond(d), d.kind || 1);\r\n}\r\nexport function addMonths(d, v) {\r\n    var newMonth = month(d) + v;\r\n    var newMonth_ = 0;\r\n    var yearOffset = 0;\r\n    if (newMonth > 12) {\r\n        newMonth_ = newMonth % 12;\r\n        yearOffset = Math.floor(newMonth / 12);\r\n        newMonth = newMonth_;\r\n    }\r\n    else if (newMonth < 1) {\r\n        newMonth_ = 12 + newMonth % 12;\r\n        yearOffset = Math.floor(newMonth / 12) + (newMonth_ == 12 ? -1 : 0);\r\n        newMonth = newMonth_;\r\n    }\r\n    var newYear = year(d) + yearOffset;\r\n    var _daysInMonth = daysInMonth(newYear, newMonth);\r\n    var newDay = Math.min(_daysInMonth, day(d));\r\n    return create(newYear, newMonth, newDay, hour(d), minute(d), second(d), millisecond(d), d.kind || 1);\r\n}\r\nexport function subtract(d, that) {\r\n    return typeof that == \"number\"\r\n        ? parse(d.getTime() - that, d.kind || 1)\r\n        : d.getTime() - that.getTime();\r\n}\r\nexport function toLongDateString(d) {\r\n    return d.toDateString();\r\n}\r\nexport function toShortDateString(d) {\r\n    return d.toLocaleDateString();\r\n}\r\nexport function toLongTimeString(d) {\r\n    return d.toLocaleTimeString();\r\n}\r\nexport function toShortTimeString(d) {\r\n    return d.toLocaleTimeString().replace(/:\\d\\d(?!:)/, \"\");\r\n}\r\nexport function equals(d1, d2) {\r\n    return d1.getTime() == d2.getTime();\r\n}\r\nexport function compare(x, y) {\r\n    return utilCompare(x, y);\r\n}\r\nexport function compareTo(x, y) {\r\n    return utilCompare(x, y);\r\n}\r\nexport function op_Addition(x, y) {\r\n    return add(x, y);\r\n}\r\nexport function op_Subtraction(x, y) {\r\n    return subtract(x, y);\r\n}\r\n","import { toString } from \"./Util\";\r\nimport { getRestParams } from \"./Util\";\r\nimport { escape } from \"./RegExp\";\r\nimport { second } from \"./Date\";\r\nimport { minute } from \"./Date\";\r\nimport { hour } from \"./Date\";\r\nimport { day } from \"./Date\";\r\nimport { month } from \"./Date\";\r\nimport { year } from \"./Date\";\r\nvar fsFormatRegExp = /(^|[^%])%([0+ ]*)(-?\\d+)?(?:\\.(\\d+))?(\\w)/;\r\nvar formatRegExp = /\\{(\\d+)(,-?\\d+)?(?:\\:(.+?))?\\}/g;\r\nvar StringComparison = {\r\n    CurrentCulture: 0,\r\n    CurrentCultureIgnoreCase: 1,\r\n    InvariantCulture: 2,\r\n    InvariantCultureIgnoreCase: 3,\r\n    Ordinal: 4,\r\n    OrdinalIgnoreCase: 5,\r\n};\r\nfunction cmp(x, y, ic) {\r\n    function isIgnoreCase(i) {\r\n        return i === true ||\r\n            i === StringComparison.CurrentCultureIgnoreCase ||\r\n            i === StringComparison.InvariantCultureIgnoreCase ||\r\n            i === StringComparison.OrdinalIgnoreCase;\r\n    }\r\n    function isOrdinal(i) {\r\n        return i === StringComparison.Ordinal ||\r\n            i === StringComparison.OrdinalIgnoreCase;\r\n    }\r\n    if (x == null)\r\n        return y == null ? 0 : -1;\r\n    if (y == null)\r\n        return 1;\r\n    if (isOrdinal(ic)) {\r\n        if (isIgnoreCase(ic)) {\r\n            x = x.toLowerCase();\r\n            y = y.toLowerCase();\r\n        }\r\n        return (x === y) ? 0 : (x < y ? -1 : 1);\r\n    }\r\n    else {\r\n        if (isIgnoreCase(ic)) {\r\n            x = x.toLocaleLowerCase();\r\n            y = y.toLocaleLowerCase();\r\n        }\r\n        return x.localeCompare(y);\r\n    }\r\n}\r\nexport function compare() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    switch (args.length) {\r\n        case 2: return cmp(args[0], args[1], false);\r\n        case 3: return cmp(args[0], args[1], args[2]);\r\n        case 4: return cmp(args[0], args[1], args[2] === true);\r\n        case 5: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), false);\r\n        case 6: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), args[5]);\r\n        case 7: return cmp(args[0].substr(args[1], args[4]), args[2].substr(args[3], args[4]), args[5] === true);\r\n        default: throw new Error(\"String.compare: Unsupported number of parameters\");\r\n    }\r\n}\r\nexport function compareTo(x, y) {\r\n    return cmp(x, y, false);\r\n}\r\nexport function indexOfAny(str, anyOf) {\r\n    var args = [];\r\n    for (var _i = 2; _i < arguments.length; _i++) {\r\n        args[_i - 2] = arguments[_i];\r\n    }\r\n    if (str == null || str === \"\")\r\n        return -1;\r\n    var startIndex = (args.length > 0) ? args[0] : 0;\r\n    if (startIndex < 0)\r\n        throw new Error(\"String.indexOfAny: Start index cannot be negative\");\r\n    var length = (args.length > 1) ? args[1] : str.length - startIndex;\r\n    if (length < 0)\r\n        throw new Error(\"String.indexOfAny: Length cannot be negative\");\r\n    if (length > str.length - startIndex)\r\n        throw new Error(\"String.indexOfAny: Invalid startIndex and length\");\r\n    str = str.substr(startIndex, length);\r\n    for (var _a = 0, anyOf_1 = anyOf; _a < anyOf_1.length; _a++) {\r\n        var c = anyOf_1[_a];\r\n        var index = str.indexOf(c);\r\n        if (index > -1)\r\n            return index + startIndex;\r\n    }\r\n    return -1;\r\n}\r\nfunction toHex(value) {\r\n    return value < 0\r\n        ? \"ff\" + (16777215 - (Math.abs(value) - 1)).toString(16)\r\n        : value.toString(16);\r\n}\r\nexport function fsFormat(str) {\r\n    var args = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        args[_i - 1] = arguments[_i];\r\n    }\r\n    var _cont;\r\n    function isObject(x) {\r\n        return x !== null && typeof x === \"object\" && !(x instanceof Number) && !(x instanceof String) && !(x instanceof Boolean);\r\n    }\r\n    function formatOnce(str, rep) {\r\n        return str.replace(fsFormatRegExp, function (_, prefix, flags, pad, precision, format) {\r\n            switch (format) {\r\n                case \"f\":\r\n                case \"F\":\r\n                    rep = rep.toFixed(precision || 6);\r\n                    break;\r\n                case \"g\":\r\n                case \"G\":\r\n                    rep = rep.toPrecision(precision);\r\n                    break;\r\n                case \"e\":\r\n                case \"E\":\r\n                    rep = rep.toExponential(precision);\r\n                    break;\r\n                case \"O\":\r\n                    rep = toString(rep);\r\n                    break;\r\n                case \"A\":\r\n                    try {\r\n                        rep = JSON.stringify(rep, function (k, v) {\r\n                            return v && v[Symbol.iterator] && !Array.isArray(v) && isObject(v) ? Array.from(v)\r\n                                : v && typeof v.ToString === \"function\" ? toString(v) : v;\r\n                        });\r\n                    }\r\n                    catch (err) {\r\n                        rep = \"{\" + Object.getOwnPropertyNames(rep).map(function (k) { return k + \": \" + String(rep[k]); }).join(\", \") + \"}\";\r\n                    }\r\n                    break;\r\n                case \"x\":\r\n                    rep = toHex(Number(rep));\r\n                    break;\r\n                case \"X\":\r\n                    rep = toHex(Number(rep)).toUpperCase();\r\n                    break;\r\n            }\r\n            var plusPrefix = flags.indexOf(\"+\") >= 0 && parseInt(rep) >= 0;\r\n            if (!isNaN(pad = parseInt(pad))) {\r\n                var ch = pad >= 0 && flags.indexOf(\"0\") >= 0 ? \"0\" : \" \";\r\n                rep = padLeft(rep, Math.abs(pad) - (plusPrefix ? 1 : 0), ch, pad < 0);\r\n            }\r\n            var once = prefix + (plusPrefix ? \"+\" + rep : rep);\r\n            return once.replace(/%/g, \"%%\");\r\n        });\r\n    }\r\n    function makeFn(str) {\r\n        return function (rep) {\r\n            var str2 = formatOnce(str, rep);\r\n            return fsFormatRegExp.test(str2)\r\n                ? makeFn(str2) : _cont(str2.replace(/%%/g, \"%\"));\r\n        };\r\n    }\r\n    if (args.length === 0) {\r\n        return function (cont) {\r\n            _cont = cont;\r\n            return fsFormatRegExp.test(str) ? makeFn(str) : _cont(str);\r\n        };\r\n    }\r\n    else {\r\n        for (var i = 0; i < args.length; i++) {\r\n            str = formatOnce(str, args[i]);\r\n        }\r\n        return str.replace(/%%/g, \"%\");\r\n    }\r\n}\r\nexport function format(str) {\r\n    var args = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        args[_i - 1] = arguments[_i];\r\n    }\r\n    return str.replace(formatRegExp, function (match, idx, pad, format) {\r\n        var rep = args[idx], padSymbol = \" \";\r\n        if (typeof rep === \"number\") {\r\n            switch ((format || \"\").substring(0, 1)) {\r\n                case \"f\":\r\n                case \"F\":\r\n                    rep = format.length > 1 ? rep.toFixed(format.substring(1)) : rep.toFixed(2);\r\n                    break;\r\n                case \"g\":\r\n                case \"G\":\r\n                    rep = format.length > 1 ? rep.toPrecision(format.substring(1)) : rep.toPrecision();\r\n                    break;\r\n                case \"e\":\r\n                case \"E\":\r\n                    rep = format.length > 1 ? rep.toExponential(format.substring(1)) : rep.toExponential();\r\n                    break;\r\n                case \"p\":\r\n                case \"P\":\r\n                    rep = (format.length > 1 ? (rep * 100).toFixed(format.substring(1)) : (rep * 100).toFixed(2)) + \" %\";\r\n                    break;\r\n                case \"x\":\r\n                    rep = toHex(Number(rep));\r\n                    break;\r\n                case \"X\":\r\n                    rep = toHex(Number(rep)).toUpperCase();\r\n                    break;\r\n                default:\r\n                    var m = /^(0+)(\\.0+)?$/.exec(format);\r\n                    if (m != null) {\r\n                        var decs = 0;\r\n                        if (m[2] != null)\r\n                            rep = rep.toFixed(decs = m[2].length - 1);\r\n                        pad = \",\" + (m[1].length + (decs ? decs + 1 : 0)).toString();\r\n                        padSymbol = \"0\";\r\n                    }\r\n                    else if (format) {\r\n                        rep = format;\r\n                    }\r\n            }\r\n        }\r\n        else if (rep instanceof Date) {\r\n            if (format.length === 1) {\r\n                switch (format) {\r\n                    case \"D\":\r\n                        rep = rep.toDateString();\r\n                        break;\r\n                    case \"T\":\r\n                        rep = rep.toLocaleTimeString();\r\n                        break;\r\n                    case \"d\":\r\n                        rep = rep.toLocaleDateString();\r\n                        break;\r\n                    case \"t\":\r\n                        rep = rep.toLocaleTimeString().replace(/:\\d\\d(?!:)/, \"\");\r\n                        break;\r\n                    case \"o\":\r\n                    case \"O\":\r\n                        if (rep.kind === 2) {\r\n                            var offset = rep.getTimezoneOffset() * -1;\r\n                            rep = format(\"{0:yyyy-MM-dd}T{0:HH:mm}:{1:00.000}{2}{3:00}:{4:00}\", rep, second(rep), offset >= 0 ? \"+\" : \"-\", ~~(offset / 60), offset % 60);\r\n                        }\r\n                        else {\r\n                            rep = rep.toISOString();\r\n                        }\r\n                }\r\n            }\r\n            else {\r\n                rep = format.replace(/\\w+/g, function (match2) {\r\n                    var rep2 = match2;\r\n                    switch (match2.substring(0, 1)) {\r\n                        case \"y\":\r\n                            rep2 = match2.length < 4 ? year(rep) % 100 : year(rep);\r\n                            break;\r\n                        case \"h\":\r\n                            rep2 = rep.getHours() > 12 ? hour(rep) % 12 : hour(rep);\r\n                            break;\r\n                        case \"M\":\r\n                            rep2 = month(rep);\r\n                            break;\r\n                        case \"d\":\r\n                            rep2 = day(rep);\r\n                            break;\r\n                        case \"H\":\r\n                            rep2 = hour(rep);\r\n                            break;\r\n                        case \"m\":\r\n                            rep2 = minute(rep);\r\n                            break;\r\n                        case \"s\":\r\n                            rep2 = second(rep);\r\n                            break;\r\n                    }\r\n                    if (rep2 !== match2 && rep2 < 10 && match2.length > 1) {\r\n                        rep2 = \"0\" + rep2;\r\n                    }\r\n                    return rep2;\r\n                });\r\n            }\r\n        }\r\n        if (!isNaN(pad = parseInt((pad || \"\").substring(1)))) {\r\n            rep = padLeft(rep, Math.abs(pad), padSymbol, pad < 0);\r\n        }\r\n        return rep;\r\n    });\r\n}\r\nexport function endsWith(str, search) {\r\n    var idx = str.lastIndexOf(search);\r\n    return idx >= 0 && idx == str.length - search.length;\r\n}\r\nexport function initialize(n, f) {\r\n    if (n < 0)\r\n        throw new Error(\"String length must be non-negative\");\r\n    var xs = new Array(n);\r\n    for (var i = 0; i < n; i++)\r\n        xs[i] = f(i);\r\n    return xs.join(\"\");\r\n}\r\nexport function insert(str, startIndex, value) {\r\n    if (startIndex < 0 || startIndex > str.length) {\r\n        throw new Error(\"startIndex is negative or greater than the length of this instance.\");\r\n    }\r\n    return str.substring(0, startIndex) + value + str.substring(startIndex);\r\n}\r\nexport function isNullOrEmpty(str) {\r\n    return typeof str !== \"string\" || str.length == 0;\r\n}\r\nexport function isNullOrWhiteSpace(str) {\r\n    return typeof str !== \"string\" || /^\\s*$/.test(str);\r\n}\r\nexport function join(delimiter, xs) {\r\n    xs = typeof xs == \"string\" ? getRestParams(arguments, 1) : xs;\r\n    return (Array.isArray(xs) ? xs : Array.from(xs)).join(delimiter);\r\n}\r\nexport function newGuid() {\r\n    var uuid = \"\";\r\n    for (var i = 0; i < 32; i++) {\r\n        var random = Math.random() * 16 | 0;\r\n        if (i === 8 || i === 12 || i === 16 || i === 20)\r\n            uuid += \"-\";\r\n        uuid += (i === 12 ? 4 : i === 16 ? random & 3 | 8 : random).toString(16);\r\n    }\r\n    return uuid;\r\n}\r\nexport function padLeft(str, len, ch, isRight) {\r\n    ch = ch || \" \";\r\n    str = String(str);\r\n    len = len - str.length;\r\n    for (var i = -1; ++i < len;)\r\n        str = isRight ? str + ch : ch + str;\r\n    return str;\r\n}\r\nexport function padRight(str, len, ch) {\r\n    return padLeft(str, len, ch, true);\r\n}\r\nexport function remove(str, startIndex, count) {\r\n    if (startIndex >= str.length) {\r\n        throw new Error(\"startIndex must be less than length of string\");\r\n    }\r\n    if (typeof count === \"number\" && (startIndex + count) > str.length) {\r\n        throw new Error(\"Index and count must refer to a location within the string.\");\r\n    }\r\n    return str.slice(0, startIndex) + (typeof count === \"number\" ? str.substr(startIndex + count) : \"\");\r\n}\r\nexport function replace(str, search, replace) {\r\n    return str.replace(new RegExp(escape(search), \"g\"), replace);\r\n}\r\nexport function replicate(n, x) {\r\n    return initialize(n, function () { return x; });\r\n}\r\nexport function split(str, splitters, count, removeEmpty) {\r\n    count = typeof count == \"number\" ? count : null;\r\n    removeEmpty = typeof removeEmpty == \"number\" ? removeEmpty : null;\r\n    if (count < 0)\r\n        throw new Error(\"Count cannot be less than zero\");\r\n    if (count === 0)\r\n        return [];\r\n    splitters = Array.isArray(splitters) ? splitters : getRestParams(arguments, 1);\r\n    splitters = splitters.map(function (x) { return escape(x); });\r\n    splitters = splitters.length > 0 ? splitters : [\" \"];\r\n    var m;\r\n    var i = 0;\r\n    var splits = [];\r\n    var reg = new RegExp(splitters.join(\"|\"), \"g\");\r\n    while ((count == null || count > 1) && (m = reg.exec(str)) !== null) {\r\n        if (!removeEmpty || (m.index - i) > 0) {\r\n            count = count != null ? count - 1 : count;\r\n            splits.push(str.substring(i, m.index));\r\n        }\r\n        i = reg.lastIndex;\r\n    }\r\n    if (!removeEmpty || (str.length - i) > 0)\r\n        splits.push(str.substring(i));\r\n    return splits;\r\n}\r\nexport function trim(str, side) {\r\n    var chars = [];\r\n    for (var _i = 2; _i < arguments.length; _i++) {\r\n        chars[_i - 2] = arguments[_i];\r\n    }\r\n    if (side == \"both\" && chars.length == 0)\r\n        return str.trim();\r\n    if (side == \"start\" || side == \"both\") {\r\n        var reg = chars.length == 0 ? /^\\s+/ : new RegExp(\"^[\" + escape(chars.join(\"\")) + \"]+\");\r\n        str = str.replace(reg, \"\");\r\n    }\r\n    if (side == \"end\" || side == \"both\") {\r\n        var reg = chars.length == 0 ? /\\s+$/ : new RegExp(\"[\" + escape(chars.join(\"\")) + \"]+$\");\r\n        str = str.replace(reg, \"\");\r\n    }\r\n    return str;\r\n}\r\n","import List from \"./ListClass\";\r\nimport { ofArray as listOfArray } from \"./ListClass\";\r\nimport { toString } from \"./Util\";\r\nimport { equals } from \"./Util\";\r\nimport { compare } from \"./Util\";\r\nimport GenericComparer from \"./GenericComparer\";\r\nimport FSymbol from \"./Symbol\";\r\nimport { map as seqMap } from \"./Seq\";\r\nimport { fold as seqFold } from \"./Seq\";\r\nimport { pick as seqPick } from \"./Seq\";\r\nimport { tryPick as seqTryPick } from \"./Seq\";\r\nimport { compareWith as seqCompareWith } from \"./Seq\";\r\nexport function groupBy(f, xs) {\r\n    var keys = [], iter = xs[Symbol.iterator]();\r\n    var acc = create(), cur = iter.next();\r\n    while (!cur.done) {\r\n        var k = f(cur.value), vs = tryFind(k, acc);\r\n        if (vs == null) {\r\n            keys.push(k);\r\n            acc = add(k, [cur.value], acc);\r\n        }\r\n        else {\r\n            vs.push(cur.value);\r\n        }\r\n        cur = iter.next();\r\n    }\r\n    return keys.map(function (k) { return [k, acc.get(k)]; });\r\n}\r\nexport function countBy(f, xs) {\r\n    return groupBy(f, xs).map(function (kv) { return [kv[0], kv[1].length]; });\r\n}\r\nvar MapTree = (function () {\r\n    function MapTree(caseName, fields) {\r\n        this.Case = caseName;\r\n        this.Fields = fields;\r\n    }\r\n    return MapTree;\r\n}());\r\nexport { MapTree };\r\nfunction tree_sizeAux(acc, m) {\r\n    return m.Case === \"MapOne\"\r\n        ? acc + 1\r\n        : m.Case === \"MapNode\"\r\n            ? tree_sizeAux(tree_sizeAux(acc + 1, m.Fields[2]), m.Fields[3])\r\n            : acc;\r\n}\r\nfunction tree_size(x) {\r\n    return tree_sizeAux(0, x);\r\n}\r\nfunction tree_empty() {\r\n    return new MapTree(\"MapEmpty\", []);\r\n}\r\nfunction tree_height(_arg1) {\r\n    return _arg1.Case === \"MapOne\" ? 1 : _arg1.Case === \"MapNode\" ? _arg1.Fields[4] : 0;\r\n}\r\nfunction tree_isEmpty(m) {\r\n    return m.Case === \"MapEmpty\" ? true : false;\r\n}\r\nfunction tree_mk(l, k, v, r) {\r\n    var matchValue = [l, r];\r\n    var $target1 = function () {\r\n        var hl = tree_height(l);\r\n        var hr = tree_height(r);\r\n        var m = hl < hr ? hr : hl;\r\n        return new MapTree(\"MapNode\", [k, v, l, r, m + 1]);\r\n    };\r\n    if (matchValue[0].Case === \"MapEmpty\") {\r\n        if (matchValue[1].Case === \"MapEmpty\") {\r\n            return new MapTree(\"MapOne\", [k, v]);\r\n        }\r\n        else {\r\n            return $target1();\r\n        }\r\n    }\r\n    else {\r\n        return $target1();\r\n    }\r\n}\r\n;\r\nfunction tree_rebalance(t1, k, v, t2) {\r\n    var t1h = tree_height(t1);\r\n    var t2h = tree_height(t2);\r\n    if (t2h > t1h + 2) {\r\n        if (t2.Case === \"MapNode\") {\r\n            if (tree_height(t2.Fields[2]) > t1h + 1) {\r\n                if (t2.Fields[2].Case === \"MapNode\") {\r\n                    return tree_mk(tree_mk(t1, k, v, t2.Fields[2].Fields[2]), t2.Fields[2].Fields[0], t2.Fields[2].Fields[1], tree_mk(t2.Fields[2].Fields[3], t2.Fields[0], t2.Fields[1], t2.Fields[3]));\r\n                }\r\n                else {\r\n                    throw new Error(\"rebalance\");\r\n                }\r\n            }\r\n            else {\r\n                return tree_mk(tree_mk(t1, k, v, t2.Fields[2]), t2.Fields[0], t2.Fields[1], t2.Fields[3]);\r\n            }\r\n        }\r\n        else {\r\n            throw new Error(\"rebalance\");\r\n        }\r\n    }\r\n    else {\r\n        if (t1h > t2h + 2) {\r\n            if (t1.Case === \"MapNode\") {\r\n                if (tree_height(t1.Fields[3]) > t2h + 1) {\r\n                    if (t1.Fields[3].Case === \"MapNode\") {\r\n                        return tree_mk(tree_mk(t1.Fields[2], t1.Fields[0], t1.Fields[1], t1.Fields[3].Fields[2]), t1.Fields[3].Fields[0], t1.Fields[3].Fields[1], tree_mk(t1.Fields[3].Fields[3], k, v, t2));\r\n                    }\r\n                    else {\r\n                        throw new Error(\"rebalance\");\r\n                    }\r\n                }\r\n                else {\r\n                    return tree_mk(t1.Fields[2], t1.Fields[0], t1.Fields[1], tree_mk(t1.Fields[3], k, v, t2));\r\n                }\r\n            }\r\n            else {\r\n                throw new Error(\"rebalance\");\r\n            }\r\n        }\r\n        else {\r\n            return tree_mk(t1, k, v, t2);\r\n        }\r\n    }\r\n}\r\nfunction tree_add(comparer, k, v, m) {\r\n    if (m.Case === \"MapOne\") {\r\n        var c = comparer.Compare(k, m.Fields[0]);\r\n        if (c < 0) {\r\n            return new MapTree(\"MapNode\", [k, v, new MapTree(\"MapEmpty\", []), m, 2]);\r\n        }\r\n        else if (c === 0) {\r\n            return new MapTree(\"MapOne\", [k, v]);\r\n        }\r\n        return new MapTree(\"MapNode\", [k, v, m, new MapTree(\"MapEmpty\", []), 2]);\r\n    }\r\n    else if (m.Case === \"MapNode\") {\r\n        var c = comparer.Compare(k, m.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_rebalance(tree_add(comparer, k, v, m.Fields[2]), m.Fields[0], m.Fields[1], m.Fields[3]);\r\n        }\r\n        else if (c === 0) {\r\n            return new MapTree(\"MapNode\", [k, v, m.Fields[2], m.Fields[3], m.Fields[4]]);\r\n        }\r\n        return tree_rebalance(m.Fields[2], m.Fields[0], m.Fields[1], tree_add(comparer, k, v, m.Fields[3]));\r\n    }\r\n    return new MapTree(\"MapOne\", [k, v]);\r\n}\r\nfunction tree_find(comparer, k, m) {\r\n    var res = tree_tryFind(comparer, k, m);\r\n    if (res != null)\r\n        return res;\r\n    throw new Error(\"key not found\");\r\n}\r\nfunction tree_tryFind(comparer, k, m) {\r\n    if (m.Case === \"MapOne\") {\r\n        var c = comparer.Compare(k, m.Fields[0]);\r\n        return c === 0 ? m.Fields[1] : null;\r\n    }\r\n    else if (m.Case === \"MapNode\") {\r\n        var c = comparer.Compare(k, m.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_tryFind(comparer, k, m.Fields[2]);\r\n        }\r\n        else {\r\n            if (c === 0) {\r\n                return m.Fields[1];\r\n            }\r\n            else {\r\n                return tree_tryFind(comparer, k, m.Fields[3]);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction tree_partition1(comparer, f, k, v, acc1, acc2) {\r\n    return f(k, v) ? [tree_add(comparer, k, v, acc1), acc2] : [acc1, tree_add(comparer, k, v, acc2)];\r\n}\r\nfunction tree_partitionAux(comparer, f, s, acc_0, acc_1) {\r\n    var acc = [acc_0, acc_1];\r\n    if (s.Case === \"MapOne\") {\r\n        return tree_partition1(comparer, f, s.Fields[0], s.Fields[1], acc[0], acc[1]);\r\n    }\r\n    else if (s.Case === \"MapNode\") {\r\n        var acc_2 = tree_partitionAux(comparer, f, s.Fields[3], acc[0], acc[1]);\r\n        var acc_3 = tree_partition1(comparer, f, s.Fields[0], s.Fields[1], acc_2[0], acc_2[1]);\r\n        return tree_partitionAux(comparer, f, s.Fields[2], acc_3[0], acc_3[1]);\r\n    }\r\n    return acc;\r\n}\r\nfunction tree_partition(comparer, f, s) {\r\n    return tree_partitionAux(comparer, f, s, tree_empty(), tree_empty());\r\n}\r\nfunction tree_filter1(comparer, f, k, v, acc) {\r\n    return f(k, v) ? tree_add(comparer, k, v, acc) : acc;\r\n}\r\nfunction tree_filterAux(comparer, f, s, acc) {\r\n    return s.Case === \"MapOne\" ? tree_filter1(comparer, f, s.Fields[0], s.Fields[1], acc) : s.Case === \"MapNode\" ? tree_filterAux(comparer, f, s.Fields[3], tree_filter1(comparer, f, s.Fields[0], s.Fields[1], tree_filterAux(comparer, f, s.Fields[2], acc))) : acc;\r\n}\r\nfunction tree_filter(comparer, f, s) {\r\n    return tree_filterAux(comparer, f, s, tree_empty());\r\n}\r\nfunction tree_spliceOutSuccessor(m) {\r\n    if (m.Case === \"MapOne\") {\r\n        return [m.Fields[0], m.Fields[1], new MapTree(\"MapEmpty\", [])];\r\n    }\r\n    else if (m.Case === \"MapNode\") {\r\n        if (m.Fields[2].Case === \"MapEmpty\") {\r\n            return [m.Fields[0], m.Fields[1], m.Fields[3]];\r\n        }\r\n        else {\r\n            var kvl = tree_spliceOutSuccessor(m.Fields[2]);\r\n            return [kvl[0], kvl[1], tree_mk(kvl[2], m.Fields[0], m.Fields[1], m.Fields[3])];\r\n        }\r\n    }\r\n    throw new Error(\"internal error: Map.spliceOutSuccessor\");\r\n}\r\nfunction tree_remove(comparer, k, m) {\r\n    if (m.Case === \"MapOne\") {\r\n        var c = comparer.Compare(k, m.Fields[0]);\r\n        if (c === 0) {\r\n            return new MapTree(\"MapEmpty\", []);\r\n        }\r\n        else {\r\n            return m;\r\n        }\r\n    }\r\n    else if (m.Case === \"MapNode\") {\r\n        var c = comparer.Compare(k, m.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_rebalance(tree_remove(comparer, k, m.Fields[2]), m.Fields[0], m.Fields[1], m.Fields[3]);\r\n        }\r\n        else {\r\n            if (c === 0) {\r\n                var matchValue = [m.Fields[2], m.Fields[3]];\r\n                if (matchValue[0].Case === \"MapEmpty\") {\r\n                    return m.Fields[3];\r\n                }\r\n                else {\r\n                    if (matchValue[1].Case === \"MapEmpty\") {\r\n                        return m.Fields[2];\r\n                    }\r\n                    else {\r\n                        var patternInput = tree_spliceOutSuccessor(m.Fields[3]);\r\n                        var sv = patternInput[1];\r\n                        var sk = patternInput[0];\r\n                        var r_ = patternInput[2];\r\n                        return tree_mk(m.Fields[2], sk, sv, r_);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                return tree_rebalance(m.Fields[2], m.Fields[0], m.Fields[1], tree_remove(comparer, k, m.Fields[3]));\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        return tree_empty();\r\n    }\r\n}\r\nfunction tree_mem(comparer, k, m) {\r\n    if (m.Case === \"MapOne\") {\r\n        return comparer.Compare(k, m.Fields[0]) === 0;\r\n    }\r\n    else if (m.Case === \"MapNode\") {\r\n        var c = comparer.Compare(k, m.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_mem(comparer, k, m.Fields[2]);\r\n        }\r\n        else {\r\n            if (c === 0) {\r\n                return true;\r\n            }\r\n            else {\r\n                return tree_mem(comparer, k, m.Fields[3]);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\nfunction tree_iter(f, m) {\r\n    if (m.Case === \"MapOne\") {\r\n        f(m.Fields[0], m.Fields[1]);\r\n    }\r\n    else if (m.Case === \"MapNode\") {\r\n        tree_iter(f, m.Fields[2]);\r\n        f(m.Fields[0], m.Fields[1]);\r\n        tree_iter(f, m.Fields[3]);\r\n    }\r\n}\r\nfunction tree_tryPick(f, m) {\r\n    if (m.Case === \"MapOne\") {\r\n        return f(m.Fields[0], m.Fields[1]);\r\n    }\r\n    else if (m.Case === \"MapNode\") {\r\n        var matchValue = tree_tryPick(f, m.Fields[2]);\r\n        if (matchValue == null) {\r\n            var matchValue_1 = f(m.Fields[0], m.Fields[1]);\r\n            if (matchValue_1 == null) {\r\n                return tree_tryPick(f, m.Fields[3]);\r\n            }\r\n            else {\r\n                var res = matchValue_1;\r\n                return res;\r\n            }\r\n        }\r\n        else {\r\n            var res = matchValue;\r\n            return res;\r\n        }\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\nfunction tree_exists(f, m) {\r\n    return m.Case === \"MapOne\" ? f(m.Fields[0], m.Fields[1]) : m.Case === \"MapNode\" ? (tree_exists(f, m.Fields[2]) ? true : f(m.Fields[0], m.Fields[1])) ? true : tree_exists(f, m.Fields[3]) : false;\r\n}\r\nfunction tree_forall(f, m) {\r\n    return m.Case === \"MapOne\" ? f(m.Fields[0], m.Fields[1]) : m.Case === \"MapNode\" ? (tree_forall(f, m.Fields[2]) ? f(m.Fields[0], m.Fields[1]) : false) ? tree_forall(f, m.Fields[3]) : false : true;\r\n}\r\nfunction tree_mapi(f, m) {\r\n    return m.Case === \"MapOne\" ? new MapTree(\"MapOne\", [m.Fields[0], f(m.Fields[0], m.Fields[1])]) : m.Case === \"MapNode\" ? new MapTree(\"MapNode\", [m.Fields[0], f(m.Fields[0], m.Fields[1]), tree_mapi(f, m.Fields[2]), tree_mapi(f, m.Fields[3]), m.Fields[4]]) : tree_empty();\r\n}\r\nfunction tree_foldBack(f, m, x) {\r\n    return m.Case === \"MapOne\" ? f(m.Fields[0], m.Fields[1], x) : m.Case === \"MapNode\" ? tree_foldBack(f, m.Fields[2], f(m.Fields[0], m.Fields[1], tree_foldBack(f, m.Fields[3], x))) : x;\r\n}\r\nfunction tree_fold(f, x, m) {\r\n    return m.Case === \"MapOne\" ? f(x, m.Fields[0], m.Fields[1]) : m.Case === \"MapNode\" ? tree_fold(f, f(tree_fold(f, x, m.Fields[2]), m.Fields[0], m.Fields[1]), m.Fields[3]) : x;\r\n}\r\nfunction tree_mkFromEnumerator(comparer, acc, e) {\r\n    var cur = e.next();\r\n    while (!cur.done) {\r\n        acc = tree_add(comparer, cur.value[0], cur.value[1], acc);\r\n        cur = e.next();\r\n    }\r\n    return acc;\r\n}\r\nfunction tree_ofSeq(comparer, c) {\r\n    var ie = c[Symbol.iterator]();\r\n    return tree_mkFromEnumerator(comparer, tree_empty(), ie);\r\n}\r\nfunction tree_collapseLHS(stack) {\r\n    if (stack.tail != null) {\r\n        if (stack.head.Case === \"MapOne\") {\r\n            return stack;\r\n        }\r\n        else if (stack.head.Case === \"MapNode\") {\r\n            return tree_collapseLHS(listOfArray([\r\n                stack.head.Fields[2],\r\n                new MapTree(\"MapOne\", [stack.head.Fields[0], stack.head.Fields[1]]),\r\n                stack.head.Fields[3]\r\n            ], stack.tail));\r\n        }\r\n        else {\r\n            return tree_collapseLHS(stack.tail);\r\n        }\r\n    }\r\n    else {\r\n        return new List();\r\n    }\r\n}\r\nfunction tree_mkIterator(s) {\r\n    return { stack: tree_collapseLHS(new List(s, new List())), started: false };\r\n}\r\nfunction tree_moveNext(i) {\r\n    function current(i) {\r\n        if (i.stack.tail == null) {\r\n            return null;\r\n        }\r\n        else if (i.stack.head.Case === \"MapOne\") {\r\n            return [i.stack.head.Fields[0], i.stack.head.Fields[1]];\r\n        }\r\n        throw new Error(\"Please report error: Map iterator, unexpected stack for current\");\r\n    }\r\n    if (i.started) {\r\n        if (i.stack.tail == null) {\r\n            return { done: true, value: null };\r\n        }\r\n        else {\r\n            if (i.stack.head.Case === \"MapOne\") {\r\n                i.stack = tree_collapseLHS(i.stack.tail);\r\n                return {\r\n                    done: i.stack.tail == null,\r\n                    value: current(i)\r\n                };\r\n            }\r\n            else {\r\n                throw new Error(\"Please report error: Map iterator, unexpected stack for moveNext\");\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        i.started = true;\r\n        return {\r\n            done: i.stack.tail == null,\r\n            value: current(i)\r\n        };\r\n    }\r\n    ;\r\n}\r\nvar FableMap = (function () {\r\n    function FableMap() {\r\n    }\r\n    FableMap.prototype.ToString = function () {\r\n        return \"map [\" + Array.from(this).map(toString).join(\"; \") + \"]\";\r\n    };\r\n    FableMap.prototype.Equals = function (m2) {\r\n        return this.CompareTo(m2) === 0;\r\n    };\r\n    FableMap.prototype.CompareTo = function (m2) {\r\n        var _this = this;\r\n        return this === m2 ? 0 : seqCompareWith(function (kvp1, kvp2) {\r\n            var c = _this.comparer.Compare(kvp1[0], kvp2[0]);\r\n            return c !== 0 ? c : compare(kvp1[1], kvp2[1]);\r\n        }, this, m2);\r\n    };\r\n    FableMap.prototype[Symbol.iterator] = function () {\r\n        var i = tree_mkIterator(this.tree);\r\n        return {\r\n            next: function () { return tree_moveNext(i); }\r\n        };\r\n    };\r\n    FableMap.prototype.entries = function () {\r\n        return this[Symbol.iterator]();\r\n    };\r\n    FableMap.prototype.keys = function () {\r\n        return seqMap(function (kv) { return kv[0]; }, this);\r\n    };\r\n    FableMap.prototype.values = function () {\r\n        return seqMap(function (kv) { return kv[1]; }, this);\r\n    };\r\n    FableMap.prototype.get = function (k) {\r\n        return tree_find(this.comparer, k, this.tree);\r\n    };\r\n    FableMap.prototype.has = function (k) {\r\n        return tree_mem(this.comparer, k, this.tree);\r\n    };\r\n    FableMap.prototype.set = function (k, v) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    FableMap.prototype.delete = function (k) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    FableMap.prototype.clear = function () {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    Object.defineProperty(FableMap.prototype, \"size\", {\r\n        get: function () {\r\n            return tree_size(this.tree);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    FableMap.prototype[FSymbol.reflection] = function () {\r\n        return {\r\n            type: \"Microsoft.FSharp.Collections.FSharpMap\",\r\n            interfaces: [\"System.IEquatable\", \"System.IComparable\", \"System.Collections.Generic.IDictionary\"]\r\n        };\r\n    };\r\n    return FableMap;\r\n}());\r\nexport default FableMap;\r\nfunction from(comparer, tree) {\r\n    var map = new FableMap();\r\n    map.tree = tree;\r\n    map.comparer = comparer || new GenericComparer();\r\n    return map;\r\n}\r\nexport function create(ie, comparer) {\r\n    comparer = comparer || new GenericComparer();\r\n    return from(comparer, ie ? tree_ofSeq(comparer, ie) : tree_empty());\r\n}\r\nexport function add(k, v, map) {\r\n    return from(map.comparer, tree_add(map.comparer, k, v, map.tree));\r\n}\r\nexport function remove(item, map) {\r\n    return from(map.comparer, tree_remove(map.comparer, item, map.tree));\r\n}\r\nexport function containsValue(v, map) {\r\n    return seqFold(function (acc, k) { return acc || equals(map.get(k), v); }, false, map.keys());\r\n}\r\nexport function tryGetValue(map, key, defaultValue) {\r\n    return map.has(key) ? [true, map.get(key)] : [false, defaultValue];\r\n}\r\nexport function exists(f, map) {\r\n    return tree_exists(f, map.tree);\r\n}\r\nexport function find(k, map) {\r\n    return tree_find(map.comparer, k, map.tree);\r\n}\r\nexport function tryFind(k, map) {\r\n    return tree_tryFind(map.comparer, k, map.tree);\r\n}\r\nexport function filter(f, map) {\r\n    return from(map.comparer, tree_filter(map.comparer, f, map.tree));\r\n}\r\nexport function fold(f, seed, map) {\r\n    return tree_fold(f, seed, map.tree);\r\n}\r\nexport function foldBack(f, map, seed) {\r\n    return tree_foldBack(f, map.tree, seed);\r\n}\r\nexport function forAll(f, map) {\r\n    return tree_forall(f, map.tree);\r\n}\r\nexport function isEmpty(map) {\r\n    return tree_isEmpty(map.tree);\r\n}\r\nexport function iterate(f, map) {\r\n    tree_iter(f, map.tree);\r\n}\r\nexport function map(f, map) {\r\n    return from(map.comparer, tree_mapi(f, map.tree));\r\n}\r\nexport function partition(f, map) {\r\n    var rs = tree_partition(map.comparer, f, map.tree);\r\n    return [from(map.comparer, rs[0]), from(map.comparer, rs[1])];\r\n}\r\nexport function findKey(f, map) {\r\n    return seqPick(function (kv) { return f(kv[0], kv[1]) ? kv[0] : null; }, map);\r\n}\r\nexport function tryFindKey(f, map) {\r\n    return seqTryPick(function (kv) { return f(kv[0], kv[1]) ? kv[0] : null; }, map);\r\n}\r\nexport function pick(f, map) {\r\n    var res = tryPick(f, map);\r\n    if (res != null)\r\n        return res;\r\n    throw new Error(\"key not found\");\r\n}\r\nexport function tryPick(f, map) {\r\n    return tree_tryPick(f, map.tree);\r\n}\r\n","import List from \"./ListClass\";\r\nimport { map as seqMap } from \"./Seq\";\r\nimport { fold as seqFold } from \"./Seq\";\r\nimport { foldBack as seqFoldBack } from \"./Seq\";\r\nimport { toList as seqToList } from \"./Seq\";\r\nimport { groupBy as mapGroupBy } from \"./Map\";\r\nexport default List;\r\nexport { ofArray } from \"./ListClass\";\r\nexport function append(xs, ys) {\r\n    return seqFold(function (acc, x) { return new List(x, acc); }, ys, reverse(xs));\r\n}\r\nexport function choose(f, xs) {\r\n    var r = seqFold(function (acc, x) {\r\n        var y = f(x);\r\n        return y != null ? new List(y, acc) : acc;\r\n    }, new List(), xs);\r\n    return reverse(r);\r\n}\r\nexport function collect(f, xs) {\r\n    return seqFold(function (acc, x) { return append(acc, f(x)); }, new List(), xs);\r\n}\r\nexport function concat(xs) {\r\n    return collect(function (x) { return x; }, xs);\r\n}\r\nexport function filter(f, xs) {\r\n    return reverse(seqFold(function (acc, x) { return f(x) ? new List(x, acc) : acc; }, new List(), xs));\r\n}\r\nexport function where(f, xs) {\r\n    return filter(f, xs);\r\n}\r\nexport function initialize(n, f) {\r\n    if (n < 0) {\r\n        throw new Error(\"List length must be non-negative\");\r\n    }\r\n    var xs = new List();\r\n    for (var i = 1; i <= n; i++) {\r\n        xs = new List(f(n - i), xs);\r\n    }\r\n    return xs;\r\n}\r\nexport function map(f, xs) {\r\n    return reverse(seqFold(function (acc, x) { return new List(f(x), acc); }, new List(), xs));\r\n}\r\nexport function mapIndexed(f, xs) {\r\n    return reverse(seqFold(function (acc, x, i) { return new List(f(i, x), acc); }, new List(), xs));\r\n}\r\nexport function partition(f, xs) {\r\n    return seqFold(function (acc, x) {\r\n        var lacc = acc[0], racc = acc[1];\r\n        return f(x) ? [new List(x, lacc), racc] : [lacc, new List(x, racc)];\r\n    }, [new List(), new List()], reverse(xs));\r\n}\r\nexport function replicate(n, x) {\r\n    return initialize(n, function () { return x; });\r\n}\r\nexport function reverse(xs) {\r\n    return seqFold(function (acc, x) { return new List(x, acc); }, new List(), xs);\r\n}\r\nexport function singleton(x) {\r\n    return new List(x, new List());\r\n}\r\nexport function slice(lower, upper, xs) {\r\n    var noLower = (lower == null);\r\n    var noUpper = (upper == null);\r\n    return reverse(seqFold(function (acc, x, i) { return (noLower || lower <= i) && (noUpper || i <= upper) ? new List(x, acc) : acc; }, new List(), xs));\r\n}\r\nexport function unzip(xs) {\r\n    return seqFoldBack(function (xy, acc) {\r\n        return [new List(xy[0], acc[0]), new List(xy[1], acc[1])];\r\n    }, xs, [new List(), new List()]);\r\n}\r\nexport function unzip3(xs) {\r\n    return seqFoldBack(function (xyz, acc) {\r\n        return [new List(xyz[0], acc[0]), new List(xyz[1], acc[1]), new List(xyz[2], acc[2])];\r\n    }, xs, [new List(), new List(), new List()]);\r\n}\r\nexport function groupBy(f, xs) {\r\n    return seqToList(seqMap(function (k) { return [k[0], seqToList(k[1])]; }, mapGroupBy(f, xs)));\r\n}\r\n","import List from \"./List\";\r\nimport { ofArray as listOfArray } from \"./List\";\r\nimport { toString } from \"./Util\";\r\nimport GenericComparer from \"./GenericComparer\";\r\nimport FSymbol from \"./Symbol\";\r\nimport { iterate as seqIterate } from \"./Seq\";\r\nimport { fold as seqFold } from \"./Seq\";\r\nimport { reduce as seqReduce } from \"./Seq\";\r\nimport { forAll as seqForAll } from \"./Seq\";\r\nimport { exists as seqExists } from \"./Seq\";\r\nimport { choose as seqChoose } from \"./Seq\";\r\nimport { scan as seqScan } from \"./Seq\";\r\nexport function distinctBy(f, xs) {\r\n    return seqChoose(function (tup) { return tup[0]; }, seqScan(function (tup, x) {\r\n        var acc = tup[1];\r\n        var k = f(x);\r\n        return acc.has(k) ? [null, acc] : [x, add(k, acc)];\r\n    }, [null, create()], xs));\r\n}\r\nexport function distinct(xs) {\r\n    return distinctBy(function (x) { return x; }, xs);\r\n}\r\nvar SetTree = (function () {\r\n    function SetTree(caseName, fields) {\r\n        this.Case = caseName;\r\n        this.Fields = fields;\r\n    }\r\n    return SetTree;\r\n}());\r\nexport { SetTree };\r\nvar tree_tolerance = 2;\r\nfunction tree_countAux(s, acc) {\r\n    return s.Case === \"SetOne\" ? acc + 1 : s.Case === \"SetEmpty\" ? acc : tree_countAux(s.Fields[1], tree_countAux(s.Fields[2], acc + 1));\r\n}\r\nfunction tree_count(s) {\r\n    return tree_countAux(s, 0);\r\n}\r\nfunction tree_SetOne(n) {\r\n    return new SetTree(\"SetOne\", [n]);\r\n}\r\nfunction tree_SetNode(x, l, r, h) {\r\n    return new SetTree(\"SetNode\", [x, l, r, h]);\r\n}\r\nfunction tree_height(t) {\r\n    return t.Case === \"SetOne\" ? 1 : t.Case === \"SetNode\" ? t.Fields[3] : 0;\r\n}\r\nfunction tree_mk(l, k, r) {\r\n    var matchValue = [l, r];\r\n    var $target1 = function () {\r\n        var hl = tree_height(l);\r\n        var hr = tree_height(r);\r\n        var m = hl < hr ? hr : hl;\r\n        return tree_SetNode(k, l, r, m + 1);\r\n    };\r\n    if (matchValue[0].Case === \"SetEmpty\") {\r\n        if (matchValue[1].Case === \"SetEmpty\") {\r\n            return tree_SetOne(k);\r\n        }\r\n        else {\r\n            return $target1();\r\n        }\r\n    }\r\n    else {\r\n        return $target1();\r\n    }\r\n}\r\nfunction tree_rebalance(t1, k, t2) {\r\n    var t1h = tree_height(t1);\r\n    var t2h = tree_height(t2);\r\n    if (t2h > t1h + tree_tolerance) {\r\n        if (t2.Case === \"SetNode\") {\r\n            if (tree_height(t2.Fields[1]) > t1h + 1) {\r\n                if (t2.Fields[1].Case === \"SetNode\") {\r\n                    return tree_mk(tree_mk(t1, k, t2.Fields[1].Fields[1]), t2.Fields[1].Fields[0], tree_mk(t2.Fields[1].Fields[2], t2.Fields[0], t2.Fields[2]));\r\n                }\r\n                else {\r\n                    throw new Error(\"rebalance\");\r\n                }\r\n            }\r\n            else {\r\n                return tree_mk(tree_mk(t1, k, t2.Fields[1]), t2.Fields[0], t2.Fields[2]);\r\n            }\r\n        }\r\n        else {\r\n            throw new Error(\"rebalance\");\r\n        }\r\n    }\r\n    else {\r\n        if (t1h > t2h + tree_tolerance) {\r\n            if (t1.Case === \"SetNode\") {\r\n                if (tree_height(t1.Fields[2]) > t2h + 1) {\r\n                    if (t1.Fields[2].Case === \"SetNode\") {\r\n                        return tree_mk(tree_mk(t1.Fields[1], t1.Fields[0], t1.Fields[2].Fields[1]), t1.Fields[2].Fields[0], tree_mk(t1.Fields[2].Fields[2], k, t2));\r\n                    }\r\n                    else {\r\n                        throw new Error(\"rebalance\");\r\n                    }\r\n                }\r\n                else {\r\n                    return tree_mk(t1.Fields[1], t1.Fields[0], tree_mk(t1.Fields[2], k, t2));\r\n                }\r\n            }\r\n            else {\r\n                throw new Error(\"rebalance\");\r\n            }\r\n        }\r\n        else {\r\n            return tree_mk(t1, k, t2);\r\n        }\r\n    }\r\n}\r\nfunction tree_add(comparer, k, t) {\r\n    if (t.Case === \"SetOne\") {\r\n        var c = comparer.Compare(k, t.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_SetNode(k, new SetTree(\"SetEmpty\", []), t, 2);\r\n        }\r\n        else if (c === 0) {\r\n            return t;\r\n        }\r\n        else {\r\n            return tree_SetNode(k, t, new SetTree(\"SetEmpty\", []), 2);\r\n        }\r\n    }\r\n    else if (t.Case === \"SetEmpty\") {\r\n        return tree_SetOne(k);\r\n    }\r\n    else {\r\n        var c = comparer.Compare(k, t.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_rebalance(tree_add(comparer, k, t.Fields[1]), t.Fields[0], t.Fields[2]);\r\n        }\r\n        else if (c === 0) {\r\n            return t;\r\n        }\r\n        else {\r\n            return tree_rebalance(t.Fields[1], t.Fields[0], tree_add(comparer, k, t.Fields[2]));\r\n        }\r\n    }\r\n}\r\nfunction tree_balance(comparer, t1, k, t2) {\r\n    var matchValue = [t1, t2];\r\n    var $target1 = function (t1_1) { return tree_add(comparer, k, t1_1); };\r\n    var $target2 = function (k1, t2_1) { return tree_add(comparer, k, tree_add(comparer, k1, t2_1)); };\r\n    if (matchValue[0].Case === \"SetOne\") {\r\n        if (matchValue[1].Case === \"SetEmpty\") {\r\n            return $target1(matchValue[0]);\r\n        }\r\n        else {\r\n            if (matchValue[1].Case === \"SetOne\") {\r\n                return $target2(matchValue[0].Fields[0], matchValue[1]);\r\n            }\r\n            else {\r\n                return $target2(matchValue[0].Fields[0], matchValue[1]);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        if (matchValue[0].Case === \"SetNode\") {\r\n            if (matchValue[1].Case === \"SetOne\") {\r\n                var k2 = matchValue[1].Fields[0];\r\n                var t1_1 = matchValue[0];\r\n                return tree_add(comparer, k, tree_add(comparer, k2, t1_1));\r\n            }\r\n            else {\r\n                if (matchValue[1].Case === \"SetNode\") {\r\n                    var h1 = matchValue[0].Fields[3];\r\n                    var h2 = matchValue[1].Fields[3];\r\n                    var k1 = matchValue[0].Fields[0];\r\n                    var k2 = matchValue[1].Fields[0];\r\n                    var t11 = matchValue[0].Fields[1];\r\n                    var t12 = matchValue[0].Fields[2];\r\n                    var t21 = matchValue[1].Fields[1];\r\n                    var t22 = matchValue[1].Fields[2];\r\n                    if (h1 + tree_tolerance < h2) {\r\n                        return tree_rebalance(tree_balance(comparer, t1, k, t21), k2, t22);\r\n                    }\r\n                    else {\r\n                        if (h2 + tree_tolerance < h1) {\r\n                            return tree_rebalance(t11, k1, tree_balance(comparer, t12, k, t2));\r\n                        }\r\n                        else {\r\n                            return tree_mk(t1, k, t2);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    return $target1(matchValue[0]);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var t2_1 = matchValue[1];\r\n            return tree_add(comparer, k, t2_1);\r\n        }\r\n    }\r\n}\r\nfunction tree_split(comparer, pivot, t) {\r\n    if (t.Case === \"SetOne\") {\r\n        var c = comparer.Compare(t.Fields[0], pivot);\r\n        if (c < 0) {\r\n            return [t, false, new SetTree(\"SetEmpty\", [])];\r\n        }\r\n        else if (c === 0) {\r\n            return [new SetTree(\"SetEmpty\", []), true, new SetTree(\"SetEmpty\", [])];\r\n        }\r\n        else {\r\n            return [new SetTree(\"SetEmpty\", []), false, t];\r\n        }\r\n    }\r\n    else if (t.Case === \"SetEmpty\") {\r\n        return [new SetTree(\"SetEmpty\", []), false, new SetTree(\"SetEmpty\", [])];\r\n    }\r\n    else {\r\n        var c = comparer.Compare(pivot, t.Fields[0]);\r\n        if (c < 0) {\r\n            var patternInput = tree_split(comparer, pivot, t.Fields[1]);\r\n            return [patternInput[0], patternInput[1], tree_balance(comparer, patternInput[2], t.Fields[0], t.Fields[2])];\r\n        }\r\n        else if (c === 0) {\r\n            return [t.Fields[1], true, t.Fields[2]];\r\n        }\r\n        else {\r\n            var patternInput = tree_split(comparer, pivot, t.Fields[2]);\r\n            return [tree_balance(comparer, t.Fields[1], t.Fields[0], patternInput[0]), patternInput[1], patternInput[2]];\r\n        }\r\n    }\r\n}\r\nfunction tree_spliceOutSuccessor(t) {\r\n    if (t.Case === \"SetOne\") {\r\n        return [t.Fields[0], new SetTree(\"SetEmpty\", [])];\r\n    }\r\n    else if (t.Case === \"SetNode\") {\r\n        if (t.Fields[1].Case === \"SetEmpty\") {\r\n            return [t.Fields[0], t.Fields[2]];\r\n        }\r\n        else {\r\n            var patternInput = tree_spliceOutSuccessor(t.Fields[1]);\r\n            return [patternInput[0], tree_mk(patternInput[1], t.Fields[0], t.Fields[2])];\r\n        }\r\n    }\r\n    else {\r\n        throw new Error(\"internal error: Map.spliceOutSuccessor\");\r\n    }\r\n}\r\nfunction tree_remove(comparer, k, t) {\r\n    if (t.Case === \"SetOne\") {\r\n        var c = comparer.Compare(k, t.Fields[0]);\r\n        if (c === 0) {\r\n            return new SetTree(\"SetEmpty\", []);\r\n        }\r\n        else {\r\n            return t;\r\n        }\r\n    }\r\n    else if (t.Case === \"SetNode\") {\r\n        var c = comparer.Compare(k, t.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_rebalance(tree_remove(comparer, k, t.Fields[1]), t.Fields[0], t.Fields[2]);\r\n        }\r\n        else if (c === 0) {\r\n            var matchValue = [t.Fields[1], t.Fields[2]];\r\n            if (matchValue[0].Case === \"SetEmpty\") {\r\n                return t.Fields[2];\r\n            }\r\n            else if (matchValue[1].Case === \"SetEmpty\") {\r\n                return t.Fields[1];\r\n            }\r\n            else {\r\n                var patternInput = tree_spliceOutSuccessor(t.Fields[2]);\r\n                return tree_mk(t.Fields[1], patternInput[0], patternInput[1]);\r\n            }\r\n        }\r\n        else {\r\n            return tree_rebalance(t.Fields[1], t.Fields[0], tree_remove(comparer, k, t.Fields[2]));\r\n        }\r\n    }\r\n    else {\r\n        return t;\r\n    }\r\n}\r\nfunction tree_mem(comparer, k, t) {\r\n    if (t.Case === \"SetOne\") {\r\n        return comparer.Compare(k, t.Fields[0]) === 0;\r\n    }\r\n    else if (t.Case === \"SetEmpty\") {\r\n        return false;\r\n    }\r\n    else {\r\n        var c = comparer.Compare(k, t.Fields[0]);\r\n        if (c < 0) {\r\n            return tree_mem(comparer, k, t.Fields[1]);\r\n        }\r\n        else if (c === 0) {\r\n            return true;\r\n        }\r\n        else {\r\n            return tree_mem(comparer, k, t.Fields[2]);\r\n        }\r\n    }\r\n}\r\nfunction tree_iter(f, t) {\r\n    if (t.Case === \"SetOne\") {\r\n        f(t.Fields[0]);\r\n    }\r\n    else {\r\n        if (t.Case === \"SetEmpty\") { }\r\n        else {\r\n            tree_iter(f, t.Fields[1]);\r\n            f(t.Fields[0]);\r\n            tree_iter(f, t.Fields[2]);\r\n        }\r\n    }\r\n}\r\nfunction tree_foldBack(f, m, x) {\r\n    return m.Case === \"SetOne\" ? f(m.Fields[0], x) : m.Case === \"SetEmpty\" ? x : tree_foldBack(f, m.Fields[1], f(m.Fields[0], tree_foldBack(f, m.Fields[2], x)));\r\n}\r\nfunction tree_fold(f, x, m) {\r\n    if (m.Case === \"SetOne\") {\r\n        return f(x, m.Fields[0]);\r\n    }\r\n    else if (m.Case === \"SetEmpty\") {\r\n        return x;\r\n    }\r\n    else {\r\n        var x_1 = tree_fold(f, x, m.Fields[1]);\r\n        var x_2 = f(x_1, m.Fields[0]);\r\n        return tree_fold(f, x_2, m.Fields[2]);\r\n    }\r\n}\r\nfunction tree_forall(f, m) {\r\n    return m.Case === \"SetOne\" ? f(m.Fields[0]) : m.Case === \"SetEmpty\" ? true : (f(m.Fields[0]) ? tree_forall(f, m.Fields[1]) : false) ? tree_forall(f, m.Fields[2]) : false;\r\n}\r\nfunction tree_exists(f, m) {\r\n    return m.Case === \"SetOne\" ? f(m.Fields[0]) : m.Case === \"SetEmpty\" ? false : (f(m.Fields[0]) ? true : tree_exists(f, m.Fields[1])) ? true : tree_exists(f, m.Fields[2]);\r\n}\r\nfunction tree_isEmpty(m) {\r\n    return m.Case === \"SetEmpty\" ? true : false;\r\n}\r\nfunction tree_subset(comparer, a, b) {\r\n    return tree_forall(function (x) { return tree_mem(comparer, x, b); }, a);\r\n}\r\nfunction tree_psubset(comparer, a, b) {\r\n    return tree_forall(function (x) { return tree_mem(comparer, x, b); }, a) ? tree_exists(function (x) { return !tree_mem(comparer, x, a); }, b) : false;\r\n}\r\nfunction tree_filterAux(comparer, f, s, acc) {\r\n    if (s.Case === \"SetOne\") {\r\n        if (f(s.Fields[0])) {\r\n            return tree_add(comparer, s.Fields[0], acc);\r\n        }\r\n        else {\r\n            return acc;\r\n        }\r\n    }\r\n    else if (s.Case === \"SetEmpty\") {\r\n        return acc;\r\n    }\r\n    else {\r\n        var acc_1 = f(s.Fields[0]) ? tree_add(comparer, s.Fields[0], acc) : acc;\r\n        return tree_filterAux(comparer, f, s.Fields[1], tree_filterAux(comparer, f, s.Fields[2], acc_1));\r\n    }\r\n}\r\nfunction tree_filter(comparer, f, s) {\r\n    return tree_filterAux(comparer, f, s, new SetTree(\"SetEmpty\", []));\r\n}\r\nfunction tree_diffAux(comparer, m, acc) {\r\n    return m.Case === \"SetOne\" ? tree_remove(comparer, m.Fields[0], acc) : m.Case === \"SetEmpty\" ? acc : tree_diffAux(comparer, m.Fields[1], tree_diffAux(comparer, m.Fields[2], tree_remove(comparer, m.Fields[0], acc)));\r\n}\r\nfunction tree_diff(comparer, a, b) {\r\n    return tree_diffAux(comparer, b, a);\r\n}\r\nfunction tree_union(comparer, t1, t2) {\r\n    var matchValue = [t1, t2];\r\n    var $target2 = function (t) { return t; };\r\n    var $target3 = function (k1, t2_1) { return tree_add(comparer, k1, t2_1); };\r\n    if (matchValue[0].Case === \"SetEmpty\") {\r\n        var t = matchValue[1];\r\n        return t;\r\n    }\r\n    else {\r\n        if (matchValue[0].Case === \"SetOne\") {\r\n            if (matchValue[1].Case === \"SetEmpty\") {\r\n                return $target2(matchValue[0]);\r\n            }\r\n            else {\r\n                if (matchValue[1].Case === \"SetOne\") {\r\n                    return $target3(matchValue[0].Fields[0], matchValue[1]);\r\n                }\r\n                else {\r\n                    return $target3(matchValue[0].Fields[0], matchValue[1]);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (matchValue[1].Case === \"SetEmpty\") {\r\n                return $target2(matchValue[0]);\r\n            }\r\n            else {\r\n                if (matchValue[1].Case === \"SetOne\") {\r\n                    var k2 = matchValue[1].Fields[0];\r\n                    var t1_1 = matchValue[0];\r\n                    return tree_add(comparer, k2, t1_1);\r\n                }\r\n                else {\r\n                    var h1 = matchValue[0].Fields[3];\r\n                    var h2 = matchValue[1].Fields[3];\r\n                    var k1 = matchValue[0].Fields[0];\r\n                    var k2 = matchValue[1].Fields[0];\r\n                    var t11 = matchValue[0].Fields[1];\r\n                    var t12 = matchValue[0].Fields[2];\r\n                    var t21 = matchValue[1].Fields[1];\r\n                    var t22 = matchValue[1].Fields[2];\r\n                    if (h1 > h2) {\r\n                        var patternInput = tree_split(comparer, k1, t2);\r\n                        var lo = patternInput[0];\r\n                        var hi = patternInput[2];\r\n                        return tree_balance(comparer, tree_union(comparer, t11, lo), k1, tree_union(comparer, t12, hi));\r\n                    }\r\n                    else {\r\n                        var patternInput = tree_split(comparer, k2, t1);\r\n                        var lo = patternInput[0];\r\n                        var hi = patternInput[2];\r\n                        return tree_balance(comparer, tree_union(comparer, t21, lo), k2, tree_union(comparer, t22, hi));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction tree_intersectionAux(comparer, b, m, acc) {\r\n    if (m.Case === \"SetOne\") {\r\n        if (tree_mem(comparer, m.Fields[0], b)) {\r\n            return tree_add(comparer, m.Fields[0], acc);\r\n        }\r\n        else {\r\n            return acc;\r\n        }\r\n    }\r\n    else if (m.Case === \"SetEmpty\") {\r\n        return acc;\r\n    }\r\n    else {\r\n        var acc_1 = tree_intersectionAux(comparer, b, m.Fields[2], acc);\r\n        var acc_2 = tree_mem(comparer, m.Fields[0], b) ? tree_add(comparer, m.Fields[0], acc_1) : acc_1;\r\n        return tree_intersectionAux(comparer, b, m.Fields[1], acc_2);\r\n    }\r\n}\r\nfunction tree_intersection(comparer, a, b) {\r\n    return tree_intersectionAux(comparer, b, a, new SetTree(\"SetEmpty\", []));\r\n}\r\nfunction tree_partition1(comparer, f, k, acc1, acc2) {\r\n    return f(k) ? [tree_add(comparer, k, acc1), acc2] : [acc1, tree_add(comparer, k, acc2)];\r\n}\r\nfunction tree_partitionAux(comparer, f, s, acc_0, acc_1) {\r\n    var acc = [acc_0, acc_1];\r\n    if (s.Case === \"SetOne\") {\r\n        var acc1 = acc[0];\r\n        var acc2 = acc[1];\r\n        return tree_partition1(comparer, f, s.Fields[0], acc1, acc2);\r\n    }\r\n    else {\r\n        if (s.Case === \"SetEmpty\") {\r\n            return acc;\r\n        }\r\n        else {\r\n            var acc_2 = tree_partitionAux(comparer, f, s.Fields[2], acc[0], acc[1]);\r\n            var acc_3 = tree_partition1(comparer, f, s.Fields[0], acc_2[0], acc_2[1]);\r\n            return tree_partitionAux(comparer, f, s.Fields[1], acc_3[0], acc_3[1]);\r\n        }\r\n    }\r\n}\r\nfunction tree_partition(comparer, f, s) {\r\n    var seed = [new SetTree(\"SetEmpty\", []), new SetTree(\"SetEmpty\", [])];\r\n    var arg30_ = seed[0];\r\n    var arg31_ = seed[1];\r\n    return tree_partitionAux(comparer, f, s, arg30_, arg31_);\r\n}\r\nfunction tree_minimumElementAux(s, n) {\r\n    return s.Case === \"SetOne\" ? s.Fields[0] : s.Case === \"SetEmpty\" ? n : tree_minimumElementAux(s.Fields[1], s.Fields[0]);\r\n}\r\nfunction tree_minimumElementOpt(s) {\r\n    return s.Case === \"SetOne\" ? s.Fields[0] : s.Case === \"SetEmpty\" ? null : tree_minimumElementAux(s.Fields[1], s.Fields[0]);\r\n}\r\nfunction tree_maximumElementAux(s, n) {\r\n    return s.Case === \"SetOne\" ? s.Fields[0] : s.Case === \"SetEmpty\" ? n : tree_maximumElementAux(s.Fields[2], s.Fields[0]);\r\n}\r\nfunction tree_maximumElementOpt(s) {\r\n    return s.Case === \"SetOne\" ? s.Fields[0] : s.Case === \"SetEmpty\" ? null : tree_maximumElementAux(s.Fields[2], s.Fields[0]);\r\n}\r\nfunction tree_minimumElement(s) {\r\n    var matchValue = tree_minimumElementOpt(s);\r\n    if (matchValue == null) {\r\n        throw new Error(\"Set contains no elements\");\r\n    }\r\n    else {\r\n        return matchValue;\r\n    }\r\n}\r\nfunction tree_maximumElement(s) {\r\n    var matchValue = tree_maximumElementOpt(s);\r\n    if (matchValue == null) {\r\n        throw new Error(\"Set contains no elements\");\r\n    }\r\n    else {\r\n        return matchValue;\r\n    }\r\n}\r\nfunction tree_collapseLHS(stack) {\r\n    return stack.tail != null\r\n        ? stack.head.Case === \"SetOne\"\r\n            ? stack\r\n            : stack.head.Case === \"SetNode\"\r\n                ? tree_collapseLHS(listOfArray([\r\n                    stack.head.Fields[1],\r\n                    tree_SetOne(stack.head.Fields[0]),\r\n                    stack.head.Fields[2]\r\n                ], stack.tail))\r\n                : tree_collapseLHS(stack.tail)\r\n        : new List();\r\n}\r\nfunction tree_mkIterator(s) {\r\n    return { stack: tree_collapseLHS(new List(s, new List())), started: false };\r\n}\r\n;\r\nfunction tree_moveNext(i) {\r\n    function current(i) {\r\n        if (i.stack.tail == null) {\r\n            return null;\r\n        }\r\n        else if (i.stack.head.Case === \"SetOne\") {\r\n            return i.stack.head.Fields[0];\r\n        }\r\n        throw new Error(\"Please report error: Set iterator, unexpected stack for current\");\r\n    }\r\n    if (i.started) {\r\n        if (i.stack.tail == null) {\r\n            return { done: true, value: null };\r\n        }\r\n        else {\r\n            if (i.stack.head.Case === \"SetOne\") {\r\n                i.stack = tree_collapseLHS(i.stack.tail);\r\n                return {\r\n                    done: i.stack.tail == null,\r\n                    value: current(i)\r\n                };\r\n            }\r\n            else {\r\n                throw new Error(\"Please report error: Set iterator, unexpected stack for moveNext\");\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        i.started = true;\r\n        return {\r\n            done: i.stack.tail == null,\r\n            value: current(i)\r\n        };\r\n    }\r\n    ;\r\n}\r\nfunction tree_compareStacks(comparer, l1, l2) {\r\n    var $target8 = function (n1k, t1) { return tree_compareStacks(comparer, listOfArray([new SetTree(\"SetEmpty\", []), tree_SetOne(n1k)], t1), l2); };\r\n    var $target9 = function (n1k, n1l, n1r, t1) { return tree_compareStacks(comparer, listOfArray([n1l, tree_SetNode(n1k, new SetTree(\"SetEmpty\", []), n1r, 0)], t1), l2); };\r\n    var $target11 = function (n2k, n2l, n2r, t2) { return tree_compareStacks(comparer, l1, listOfArray([n2l, tree_SetNode(n2k, new SetTree(\"SetEmpty\", []), n2r, 0)], t2)); };\r\n    if (l1.tail != null) {\r\n        if (l2.tail != null) {\r\n            if (l2.head.Case === \"SetOne\") {\r\n                if (l1.head.Case === \"SetOne\") {\r\n                    var n1k = l1.head.Fields[0], n2k = l2.head.Fields[0], t1 = l1.tail, t2 = l2.tail, c = comparer.Compare(n1k, n2k);\r\n                    if (c !== 0) {\r\n                        return c;\r\n                    }\r\n                    else {\r\n                        return tree_compareStacks(comparer, t1, t2);\r\n                    }\r\n                }\r\n                else {\r\n                    if (l1.head.Case === \"SetNode\") {\r\n                        if (l1.head.Fields[1].Case === \"SetEmpty\") {\r\n                            var emp = l1.head.Fields[1], n1k = l1.head.Fields[0], n1r = l1.head.Fields[2], n2k = l2.head.Fields[0], t1 = l1.tail, t2 = l2.tail, c = comparer.Compare(n1k, n2k);\r\n                            if (c !== 0) {\r\n                                return c;\r\n                            }\r\n                            else {\r\n                                return tree_compareStacks(comparer, listOfArray([n1r], t1), listOfArray([emp], t2));\r\n                            }\r\n                        }\r\n                        else {\r\n                            return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);\r\n                        }\r\n                    }\r\n                    else {\r\n                        var n2k = l2.head.Fields[0], t2 = l2.tail;\r\n                        return tree_compareStacks(comparer, l1, listOfArray([new SetTree(\"SetEmpty\", []), tree_SetOne(n2k)], t2));\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (l2.head.Case === \"SetNode\") {\r\n                    if (l2.head.Fields[1].Case === \"SetEmpty\") {\r\n                        if (l1.head.Case === \"SetOne\") {\r\n                            var n1k = l1.head.Fields[0], n2k = l2.head.Fields[0], n2r = l2.head.Fields[2], t1 = l1.tail, t2 = l2.tail, c = comparer.Compare(n1k, n2k);\r\n                            if (c !== 0) {\r\n                                return c;\r\n                            }\r\n                            else {\r\n                                return tree_compareStacks(comparer, listOfArray([new SetTree(\"SetEmpty\", [])], t1), listOfArray([n2r], t2));\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (l1.head.Case === \"SetNode\") {\r\n                                if (l1.head.Fields[1].Case === \"SetEmpty\") {\r\n                                    var n1k = l1.head.Fields[0], n1r = l1.head.Fields[2], n2k = l2.head.Fields[0], n2r = l2.head.Fields[2], t1 = l1.tail, t2 = l2.tail, c = comparer.Compare(n1k, n2k);\r\n                                    if (c !== 0) {\r\n                                        return c;\r\n                                    }\r\n                                    else {\r\n                                        return tree_compareStacks(comparer, listOfArray([n1r], t1), listOfArray([n2r], t2));\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);\r\n                                }\r\n                            }\r\n                            else {\r\n                                return $target11(l2.head.Fields[0], l2.head.Fields[1], l2.head.Fields[2], l2.tail);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (l1.head.Case === \"SetOne\") {\r\n                            return $target8(l1.head.Fields[0], l1.tail);\r\n                        }\r\n                        else {\r\n                            if (l1.head.Case === \"SetNode\") {\r\n                                return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);\r\n                            }\r\n                            else {\r\n                                return $target11(l2.head.Fields[0], l2.head.Fields[1], l2.head.Fields[2], l2.tail);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (l1.head.Case === \"SetOne\") {\r\n                        return $target8(l1.head.Fields[0], l1.tail);\r\n                    }\r\n                    else {\r\n                        if (l1.head.Case === \"SetNode\") {\r\n                            return $target9(l1.head.Fields[0], l1.head.Fields[1], l1.head.Fields[2], l1.tail);\r\n                        }\r\n                        else {\r\n                            return tree_compareStacks(comparer, l1.tail, l2.tail);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            return 1;\r\n        }\r\n    }\r\n    else {\r\n        if (l2.tail != null) {\r\n            return -1;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n}\r\nfunction tree_compare(comparer, s1, s2) {\r\n    if (s1.Case === \"SetEmpty\") {\r\n        if (s2.Case === \"SetEmpty\") {\r\n            return 0;\r\n        }\r\n        else {\r\n            return -1;\r\n        }\r\n    }\r\n    else {\r\n        if (s2.Case === \"SetEmpty\") {\r\n            return 1;\r\n        }\r\n        else {\r\n            return tree_compareStacks(comparer, listOfArray([s1]), listOfArray([s2]));\r\n        }\r\n    }\r\n}\r\nfunction tree_mkFromEnumerator(comparer, acc, e) {\r\n    var cur = e.next();\r\n    while (!cur.done) {\r\n        acc = tree_add(comparer, cur.value, acc);\r\n        cur = e.next();\r\n    }\r\n    return acc;\r\n}\r\nfunction tree_ofSeq(comparer, c) {\r\n    var ie = c[Symbol.iterator]();\r\n    return tree_mkFromEnumerator(comparer, new SetTree(\"SetEmpty\", []), ie);\r\n}\r\nvar FableSet = (function () {\r\n    function FableSet() {\r\n    }\r\n    FableSet.prototype.ToString = function () {\r\n        return \"set [\" + Array.from(this).map(toString).join(\"; \") + \"]\";\r\n    };\r\n    FableSet.prototype.Equals = function (s2) {\r\n        return this.CompareTo(s2) === 0;\r\n    };\r\n    FableSet.prototype.CompareTo = function (s2) {\r\n        return this === s2 ? 0 : tree_compare(this.comparer, this.tree, s2.tree);\r\n    };\r\n    FableSet.prototype[Symbol.iterator] = function () {\r\n        var i = tree_mkIterator(this.tree);\r\n        return {\r\n            next: function () { return tree_moveNext(i); }\r\n        };\r\n    };\r\n    FableSet.prototype.values = function () {\r\n        return this[Symbol.iterator]();\r\n    };\r\n    FableSet.prototype.has = function (v) {\r\n        return tree_mem(this.comparer, v, this.tree);\r\n    };\r\n    FableSet.prototype.add = function (v) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    FableSet.prototype.delete = function (v) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    FableSet.prototype.clear = function () {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    Object.defineProperty(FableSet.prototype, \"size\", {\r\n        get: function () {\r\n            return tree_count(this.tree);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    FableSet.prototype[FSymbol.reflection] = function () {\r\n        return {\r\n            type: \"Microsoft.FSharp.Collections.FSharpSet\",\r\n            interfaces: [\"System.IEquatable\", \"System.IComparable\"]\r\n        };\r\n    };\r\n    return FableSet;\r\n}());\r\nexport default FableSet;\r\nfunction from(comparer, tree) {\r\n    var s = new FableSet();\r\n    s.tree = tree;\r\n    s.comparer = comparer || new GenericComparer();\r\n    return s;\r\n}\r\nexport function create(ie, comparer) {\r\n    comparer = comparer || new GenericComparer();\r\n    return from(comparer, ie ? tree_ofSeq(comparer, ie) : new SetTree(\"SetEmpty\", []));\r\n}\r\nexport function isEmpty(s) {\r\n    return tree_isEmpty(s.tree);\r\n}\r\nexport function add(item, s) {\r\n    return from(s.comparer, tree_add(s.comparer, item, s.tree));\r\n}\r\nexport function addInPlace(item, s) {\r\n    return s.has(item) ? false : (s.add(item), true);\r\n}\r\nexport function remove(item, s) {\r\n    return from(s.comparer, tree_remove(s.comparer, item, s.tree));\r\n}\r\nexport function union(set1, set2) {\r\n    return set2.tree.Case === \"SetEmpty\"\r\n        ? set1\r\n        : set1.tree.Case === \"SetEmpty\"\r\n            ? set2\r\n            : from(set1.comparer, tree_union(set1.comparer, set1.tree, set2.tree));\r\n}\r\nexport function op_Addition(set1, set2) {\r\n    return union(set1, set2);\r\n}\r\nexport function unionInPlace(set1, set2) {\r\n    seqIterate(function (x) { set1.add(x); }, set2);\r\n}\r\nexport function unionMany(sets) {\r\n    return seqFold(function (acc, s) { return union(s, acc); }, create(), sets);\r\n}\r\nexport function difference(set1, set2) {\r\n    return set1.tree.Case === \"SetEmpty\"\r\n        ? set1\r\n        : set2.tree.Case === \"SetEmpty\"\r\n            ? set1\r\n            : from(set1.comparer, tree_diff(set1.comparer, set1.tree, set2.tree));\r\n}\r\nexport function op_Subtraction(set1, set2) {\r\n    return difference(set1, set2);\r\n}\r\nexport function differenceInPlace(set1, set2) {\r\n    seqIterate(function (x) { set1.delete(x); }, set2);\r\n}\r\nexport function intersect(set1, set2) {\r\n    return set2.tree.Case === \"SetEmpty\"\r\n        ? set2\r\n        : set1.tree.Case === \"SetEmpty\"\r\n            ? set1\r\n            : from(set1.comparer, tree_intersection(set1.comparer, set1.tree, set2.tree));\r\n}\r\nexport function intersectInPlace(set1, set2) {\r\n    var set2_ = set2 instanceof Set ? set2 : new Set(set2);\r\n    seqIterate(function (x) { if (!set2_.has(x)) {\r\n        set1.delete(x);\r\n    } }, set1);\r\n}\r\nexport function intersectMany(sets) {\r\n    return seqReduce(function (s1, s2) { return intersect(s1, s2); }, sets);\r\n}\r\nexport function isProperSubsetOf(set1, set2) {\r\n    if (set1 instanceof FableSet && set2 instanceof FableSet) {\r\n        return tree_psubset(set1.comparer, set1.tree, set2.tree);\r\n    }\r\n    else {\r\n        set2 = set2 instanceof Set ? set2 : new Set(set2);\r\n        return seqForAll(function (x) { return set2.has(x); }, set1) && seqExists(function (x) { return !set1.has(x); }, set2);\r\n    }\r\n}\r\nexport function isProperSubset(set1, set2) {\r\n    return isProperSubsetOf(set1, set2);\r\n}\r\nexport function isSubsetOf(set1, set2) {\r\n    if (set1 instanceof FableSet && set2 instanceof FableSet) {\r\n        return tree_subset(set1.comparer, set1.tree, set2.tree);\r\n    }\r\n    else {\r\n        set2 = set2 instanceof Set ? set2 : new Set(set2);\r\n        return seqForAll(function (x) { return set2.has(x); }, set1);\r\n    }\r\n}\r\nexport function isSubset(set1, set2) {\r\n    return isSubsetOf(set1, set2);\r\n}\r\nexport function isProperSupersetOf(set1, set2) {\r\n    if (set1 instanceof FableSet && set2 instanceof FableSet) {\r\n        return tree_psubset(set1.comparer, set2.tree, set1.tree);\r\n    }\r\n    else {\r\n        return isProperSubset(set2 instanceof Set ? set2 : new Set(set2), set1);\r\n    }\r\n}\r\nexport function isProperSuperset(set1, set2) {\r\n    return isProperSupersetOf(set1, set2);\r\n}\r\nexport function isSupersetOf(set1, set2) {\r\n    if (set1 instanceof FableSet && set2 instanceof FableSet) {\r\n        return tree_subset(set1.comparer, set2.tree, set1.tree);\r\n    }\r\n    else {\r\n        return isSubset(set2 instanceof Set ? set2 : new Set(set2), set1);\r\n    }\r\n}\r\nexport function isSuperset(set1, set2) {\r\n    return isSupersetOf(set1, set2);\r\n}\r\nexport function copyTo(xs, arr, arrayIndex, count) {\r\n    if (!Array.isArray(arr) && !ArrayBuffer.isView(arr))\r\n        throw new Error(\"Array is invalid\");\r\n    count = count || arr.length;\r\n    var i = arrayIndex || 0;\r\n    var iter = xs[Symbol.iterator]();\r\n    while (count--) {\r\n        var el = iter.next();\r\n        if (el.done)\r\n            break;\r\n        arr[i++] = el.value;\r\n    }\r\n}\r\nexport function partition(f, s) {\r\n    if (s.tree.Case === \"SetEmpty\") {\r\n        return [s, s];\r\n    }\r\n    else {\r\n        var tuple = tree_partition(s.comparer, f, s.tree);\r\n        return [from(s.comparer, tuple[0]), from(s.comparer, tuple[1])];\r\n    }\r\n}\r\nexport function filter(f, s) {\r\n    if (s.tree.Case === \"SetEmpty\") {\r\n        return s;\r\n    }\r\n    else {\r\n        return from(s.comparer, tree_filter(s.comparer, f, s.tree));\r\n    }\r\n}\r\nexport function map(f, s) {\r\n    var comparer = new GenericComparer();\r\n    return from(comparer, tree_fold(function (acc, k) { return tree_add(comparer, f(k), acc); }, new SetTree(\"SetEmpty\", []), s.tree));\r\n}\r\nexport function exists(f, s) {\r\n    return tree_exists(f, s.tree);\r\n}\r\nexport function forAll(f, s) {\r\n    return tree_forall(f, s.tree);\r\n}\r\nexport function fold(f, seed, s) {\r\n    return tree_fold(f, seed, s.tree);\r\n}\r\nexport function foldBack(f, s, seed) {\r\n    return tree_foldBack(f, s.tree, seed);\r\n}\r\nexport function iterate(f, s) {\r\n    tree_iter(f, s.tree);\r\n}\r\nexport function minimumElement(s) {\r\n    return tree_minimumElement(s.tree);\r\n}\r\nexport function minElement(s) {\r\n    return tree_minimumElement(s.tree);\r\n}\r\nexport function maximumElement(s) {\r\n    return tree_maximumElement(s.tree);\r\n}\r\nexport function maxElement(s) {\r\n    return tree_maximumElement(s.tree);\r\n}\r\n","var Trampoline = (function () {\r\n    function Trampoline() {\r\n        this.callCount = 0;\r\n    }\r\n    Object.defineProperty(Trampoline, \"maxTrampolineCallCount\", {\r\n        get: function () {\r\n            return 2000;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Trampoline.prototype.incrementAndCheck = function () {\r\n        return this.callCount++ > Trampoline.maxTrampolineCallCount;\r\n    };\r\n    Trampoline.prototype.hijack = function (f) {\r\n        this.callCount = 0;\r\n        setTimeout(f, 0);\r\n    };\r\n    return Trampoline;\r\n}());\r\nexport { Trampoline };\r\nexport function protectedCont(f) {\r\n    return function (ctx) {\r\n        if (ctx.cancelToken.isCancelled)\r\n            ctx.onCancel(\"cancelled\");\r\n        else if (ctx.trampoline.incrementAndCheck())\r\n            ctx.trampoline.hijack(function () {\r\n                try {\r\n                    f(ctx);\r\n                }\r\n                catch (err) {\r\n                    ctx.onError(err);\r\n                }\r\n            });\r\n        else\r\n            try {\r\n                f(ctx);\r\n            }\r\n            catch (err) {\r\n                ctx.onError(err);\r\n            }\r\n    };\r\n}\r\nexport function protectedBind(computation, binder) {\r\n    return protectedCont(function (ctx) {\r\n        computation({\r\n            onSuccess: function (x) {\r\n                try {\r\n                    binder(x)(ctx);\r\n                }\r\n                catch (ex) {\r\n                    ctx.onError(ex);\r\n                }\r\n            },\r\n            onError: ctx.onError,\r\n            onCancel: ctx.onCancel,\r\n            cancelToken: ctx.cancelToken,\r\n            trampoline: ctx.trampoline\r\n        });\r\n    });\r\n}\r\nexport function protectedReturn(value) {\r\n    return protectedCont(function (ctx) { return ctx.onSuccess(value); });\r\n}\r\nvar AsyncBuilder = (function () {\r\n    function AsyncBuilder() {\r\n    }\r\n    AsyncBuilder.prototype.Bind = function (computation, binder) {\r\n        return protectedBind(computation, binder);\r\n    };\r\n    AsyncBuilder.prototype.Combine = function (computation1, computation2) {\r\n        return this.Bind(computation1, function () { return computation2; });\r\n    };\r\n    AsyncBuilder.prototype.Delay = function (generator) {\r\n        return protectedCont(function (ctx) { return generator()(ctx); });\r\n    };\r\n    AsyncBuilder.prototype.For = function (sequence, body) {\r\n        var iter = sequence[Symbol.iterator]();\r\n        var cur = iter.next();\r\n        return this.While(function () { return !cur.done; }, this.Delay(function () {\r\n            var res = body(cur.value);\r\n            cur = iter.next();\r\n            return res;\r\n        }));\r\n    };\r\n    AsyncBuilder.prototype.Return = function (value) {\r\n        return protectedReturn(value);\r\n    };\r\n    AsyncBuilder.prototype.ReturnFrom = function (computation) {\r\n        return computation;\r\n    };\r\n    AsyncBuilder.prototype.TryFinally = function (computation, compensation) {\r\n        return protectedCont(function (ctx) {\r\n            computation({\r\n                onSuccess: function (x) {\r\n                    compensation();\r\n                    ctx.onSuccess(x);\r\n                },\r\n                onError: function (x) {\r\n                    compensation();\r\n                    ctx.onError(x);\r\n                },\r\n                onCancel: function (x) {\r\n                    compensation();\r\n                    ctx.onCancel(x);\r\n                },\r\n                cancelToken: ctx.cancelToken,\r\n                trampoline: ctx.trampoline\r\n            });\r\n        });\r\n    };\r\n    AsyncBuilder.prototype.TryWith = function (computation, catchHandler) {\r\n        return protectedCont(function (ctx) {\r\n            computation({\r\n                onSuccess: ctx.onSuccess,\r\n                onCancel: ctx.onCancel,\r\n                cancelToken: ctx.cancelToken,\r\n                trampoline: ctx.trampoline,\r\n                onError: function (ex) {\r\n                    try {\r\n                        catchHandler(ex)(ctx);\r\n                    }\r\n                    catch (ex2) {\r\n                        ctx.onError(ex2);\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    };\r\n    AsyncBuilder.prototype.Using = function (resource, binder) {\r\n        return this.TryFinally(binder(resource), function () { return resource.Dispose(); });\r\n    };\r\n    AsyncBuilder.prototype.While = function (guard, computation) {\r\n        var _this = this;\r\n        if (guard())\r\n            return this.Bind(computation, function () { return _this.While(guard, computation); });\r\n        else\r\n            return this.Return(void 0);\r\n    };\r\n    AsyncBuilder.prototype.Zero = function () {\r\n        return protectedCont(function (ctx) { return ctx.onSuccess(void 0); });\r\n    };\r\n    return AsyncBuilder;\r\n}());\r\nexport { AsyncBuilder };\r\nexport var singleton = new AsyncBuilder();\r\n","import { Trampoline } from \"./AsyncBuilder\";\r\nimport { protectedCont } from \"./AsyncBuilder\";\r\nimport { protectedBind } from \"./AsyncBuilder\";\r\nimport { protectedReturn } from \"./AsyncBuilder\";\r\nimport { choice1Of2 } from \"./Choice\";\r\nimport { choice2Of2 } from \"./Choice\";\r\nimport { map } from \"./Seq\";\r\nvar Async = (function () {\r\n    function Async() {\r\n    }\r\n    return Async;\r\n}());\r\nexport default Async;\r\nfunction emptyContinuation(x) {\r\n}\r\nexport function awaitPromise(p) {\r\n    return fromContinuations(function (conts) {\r\n        return p.then(conts[0]).catch(function (err) {\r\n            return (err == \"cancelled\" ? conts[2] : conts[1])(err);\r\n        });\r\n    });\r\n}\r\nexport function cancellationToken() {\r\n    return protectedCont(function (ctx) { return ctx.onSuccess(ctx.cancelToken); });\r\n}\r\nexport var defaultCancellationToken = { isCancelled: false };\r\nexport function catchAsync(work) {\r\n    return protectedCont(function (ctx) {\r\n        work({\r\n            onSuccess: function (x) { return ctx.onSuccess(choice1Of2(x)); },\r\n            onError: function (ex) { return ctx.onSuccess(choice2Of2(ex)); },\r\n            onCancel: ctx.onCancel,\r\n            cancelToken: ctx.cancelToken,\r\n            trampoline: ctx.trampoline\r\n        });\r\n    });\r\n}\r\nexport function fromContinuations(f) {\r\n    return protectedCont(function (ctx) { return f([ctx.onSuccess, ctx.onError, ctx.onCancel]); });\r\n}\r\nexport function ignore(computation) {\r\n    return protectedBind(computation, function (x) { return protectedReturn(void 0); });\r\n}\r\nexport function parallel(computations) {\r\n    return awaitPromise(Promise.all(map(function (w) { return startAsPromise(w); }, computations)));\r\n}\r\nexport function sleep(millisecondsDueTime) {\r\n    return protectedCont(function (ctx) {\r\n        setTimeout(function () { return ctx.cancelToken.isCancelled ? ctx.onCancel(\"cancelled\") : ctx.onSuccess(void 0); }, millisecondsDueTime);\r\n    });\r\n}\r\nexport function start(computation, cancellationToken) {\r\n    return startWithContinuations(computation, cancellationToken);\r\n}\r\nexport function startImmediate(computation, cancellationToken) {\r\n    return start(computation, cancellationToken);\r\n}\r\nexport function startWithContinuations(computation, continuation, exceptionContinuation, cancellationContinuation, cancelToken) {\r\n    if (typeof continuation !== \"function\") {\r\n        cancelToken = continuation;\r\n        continuation = null;\r\n    }\r\n    var trampoline = new Trampoline();\r\n    computation({\r\n        onSuccess: continuation ? continuation : emptyContinuation,\r\n        onError: exceptionContinuation ? exceptionContinuation : emptyContinuation,\r\n        onCancel: cancellationContinuation ? cancellationContinuation : emptyContinuation,\r\n        cancelToken: cancelToken ? cancelToken : defaultCancellationToken,\r\n        trampoline: trampoline\r\n    });\r\n}\r\nexport function startAsPromise(computation, cancellationToken) {\r\n    return new Promise(function (resolve, reject) {\r\n        return startWithContinuations(computation, resolve, reject, reject, cancellationToken ? cancellationToken : defaultCancellationToken);\r\n    });\r\n}\r\n","﻿module TheGamma.Common\n\nopen Fable.Core\nopen Fable.Import.JS\nopen Fable.Import.Browser\nopen System.Collections.Generic\nmodule FsOption = Microsoft.FSharp.Core.Option\n\n[<Emit(\"$0[$1]\")>]\nlet getProperty<'T> (obj:obj) (name:string) : 'T = failwith \"never\"\n\n[<Emit(\"parseInt($0, $1)\")>]\nlet parseInt (s:string) (b:int) : int = failwith \"JS\"\n\n[<Emit(\"$0.toString($1)\")>]\nlet formatInt (i:int) (b:int) : string = failwith \"JS\"\n\n[<Emit(\"(typeof($0)=='number')\")>]\nlet isNumber(n:obj) : bool = failwith \"!\"\n\n[<Emit(\"($0 instanceof Date)\")>]\nlet isDate(n:obj) : bool = failwith \"!\"\n\n[<Emit(\"$0.toISOString()\")>]\nlet toISOString(o:obj) : string = failwith \"!\"\n\n[<Emit(\"new Date($0)\")>]\nlet asDate(n:float) : System.DateTime = failwith \"!\"\n\n[<Emit(\"($0 instanceof Date) ? $0.getTime() : $0\")>]\nlet dateOrNumberAsNumber(n:obj) : float = failwith \"!\"\n\n[<Emit(\"\"\"($0.toLocaleString(\"en-US\",{day:\"numeric\",year:\"numeric\",month:\"short\"}))\"\"\")>]\nlet formatDate(d:obj) : string = failwith \"!\"\n\n[<Emit(\"\"\"$0.toLocaleString(\"en-GB\",{day:\"numeric\",year:\"numeric\",month:\"long\"})\"\"\")>]\nlet formatLongDate(d:obj) : string = failwith \"!\"\n\n[<Emit(\"\"\"($0.toLocaleString(\"en-US\",{hour:\"numeric\",minute:\"numeric\",second:\"numeric\"}))\"\"\")>]\nlet formatTime(d:obj) : string = failwith \"!\"\n\n[<Emit(\"\"\"($0.toLocaleString(\"en-US\",{hour:\"numeric\",minute:\"numeric\",second:\"numeric\"}) + \", \" +\n    $0.toLocaleString(\"en-US\",{day:\"numeric\",year:\"numeric\",month:\"short\"}))\"\"\")>]\nlet formatDateTime(d:obj) : string = failwith \"!\"\n\n[<Emit(\"(typeof($0)=='object')\")>]\nlet isObject(n:obj) : bool = failwith \"!\"\n\n[<Emit(\"Array.isArray($0)\")>]\nlet isArray(n:obj) : bool = failwith \"!\"\n\n[<Emit(\"isNaN($0)\")>]\nlet isNaN(n:float) : bool = failwith \"!\"\n\nlet niceNumber num decs =\n  let str = string num\n  let dot = str.IndexOf('.')\n  let before, after = \n    if dot = -1 then str, \"\"\n    else str.Substring(0, dot), str.Substring(dot + 1, min decs (str.Length - dot - 1))\n  let after = \n    if after.Length < decs then after + System.String [| for i in 1 .. (decs - after.Length) -> '0' |]\n    else after \n  let mutable res = before\n  if before.Length > 5 then\n    for i in before.Length-1 .. -1 .. 0 do\n      let j = before.Length - i\n      if i <> 0 && j % 3 = 0 then res <- res.Insert(i, \",\")\n  if Seq.forall ((=) '0') after then res\n  else res + \".\" + after\n\n[<Emit(\"JSON.stringify($0)\")>]\nlet jsonStringify json : string = failwith \"JS Only\"\n\n[<Emit(\"JSON.parse($0)\")>]\nlet jsonParse<'R> (str:string) : 'R = failwith \"JS Only\"\n\n[<Emit(\"console.log.apply(console, $0)\")>]\nlet consoleLog (args:obj[]) : unit = \n  let format = args.[0] :?> string\n  let mutable argIndex = 1\n  let mutable charIndex = 0\n  let mutable res = \"\"\n  while charIndex < format.Length do\n    if format.[charIndex] = '%' then\n      res <- res +\n        match format.[charIndex+1] with\n        | 'c' -> \"\"\n        | 's' -> args.[argIndex].ToString()\n        | 'O' -> sprintf \"%A\" (args.[argIndex])\n        | _ -> failwith \"consoleLog: Unsupported formatter\"\n      argIndex <- argIndex + 1\n      charIndex <- charIndex + 2\n    else \n      res <- res + format.[charIndex].ToString()\n      charIndex <- charIndex + 1\n  printfn \"%s\" res\n\n[<Emit(\"if (typeof logEvent != 'undefined') logEvent($0, $1, $2, $3)\")>]\nlet logEvent (category:string) (evt:string) (article:string) (data:obj) : unit = failwith \"JS only\"\n\n[<Emit(\"typeof window == 'undefined'\")>]\nlet windowUndefined () : bool = true\n\nlet isLocalHost() = \n  windowUndefined () ||\n  window.location.hostname = \"localhost\" || \n  window.location.hostname = \"127.0.0.1\"\n\nlet mutable enabledCategories = \n  if not (isLocalHost ()) then set []\n  //else set [\"TYPECHECKER\"; \"PROVIDERS\"] \n  else set [\"*\"] \ntype Log =\n  static member setEnabled(cats) = enabledCategories <- cats\n\n  static member event(category:string, evt:string, article:string, data:obj) = \n    logEvent category evt article data\n\n  static member message(level:string, category:string, msg:string, [<System.ParamArray>] args) = \n    let args = if args = null then [| |] else args\n    let category = category.ToUpper()\n    if not (isLocalHost ()) && level = \"EXCEPTION\" then\n      logEvent \"system\" \"exception\" \"\" (JsInterop.createObj [\"category\", box category; \"msg\", box msg; \"args\", box args ])\n\n    if level = \"EXCEPTION\" || level = \"ERROR\" || enabledCategories.Contains \"*\" || enabledCategories.Contains category then\n      let dt = System.DateTime.Now\n      let p2 (s:int) = (string s).PadLeft(2, '0')\n      let p4 (s:int) = (string s).PadLeft(4, '0')\n      let prefix = sprintf \"[%s:%s:%s:%s] %s: \" (p2 dt.Hour) (p2 dt.Minute) (p2 dt.Second) (p4 dt.Millisecond) category\n      let color = \n        match level with\n        | \"TRACE\" -> \"color:#808080\"\n        | \"EXCEPTION\" -> \"color:#c00000\"\n        | \"ERROR\" -> \"color:#900000\"\n        | _ -> \"\"\n      consoleLog(FSharp.Collections.Array.append [|box (\"%c\" + prefix + msg); box color|] args)\n\n  static member trace(category:string, msg:string, [<System.ParamArray>] args) = \n    Log.message(\"TRACE\", category, msg, args)\n\n  static member exn(category:string, msg:string, [<System.ParamArray>] args) = \n    Log.message(\"EXCEPTION\", category, msg, args)\n\n  static member error(category:string, msg:string, [<System.ParamArray>] args) = \n    Log.message(\"ERROR\", category, msg, args)\n\ntype Http =\n  /// Send HTTP request asynchronously\n  static member Request(meth, url, ?data, ?cookies) =\n    Async.FromContinuations(fun (cont, econt, _) ->\n      let xhr = XMLHttpRequest.Create()\n      xhr.``open``(meth, url, true)\n      match cookies with \n      | Some cookies when cookies <> \"\" -> xhr.setRequestHeader(\"X-Cookie\", cookies)\n      | _ -> ()\n      xhr.onreadystatechange <- fun _ ->\n        if xhr.readyState > 3. && xhr.status = 200. then\n          cont(xhr.responseText)\n        if xhr.readyState > 3. && xhr.status = 0. then\n          econt(System.Exception(meth + \" \" + url + \" failed: \" + xhr.statusText))\n        obj()\n      xhr.send(defaultArg data \"\") )\n\ntype Future<'T> = \n  abstract Then : ('T -> unit) -> unit\n\ntype Microsoft.FSharp.Control.Async with\n  static member AwaitFuture (f:Future<'T>) = Async.FromContinuations(fun (cont, _, _) ->\n    f.Then(cont))\n\n  static member Future (n:string option) op start = \n    let mutable res = Choice1Of3()\n    let mutable handlers = []\n    let mutable running = false\n\n    let trigger h = \n      match res with\n      | Choice1Of3 () -> handlers <- h::handlers \n      | Choice2Of3 v -> h v\n      | Choice3Of3 e -> raise e\n\n    let ensureStarted() = \n      if not running then \n        n |> FsOption.iter (fun n -> Log.trace(\"system\", \"Starting future '%s'....\", n))\n        running <- true\n        async { try \n                  let! r = op\n                  n |> FsOption.iter (fun n -> Log.trace(\"system\", \"Future '%s' evaluated to: %O\", n, r))\n                  res <- Choice2Of3 r                  \n                with e ->\n                  Log.exn(\"system\", \"Evaluating future failed: %O\", e)\n                  res <- Choice3Of3 e\n                for h in handlers do trigger h } |> Async.StartImmediate\n    if start = true then ensureStarted()\n\n    { new Future<_> with\n        member x.Then(f) = \n          ensureStarted()\n          trigger f }\n\n  static member CreateFuture(op) = Async.Future None op false\n  static member StartAsFuture(op) = Async.Future None op true\n  static member CreateNamedFuture name op = Async.Future (Some name) op false\n  static member StartAsNamedFuture name op = Async.Future (Some name) op true\n\nmodule Async = \n  module Array =\n    module Parallel =\n      let rec map f (ar:_[]) = async {\n        let res = FSharp.Collections.Array.zeroCreate ar.Length\n        let work = \n          [ for i in 0 .. ar.Length-1 -> async {\n              let! v = f ar.[i]\n              res.[i] <- v } ] |> Async.Parallel\n        let! _ = work\n        return res }\n\n    let rec map f (ar:_[]) = async {\n      let res = FSharp.Collections.Array.zeroCreate ar.Length\n      for i in 0 .. ar.Length-1 do\n        let! v = f ar.[i]\n        res.[i] <- v\n      return res }\n\n  let rec collect f l = async {\n    match l with \n    | x::xs -> \n        let! y = f x\n        let! ys = collect f xs\n        return List.append y ys\n    | [] -> return [] }\n\n  let rec choose f l = async {\n    match l with \n    | x::xs -> \n        let! y = f x\n        let! ys = choose f xs\n        return match y with None -> ys | Some y -> y::ys \n    | [] -> return [] }\n\n  let rec map f l = async {\n    match l with \n    | x::xs -> \n        let! y = f x\n        let! ys = map f xs\n        return y::ys\n    | [] -> return [] }\n\n  let rec foldMap f st l = async {\n    match l with\n    | x::xs ->\n        let! y, st = f st x\n        let! st, ys = foldMap f st xs\n        return st, y::ys\n    | [] -> return st, [] }\n\n  let rec fold f st l = async {\n    match l with\n    | x::xs ->\n        let! st = f st x\n        return! fold f st xs \n    | [] -> return st }\n\n/// Symbol is a unique immutable identiifer (we use JavaScript symbols)\ntype Symbol = interface end\n\n[<Emit(\"Symbol()\")>]\nlet createSymbol () = { new Symbol }\n\ntype ListDictionaryNode<'K, 'T> = \n  { mutable Result : 'T option\n    Nested : Dictionary<'K, ListDictionaryNode<'K, 'T>> }\n\ntype ListDictionary<'K, 'V> = Dictionary<'K, ListDictionaryNode<'K, 'V>>\n\nmodule JsHelpers = \n  type KeyValue = \n    abstract key : string\n    abstract value : obj\n\n  [<Emit(\"(function(o) { return Object.keys(o).map(function(k) { return {\\\"key\\\":k, \\\"value\\\":o[k] }; }); })($0)\")>]\n  let properties(o:obj) : KeyValue[] = failwith \"!\"\n\n[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]\nmodule ListDictionary = \n  let tryFind ks dict = \n    let rec loop ks node =\n      match ks, node with\n      | [], { Result = Some r } -> Some r\n      | k::ks, { Nested = d } when d.ContainsKey k -> loop ks (d.[k])\n      | _ -> None\n    loop ks { Nested = dict; Result = None }\n\n  let set ks v dict =\n    let rec loop ks (dict:ListDictionary<_, _>) = \n      match ks with\n      | [] -> failwith \"Empty key not supported\"\n      | k::ks ->\n          if not (dict.ContainsKey k) then dict.[k] <- { Nested = Dictionary<_, _>(); Result = None }\n          if List.isEmpty ks then dict.[k].Result <- Some v\n          else loop ks (dict.[k].Nested)\n    loop ks dict\n\n  let count (dict:ListDictionary<_, _>) = \n    let rec loop node = \n      let nest = node.Nested |> Seq.sumBy (fun kv -> loop kv.Value)\n      if node.Result.IsSome then 1 + nest else nest\n    dict |> Seq.sumBy (fun kv -> loop kv.Value)\n\nmodule List = \n  let groupWith f list = \n    let groups = ResizeArray<_ * ResizeArray<_>>()\n    for e in list do\n      let mutable added = false \n      let mutable i = 0\n      while not added && i < groups.Count do\n        if f e (fst groups.[i]) then \n          (snd groups.[i]).Add(e)\n          added <- true\n        i <- i + 1\n      if not added then \n        groups.Add(e, ResizeArray<_>([e]))\n    groups |> Seq.map (snd >> List.ofSeq) |> List.ofSeq\n\n  let unreduce f s = s |> Seq.unfold (fun s -> \n    f s |> Microsoft.FSharp.Core.Option.map (fun v -> v, v)) |> List.ofSeq\n","﻿module TheGamma.TypeProvidersRuntime\nopen System\nopen TheGamma.Common\n\nlet convertTupleSequence f g data = async {\n  let! values = data\n  return values |> Array.map (fun (a, b) -> f a, g b) }\n\nlet convertSequence f data = async {\n  let! values = data\n  return values |> Array.map f }\n\nlet trimLeft c (s:string) = s.ToCharArray() |> Array.skipWhile ((=) c) |> System.String\nlet trimRight c (s:string) = s.ToCharArray() |> Array.rev |> Array.skipWhile ((=) c) |> Array.rev |> System.String\n\nlet concatUrl (a:string) (b:string) =\n  (trimRight '/' a) + \"/\" + (trimLeft '/' b)\n\ntype RuntimeContext(root:string, cookies:string, trace:string) = \n  member x.root = root\n  member x.trace = trace\n  \n  member x.addTrace(suffix) = \n    let traces = \n      [ if not (String.IsNullOrEmpty trace) then yield trace\n        if not (String.IsNullOrEmpty suffix) then yield suffix ]\n    RuntimeContext(root, cookies, String.concat \"&\" traces)\n  \n  member x.getValue(endpoint:string) =     \n    async { \n      let! res = Http.Request(\"POST\", concatUrl root endpoint, trace, cookies)\n      // TODO: This is wrong - it may return an integer too!\n      return jsonParse<obj> res }\n\ntype PivotContext(root, calls) = \n  member x.addCall(callid:string, values:obj[]) =\n    let values = values |> Array.map (fun v ->\n      if isDate v then box (toISOString v) else v)\n    PivotContext(root, Array.append [| callid, values |] calls)\n\n  member x.getData(conv:obj -> obj, tfs:string, isPreview) = async {\n    let url = calls |> Array.fold (fun (tfs:string) (id, vals) -> \n      let vals = String.concat \",\" (Seq.map string vals)\n      tfs.Replace(id, string vals)) tfs\n    let url = Fable.Import.JS.encodeURIComponent url\n    let url = root + \"?\" + url + if isPreview then \"&preview\" else \"\"\n    Log.trace(\"runtime\", \"Pivot: %s\", url)\n    let! res = Http.Request(\"GET\", url)\n    return jsonParse<obj[]> res |> Array.map conv }\n","// AUTO-GENERATED - DO NOT EDIT\n[<ReflectedDefinition;AutoOpen>]\nmodule TheGamma.GoogleCharts.Extensions\n\nopen System\nopen TheGamma.GoogleCharts\nopen TheGamma.GoogleCharts.Helpers\nopen TheGamma.GoogleCharts.Options\n\ntype Geo = \n  { data : ChartData; typeName : string; \n    options : GeoChartOptions }\n  interface Chart\n  member x.show(outputId) = Helpers.showChart x outputId\n  member x.set(?backgroundColor:obj,?datalessRegionColor:string,?displayMode:string,?enableRegionInteractivity:bool,?height:float,?keepAspectRatio:bool,?region:string,?markerOpacity:float,?resolution:string,?width:float) = \n    let o = x.options\n    let newOptions = { x.options with backgroundColor = right o \"backgroundColor\" backgroundColor; datalessRegionColor = right o \"datalessRegionColor\" datalessRegionColor; displayMode = right o \"displayMode\" displayMode; enableRegionInteractivity = right o \"enableRegionInteractivity\" enableRegionInteractivity; height = right o \"height\" height; keepAspectRatio = right o \"keepAspectRatio\" keepAspectRatio; region = right o \"region\" region; markerOpacity = right o \"markerOpacity\" markerOpacity; resolution = right o \"resolution\" resolution; width = right o \"width\" width }\n    { x with options = newOptions }\n  member x.colorAxis(?minValue:float,?maxValue:float,?values:seq<float>,?colors:seq<string>) =\n    let o = x.options.colorAxis\n    let newNested = { ChartColorAxis.minValue = right o \"minValue\" minValue; maxValue = right o \"maxValue\" maxValue; values = right o \"values\" (Option.map Array.ofSeq values); colors = right o \"colors\" (Option.map Array.ofSeq colors); legend = copy o \"legend\" }\n    { x with options = { x.options with colorAxis = newNested } }\n  member x.legend(?alignment:string,?maxLines:float,?position:string,?numberFormat:string) =\n    let o = x.options.legend\n    let newNested = { ChartLegend.alignment = right o \"alignment\" alignment; maxLines = right o \"maxLines\" maxLines; position = right o \"position\" position; numberFormat = right o \"numberFormat\" numberFormat; textStyle = copy o \"textStyle\" }\n    { x with options = { x.options with legend = newNested } }\n  member x.magnifyingGlass(?enable:bool,?zoomFactor:float) =\n    let o = x.options.magnifyingGlass\n    let newNested = { GeoChartMagnifyingGlass.enable = right o \"enable\" enable; zoomFactor = right o \"zoomFactor\" zoomFactor;  }\n    { x with options = { x.options with magnifyingGlass = newNested } }\n  member x.sizeAxis(?maxSize:float,?maxValue:float,?minSize:float,?minValue:float) =\n    let o = x.options.sizeAxis\n    let newNested = { ChartSizeAxis.maxSize = right o \"maxSize\" maxSize; maxValue = right o \"maxValue\" maxValue; minSize = right o \"minSize\" minSize; minValue = right o \"minValue\" minValue;  }\n    { x with options = { x.options with sizeAxis = newNested } }\n  member x.tooltip(?isHtml:bool,?showColorCode:bool,?trigger:string) =\n    let o = x.options.tooltip\n    let newNested = { ChartTooltip.isHtml = right o \"isHtml\" isHtml; showColorCode = right o \"showColorCode\" showColorCode; trigger = right o \"trigger\" trigger; textStyle = copy o \"textStyle\" }\n    { x with options = { x.options with tooltip = newNested } }\ntype Scatter = \n  { data : ChartData; typeName : string; \n    options : ScatterChartOptions }\n  interface Chart\n  member x.show(outputId) = Helpers.showChart x outputId\n  member x.set(?aggregationTarget:string,?axisTitlesPosition:string,?backgroundColor:obj,?colors:seq<string>,?curveType:string,?dataOpacity:float,?enableInteractivity:bool,?fontSize:float,?fontName:string,?forceIFrame:bool,?height:float,?lineWidth:float,?pointSize:float,?selectionMode:string,?series:obj,?theme:string,?title:string,?titlePosition:string,?width:float) = \n    let o = x.options\n    let newOptions = { x.options with aggregationTarget = right o \"aggregationTarget\" aggregationTarget; axisTitlesPosition = right o \"axisTitlesPosition\" axisTitlesPosition; backgroundColor = right o \"backgroundColor\" backgroundColor; colors = right o \"colors\" (Option.map Array.ofSeq colors); curveType = right o \"curveType\" curveType; dataOpacity = right o \"dataOpacity\" dataOpacity; enableInteractivity = right o \"enableInteractivity\" enableInteractivity; fontSize = right o \"fontSize\" fontSize; fontName = right o \"fontName\" fontName; forceIFrame = right o \"forceIFrame\" forceIFrame; height = right o \"height\" height; lineWidth = right o \"lineWidth\" lineWidth; pointSize = right o \"pointSize\" pointSize; selectionMode = right o \"selectionMode\" selectionMode; series = right o \"series\" series; theme = right o \"theme\" theme; title = right o \"title\" title; titlePosition = right o \"titlePosition\" titlePosition; width = right o \"width\" width }\n    { x with options = newOptions }\n  member x.trendlines(?trendlines:seq<Trendline>) =\n    let o = x.options\n    { x with options = { x.options with trendlines = right o \"trendlines\" (Option.map Array.ofSeq trendlines) } }\n  member x.animation(?duration:float,?easing:string) =\n    let o = x.options.animation\n    let newNested = { TransitionAnimation.duration = right o \"duration\" duration; easing = right o \"easing\" easing;  }\n    { x with options = { x.options with animation = newNested } }\n  member x.chartArea(?top:obj,?left:obj,?width:obj,?height:obj) =\n    let o = x.options.chartArea\n    let newNested = { ChartArea.top = right o \"top\" top; left = right o \"left\" left; width = right o \"width\" width; height = right o \"height\" height;  }\n    { x with options = { x.options with chartArea = newNested } }\n  member x.crosshair(?color:string,?opacity:float,?orientation:string,?trigger:string) =\n    let o = x.options.crosshair\n    let newNested = { ChartCrosshair.color = right o \"color\" color; opacity = right o \"opacity\" opacity; orientation = right o \"orientation\" orientation; trigger = right o \"trigger\" trigger; focused = copy o \"focused\"; selected = copy o \"selected\" }\n    { x with options = { x.options with crosshair = newNested } }\n  member x.explorer(?actions:seq<string>,?axis:string,?keepInBounds:bool,?maxZoomIn:float,?maxZoomOut:float,?zoomDelta:float) =\n    let o = x.options.explorer\n    let newNested = { ChartExplorer.actions = right o \"actions\" (Option.map Array.ofSeq actions); axis = right o \"axis\" axis; keepInBounds = right o \"keepInBounds\" keepInBounds; maxZoomIn = right o \"maxZoomIn\" maxZoomIn; maxZoomOut = right o \"maxZoomOut\" maxZoomOut; zoomDelta = right o \"zoomDelta\" zoomDelta;  }\n    { x with options = { x.options with explorer = newNested } }\n  member x.hAxis(?baseline:float,?baselineColor:string,?direction:float,?format:string,?logScale:bool,?textPosition:string,?ticks:seq<obj>,?title:string,?allowContainerBoundaryTextCufoff:bool,?slantedText:bool,?slantedTextAngle:float,?maxAlternation:float,?maxTextLines:float,?minTextSpacing:float,?showTextEvery:float,?maxValue:float,?minValue:float,?viewWindowMode:string) =\n    let o = x.options.hAxis\n    let newNested = { ChartAxis.baseline = right o \"baseline\" baseline; baselineColor = right o \"baselineColor\" baselineColor; direction = right o \"direction\" direction; format = right o \"format\" format; logScale = right o \"logScale\" logScale; textPosition = right o \"textPosition\" textPosition; ticks = right o \"ticks\" (Option.map Array.ofSeq ticks); title = right o \"title\" title; allowContainerBoundaryTextCufoff = right o \"allowContainerBoundaryTextCufoff\" allowContainerBoundaryTextCufoff; slantedText = right o \"slantedText\" slantedText; slantedTextAngle = right o \"slantedTextAngle\" slantedTextAngle; maxAlternation = right o \"maxAlternation\" maxAlternation; maxTextLines = right o \"maxTextLines\" maxTextLines; minTextSpacing = right o \"minTextSpacing\" minTextSpacing; showTextEvery = right o \"showTextEvery\" showTextEvery; maxValue = right o \"maxValue\" maxValue; minValue = right o \"minValue\" minValue; viewWindowMode = right o \"viewWindowMode\" viewWindowMode; gridlines = copy o \"gridlines\"; minorGridlines = copy o \"minorGridlines\"; textStyle = copy o \"textStyle\"; titleTextStyle = copy o \"titleTextStyle\"; viewWindow = copy o \"viewWindow\" }\n    { x with options = { x.options with hAxis = newNested } }\n  member x.legend(?alignment:string,?maxLines:float,?position:string,?numberFormat:string) =\n    let o = x.options.legend\n    let newNested = { ChartLegend.alignment = right o \"alignment\" alignment; maxLines = right o \"maxLines\" maxLines; position = right o \"position\" position; numberFormat = right o \"numberFormat\" numberFormat; textStyle = copy o \"textStyle\" }\n    { x with options = { x.options with legend = newNested } }\n  member x.titleTextStyle(?fontName:string,?fontSize:float,?bold:bool,?italic:bool,?color:string,?auraColor:string,?opacity:float) =\n    let o = x.options.titleTextStyle\n    let newNested = { ChartTextStyle.fontName = right o \"fontName\" fontName; fontSize = right o \"fontSize\" fontSize; bold = right o \"bold\" bold; italic = right o \"italic\" italic; color = right o \"color\" color; auraColor = right o \"auraColor\" auraColor; opacity = right o \"opacity\" opacity;  }\n    { x with options = { x.options with titleTextStyle = newNested } }\n  member x.tooltip(?isHtml:bool,?showColorCode:bool,?trigger:string) =\n    let o = x.options.tooltip\n    let newNested = { ChartTooltip.isHtml = right o \"isHtml\" isHtml; showColorCode = right o \"showColorCode\" showColorCode; trigger = right o \"trigger\" trigger; textStyle = copy o \"textStyle\" }\n    { x with options = { x.options with tooltip = newNested } }\n  member x.vAxis(?baseline:float,?baselineColor:string,?direction:float,?format:string,?logScale:bool,?textPosition:string,?ticks:seq<obj>,?title:string,?allowContainerBoundaryTextCufoff:bool,?slantedText:bool,?slantedTextAngle:float,?maxAlternation:float,?maxTextLines:float,?minTextSpacing:float,?showTextEvery:float,?maxValue:float,?minValue:float,?viewWindowMode:string) =\n    let o = x.options.vAxis\n    let newNested = { ChartAxis.baseline = right o \"baseline\" baseline; baselineColor = right o \"baselineColor\" baselineColor; direction = right o \"direction\" direction; format = right o \"format\" format; logScale = right o \"logScale\" logScale; textPosition = right o \"textPosition\" textPosition; ticks = right o \"ticks\" (Option.map Array.ofSeq ticks); title = right o \"title\" title; allowContainerBoundaryTextCufoff = right o \"allowContainerBoundaryTextCufoff\" allowContainerBoundaryTextCufoff; slantedText = right o \"slantedText\" slantedText; slantedTextAngle = right o \"slantedTextAngle\" slantedTextAngle; maxAlternation = right o \"maxAlternation\" maxAlternation; maxTextLines = right o \"maxTextLines\" maxTextLines; minTextSpacing = right o \"minTextSpacing\" minTextSpacing; showTextEvery = right o \"showTextEvery\" showTextEvery; maxValue = right o \"maxValue\" maxValue; minValue = right o \"minValue\" minValue; viewWindowMode = right o \"viewWindowMode\" viewWindowMode; gridlines = copy o \"gridlines\"; minorGridlines = copy o \"minorGridlines\"; textStyle = copy o \"textStyle\"; titleTextStyle = copy o \"titleTextStyle\"; viewWindow = copy o \"viewWindow\" }\n    { x with options = { x.options with vAxis = newNested } }\ntype Column = \n  { data : ChartData; typeName : string; \n    options : ColumnChartOptions }\n  interface Chart\n  member x.show(outputId) = Helpers.showChart x outputId\n  member x.set(?aggregationTarget:string,?axisTitlesPosition:string,?backgroundColor:obj,?colors:seq<string>,?enableInteractivity:bool,?focusTarget:string,?fontSize:float,?fontName:string,?height:float,?isStacked:bool,?reverseCategories:bool,?selectionMode:string,?series:obj,?theme:string,?title:string,?titlePosition:string,?vAxes:obj,?width:float) = \n    let o = x.options\n    let newOptions = { x.options with aggregationTarget = right o \"aggregationTarget\" aggregationTarget; axisTitlesPosition = right o \"axisTitlesPosition\" axisTitlesPosition; backgroundColor = right o \"backgroundColor\" backgroundColor; colors = right o \"colors\" (Option.map Array.ofSeq colors); enableInteractivity = right o \"enableInteractivity\" enableInteractivity; focusTarget = right o \"focusTarget\" focusTarget; fontSize = right o \"fontSize\" fontSize; fontName = right o \"fontName\" fontName; height = right o \"height\" height; isStacked = right o \"isStacked\" isStacked; reverseCategories = right o \"reverseCategories\" reverseCategories; selectionMode = right o \"selectionMode\" selectionMode; series = right o \"series\" series; theme = right o \"theme\" theme; title = right o \"title\" title; titlePosition = right o \"titlePosition\" titlePosition; vAxes = right o \"vAxes\" vAxes; width = right o \"width\" width }\n    { x with options = newOptions }\n  member x.animation(?duration:float,?easing:string) =\n    let o = x.options.animation\n    let newNested = { TransitionAnimation.duration = right o \"duration\" duration; easing = right o \"easing\" easing;  }\n    { x with options = { x.options with animation = newNested } }\n  member x.bar(?groupWidth:obj) =\n    let o = x.options.bar\n    let newNested = { GroupWidth.groupWidth = right o \"groupWidth\" groupWidth;  }\n    { x with options = { x.options with bar = newNested } }\n  member x.chartArea(?top:obj,?left:obj,?width:obj,?height:obj) =\n    let o = x.options.chartArea\n    let newNested = { ChartArea.top = right o \"top\" top; left = right o \"left\" left; width = right o \"width\" width; height = right o \"height\" height;  }\n    { x with options = { x.options with chartArea = newNested } }\n  member x.hAxis(?baseline:float,?baselineColor:string,?direction:float,?format:string,?logScale:bool,?textPosition:string,?ticks:seq<obj>,?title:string,?allowContainerBoundaryTextCufoff:bool,?slantedText:bool,?slantedTextAngle:float,?maxAlternation:float,?maxTextLines:float,?minTextSpacing:float,?showTextEvery:float,?maxValue:float,?minValue:float,?viewWindowMode:string) =\n    let o = x.options.hAxis\n    let newNested = { ChartAxis.baseline = right o \"baseline\" baseline; baselineColor = right o \"baselineColor\" baselineColor; direction = right o \"direction\" direction; format = right o \"format\" format; logScale = right o \"logScale\" logScale; textPosition = right o \"textPosition\" textPosition; ticks = right o \"ticks\" (Option.map Array.ofSeq ticks); title = right o \"title\" title; allowContainerBoundaryTextCufoff = right o \"allowContainerBoundaryTextCufoff\" allowContainerBoundaryTextCufoff; slantedText = right o \"slantedText\" slantedText; slantedTextAngle = right o \"slantedTextAngle\" slantedTextAngle; maxAlternation = right o \"maxAlternation\" maxAlternation; maxTextLines = right o \"maxTextLines\" maxTextLines; minTextSpacing = right o \"minTextSpacing\" minTextSpacing; showTextEvery = right o \"showTextEvery\" showTextEvery; maxValue = right o \"maxValue\" maxValue; minValue = right o \"minValue\" minValue; viewWindowMode = right o \"viewWindowMode\" viewWindowMode; gridlines = copy o \"gridlines\"; minorGridlines = copy o \"minorGridlines\"; textStyle = copy o \"textStyle\"; titleTextStyle = copy o \"titleTextStyle\"; viewWindow = copy o \"viewWindow\" }\n    { x with options = { x.options with hAxis = newNested } }\n  member x.legend(?alignment:string,?maxLines:float,?position:string,?numberFormat:string) =\n    let o = x.options.legend\n    let newNested = { ChartLegend.alignment = right o \"alignment\" alignment; maxLines = right o \"maxLines\" maxLines; position = right o \"position\" position; numberFormat = right o \"numberFormat\" numberFormat; textStyle = copy o \"textStyle\" }\n    { x with options = { x.options with legend = newNested } }\n  member x.titleTextStyle(?fontName:string,?fontSize:float,?bold:bool,?italic:bool,?color:string,?auraColor:string,?opacity:float) =\n    let o = x.options.titleTextStyle\n    let newNested = { ChartTextStyle.fontName = right o \"fontName\" fontName; fontSize = right o \"fontSize\" fontSize; bold = right o \"bold\" bold; italic = right o \"italic\" italic; color = right o \"color\" color; auraColor = right o \"auraColor\" auraColor; opacity = right o \"opacity\" opacity;  }\n    { x with options = { x.options with titleTextStyle = newNested } }\n  member x.tooltip(?isHtml:bool,?showColorCode:bool,?trigger:string) =\n    let o = x.options.tooltip\n    let newNested = { ChartTooltip.isHtml = right o \"isHtml\" isHtml; showColorCode = right o \"showColorCode\" showColorCode; trigger = right o \"trigger\" trigger; textStyle = copy o \"textStyle\" }\n    { x with options = { x.options with tooltip = newNested } }\n  member x.vAxis(?baseline:float,?baselineColor:string,?direction:float,?format:string,?logScale:bool,?textPosition:string,?ticks:seq<obj>,?title:string,?allowContainerBoundaryTextCufoff:bool,?slantedText:bool,?slantedTextAngle:float,?maxAlternation:float,?maxTextLines:float,?minTextSpacing:float,?showTextEvery:float,?maxValue:float,?minValue:float,?viewWindowMode:string) =\n    let o = x.options.vAxis\n    let newNested = { ChartAxis.baseline = right o \"baseline\" baseline; baselineColor = right o \"baselineColor\" baselineColor; direction = right o \"direction\" direction; format = right o \"format\" format; logScale = right o \"logScale\" logScale; textPosition = right o \"textPosition\" textPosition; ticks = right o \"ticks\" (Option.map Array.ofSeq ticks); title = right o \"title\" title; allowContainerBoundaryTextCufoff = right o \"allowContainerBoundaryTextCufoff\" allowContainerBoundaryTextCufoff; slantedText = right o \"slantedText\" slantedText; slantedTextAngle = right o \"slantedTextAngle\" slantedTextAngle; maxAlternation = right o \"maxAlternation\" maxAlternation; maxTextLines = right o \"maxTextLines\" maxTextLines; minTextSpacing = right o \"minTextSpacing\" minTextSpacing; showTextEvery = right o \"showTextEvery\" showTextEvery; maxValue = right o \"maxValue\" maxValue; minValue = right o \"minValue\" minValue; viewWindowMode = right o \"viewWindowMode\" viewWindowMode; gridlines = copy o \"gridlines\"; minorGridlines = copy o \"minorGridlines\"; textStyle = copy o \"textStyle\"; titleTextStyle = copy o \"titleTextStyle\"; viewWindow = copy o \"viewWindow\" }\n    { x with options = { x.options with vAxis = newNested } }\ntype Line = \n  { data : ChartData; typeName : string; \n    options : LineChartOptions }\n  interface Chart\n  member x.show(outputId) = Helpers.showChart x outputId\n  member x.set(?aggregationTarget:string,?axisTitlesPosition:string,?backgroundColor:obj,?colors:seq<string>,?curveType:string,?dataOpacity:float,?enableInteractivity:bool,?focusTarget:string,?fontSize:float,?fontName:string,?height:float,?interpolateNulls:bool,?lineWidth:float,?orientation:string,?pointSize:float,?reverseCategories:bool,?selectionMode:string,?series:obj,?theme:string,?title:string,?titlePosition:string,?vAxes:obj,?width:float) = \n    let o = x.options\n    let newOptions = { x.options with aggregationTarget = right o \"aggregationTarget\" aggregationTarget; axisTitlesPosition = right o \"axisTitlesPosition\" axisTitlesPosition; backgroundColor = right o \"backgroundColor\" backgroundColor; colors = right o \"colors\" (Option.map Array.ofSeq colors); curveType = right o \"curveType\" curveType; dataOpacity = right o \"dataOpacity\" dataOpacity; enableInteractivity = right o \"enableInteractivity\" enableInteractivity; focusTarget = right o \"focusTarget\" focusTarget; fontSize = right o \"fontSize\" fontSize; fontName = right o \"fontName\" fontName; height = right o \"height\" height; interpolateNulls = right o \"interpolateNulls\" interpolateNulls; lineWidth = right o \"lineWidth\" lineWidth; orientation = right o \"orientation\" orientation; pointSize = right o \"pointSize\" pointSize; reverseCategories = right o \"reverseCategories\" reverseCategories; selectionMode = right o \"selectionMode\" selectionMode; series = right o \"series\" series; theme = right o \"theme\" theme; title = right o \"title\" title; titlePosition = right o \"titlePosition\" titlePosition; vAxes = right o \"vAxes\" vAxes; width = right o \"width\" width }\n    { x with options = newOptions }\n  member x.animation(?duration:float,?easing:string) =\n    let o = x.options.animation\n    let newNested = { TransitionAnimation.duration = right o \"duration\" duration; easing = right o \"easing\" easing;  }\n    { x with options = { x.options with animation = newNested } }\n  member x.chartArea(?top:obj,?left:obj,?width:obj,?height:obj) =\n    let o = x.options.chartArea\n    let newNested = { ChartArea.top = right o \"top\" top; left = right o \"left\" left; width = right o \"width\" width; height = right o \"height\" height;  }\n    { x with options = { x.options with chartArea = newNested } }\n  member x.crosshair(?color:string,?opacity:float,?orientation:string,?trigger:string) =\n    let o = x.options.crosshair\n    let newNested = { ChartCrosshair.color = right o \"color\" color; opacity = right o \"opacity\" opacity; orientation = right o \"orientation\" orientation; trigger = right o \"trigger\" trigger; focused = copy o \"focused\"; selected = copy o \"selected\" }\n    { x with options = { x.options with crosshair = newNested } }\n  member x.explorer(?actions:seq<string>,?axis:string,?keepInBounds:bool,?maxZoomIn:float,?maxZoomOut:float,?zoomDelta:float) =\n    let o = x.options.explorer\n    let newNested = { ChartExplorer.actions = right o \"actions\" (Option.map Array.ofSeq actions); axis = right o \"axis\" axis; keepInBounds = right o \"keepInBounds\" keepInBounds; maxZoomIn = right o \"maxZoomIn\" maxZoomIn; maxZoomOut = right o \"maxZoomOut\" maxZoomOut; zoomDelta = right o \"zoomDelta\" zoomDelta;  }\n    { x with options = { x.options with explorer = newNested } }\n  member x.hAxis(?baseline:float,?baselineColor:string,?direction:float,?format:string,?logScale:bool,?textPosition:string,?ticks:seq<obj>,?title:string,?allowContainerBoundaryTextCufoff:bool,?slantedText:bool,?slantedTextAngle:float,?maxAlternation:float,?maxTextLines:float,?minTextSpacing:float,?showTextEvery:float,?maxValue:float,?minValue:float,?viewWindowMode:string) =\n    let o = x.options.hAxis\n    let newNested = { ChartAxis.baseline = right o \"baseline\" baseline; baselineColor = right o \"baselineColor\" baselineColor; direction = right o \"direction\" direction; format = right o \"format\" format; logScale = right o \"logScale\" logScale; textPosition = right o \"textPosition\" textPosition; ticks = right o \"ticks\" (Option.map Array.ofSeq ticks); title = right o \"title\" title; allowContainerBoundaryTextCufoff = right o \"allowContainerBoundaryTextCufoff\" allowContainerBoundaryTextCufoff; slantedText = right o \"slantedText\" slantedText; slantedTextAngle = right o \"slantedTextAngle\" slantedTextAngle; maxAlternation = right o \"maxAlternation\" maxAlternation; maxTextLines = right o \"maxTextLines\" maxTextLines; minTextSpacing = right o \"minTextSpacing\" minTextSpacing; showTextEvery = right o \"showTextEvery\" showTextEvery; maxValue = right o \"maxValue\" maxValue; minValue = right o \"minValue\" minValue; viewWindowMode = right o \"viewWindowMode\" viewWindowMode; gridlines = copy o \"gridlines\"; minorGridlines = copy o \"minorGridlines\"; textStyle = copy o \"textStyle\"; titleTextStyle = copy o \"titleTextStyle\"; viewWindow = copy o \"viewWindow\" }\n    { x with options = { x.options with hAxis = newNested } }\n  member x.legend(?alignment:string,?maxLines:float,?position:string,?numberFormat:string) =\n    let o = x.options.legend\n    let newNested = { ChartLegend.alignment = right o \"alignment\" alignment; maxLines = right o \"maxLines\" maxLines; position = right o \"position\" position; numberFormat = right o \"numberFormat\" numberFormat; textStyle = copy o \"textStyle\" }\n    { x with options = { x.options with legend = newNested } }\n  member x.titleTextStyle(?fontName:string,?fontSize:float,?bold:bool,?italic:bool,?color:string,?auraColor:string,?opacity:float) =\n    let o = x.options.titleTextStyle\n    let newNested = { ChartTextStyle.fontName = right o \"fontName\" fontName; fontSize = right o \"fontSize\" fontSize; bold = right o \"bold\" bold; italic = right o \"italic\" italic; color = right o \"color\" color; auraColor = right o \"auraColor\" auraColor; opacity = right o \"opacity\" opacity;  }\n    { x with options = { x.options with titleTextStyle = newNested } }\n  member x.tooltip(?isHtml:bool,?showColorCode:bool,?trigger:string) =\n    let o = x.options.tooltip\n    let newNested = { ChartTooltip.isHtml = right o \"isHtml\" isHtml; showColorCode = right o \"showColorCode\" showColorCode; trigger = right o \"trigger\" trigger; textStyle = copy o \"textStyle\" }\n    { x with options = { x.options with tooltip = newNested } }\n  member x.vAxis(?baseline:float,?baselineColor:string,?direction:float,?format:string,?logScale:bool,?textPosition:string,?ticks:seq<obj>,?title:string,?allowContainerBoundaryTextCufoff:bool,?slantedText:bool,?slantedTextAngle:float,?maxAlternation:float,?maxTextLines:float,?minTextSpacing:float,?showTextEvery:float,?maxValue:float,?minValue:float,?viewWindowMode:string) =\n    let o = x.options.vAxis\n    let newNested = { ChartAxis.baseline = right o \"baseline\" baseline; baselineColor = right o \"baselineColor\" baselineColor; direction = right o \"direction\" direction; format = right o \"format\" format; logScale = right o \"logScale\" logScale; textPosition = right o \"textPosition\" textPosition; ticks = right o \"ticks\" (Option.map Array.ofSeq ticks); title = right o \"title\" title; allowContainerBoundaryTextCufoff = right o \"allowContainerBoundaryTextCufoff\" allowContainerBoundaryTextCufoff; slantedText = right o \"slantedText\" slantedText; slantedTextAngle = right o \"slantedTextAngle\" slantedTextAngle; maxAlternation = right o \"maxAlternation\" maxAlternation; maxTextLines = right o \"maxTextLines\" maxTextLines; minTextSpacing = right o \"minTextSpacing\" minTextSpacing; showTextEvery = right o \"showTextEvery\" showTextEvery; maxValue = right o \"maxValue\" maxValue; minValue = right o \"minValue\" minValue; viewWindowMode = right o \"viewWindowMode\" viewWindowMode; gridlines = copy o \"gridlines\"; minorGridlines = copy o \"minorGridlines\"; textStyle = copy o \"textStyle\"; titleTextStyle = copy o \"titleTextStyle\"; viewWindow = copy o \"viewWindow\" }\n    { x with options = { x.options with vAxis = newNested } }\ntype Bar = \n  { data : ChartData; typeName : string; \n    options : BarChartOptions }\n  interface Chart\n  member x.show(outputId) = Helpers.showChart x outputId\n  member x.set(?aggregationTarget:string,?axisTitlesPosition:string,?backgroundColor:obj,?colors:seq<string>,?dataOpacity:float,?enableInteractivity:bool,?focusTarget:string,?fontSize:float,?fontName:string,?hAxes:obj,?height:float,?isStacked:bool,?reverseCategories:bool,?series:obj,?theme:string,?title:string,?titlePosition:string,?vAxes:obj,?width:float) = \n    let o = x.options\n    let newOptions = { x.options with aggregationTarget = right o \"aggregationTarget\" aggregationTarget; axisTitlesPosition = right o \"axisTitlesPosition\" axisTitlesPosition; backgroundColor = right o \"backgroundColor\" backgroundColor; colors = right o \"colors\" (Option.map Array.ofSeq colors); dataOpacity = right o \"dataOpacity\" dataOpacity; enableInteractivity = right o \"enableInteractivity\" enableInteractivity; focusTarget = right o \"focusTarget\" focusTarget; fontSize = right o \"fontSize\" fontSize; fontName = right o \"fontName\" fontName; hAxes = right o \"hAxes\" hAxes; height = right o \"height\" height; isStacked = right o \"isStacked\" isStacked; reverseCategories = right o \"reverseCategories\" reverseCategories; series = right o \"series\" series; theme = right o \"theme\" theme; title = right o \"title\" title; titlePosition = right o \"titlePosition\" titlePosition; vAxes = right o \"vAxes\" vAxes; width = right o \"width\" width }\n    { x with options = newOptions }\n  member x.animation(?duration:float,?easing:string) =\n    let o = x.options.animation\n    let newNested = { TransitionAnimation.duration = right o \"duration\" duration; easing = right o \"easing\" easing;  }\n    { x with options = { x.options with animation = newNested } }\n  member x.bar(?groupWidth:obj) =\n    let o = x.options.bar\n    let newNested = { GroupWidth.groupWidth = right o \"groupWidth\" groupWidth;  }\n    { x with options = { x.options with bar = newNested } }\n  member x.chartArea(?top:obj,?left:obj,?width:obj,?height:obj) =\n    let o = x.options.chartArea\n    let newNested = { ChartArea.top = right o \"top\" top; left = right o \"left\" left; width = right o \"width\" width; height = right o \"height\" height;  }\n    { x with options = { x.options with chartArea = newNested } }\n  member x.hAxis(?baseline:float,?baselineColor:string,?direction:float,?format:string,?logScale:bool,?textPosition:string,?ticks:seq<obj>,?title:string,?allowContainerBoundaryTextCufoff:bool,?slantedText:bool,?slantedTextAngle:float,?maxAlternation:float,?maxTextLines:float,?minTextSpacing:float,?showTextEvery:float,?maxValue:float,?minValue:float,?viewWindowMode:string) =\n    let o = x.options.hAxis\n    let newNested = { ChartAxis.baseline = right o \"baseline\" baseline; baselineColor = right o \"baselineColor\" baselineColor; direction = right o \"direction\" direction; format = right o \"format\" format; logScale = right o \"logScale\" logScale; textPosition = right o \"textPosition\" textPosition; ticks = right o \"ticks\" (Option.map Array.ofSeq ticks); title = right o \"title\" title; allowContainerBoundaryTextCufoff = right o \"allowContainerBoundaryTextCufoff\" allowContainerBoundaryTextCufoff; slantedText = right o \"slantedText\" slantedText; slantedTextAngle = right o \"slantedTextAngle\" slantedTextAngle; maxAlternation = right o \"maxAlternation\" maxAlternation; maxTextLines = right o \"maxTextLines\" maxTextLines; minTextSpacing = right o \"minTextSpacing\" minTextSpacing; showTextEvery = right o \"showTextEvery\" showTextEvery; maxValue = right o \"maxValue\" maxValue; minValue = right o \"minValue\" minValue; viewWindowMode = right o \"viewWindowMode\" viewWindowMode; gridlines = copy o \"gridlines\"; minorGridlines = copy o \"minorGridlines\"; textStyle = copy o \"textStyle\"; titleTextStyle = copy o \"titleTextStyle\"; viewWindow = copy o \"viewWindow\" }\n    { x with options = { x.options with hAxis = newNested } }\n  member x.legend(?alignment:string,?maxLines:float,?position:string,?numberFormat:string) =\n    let o = x.options.legend\n    let newNested = { ChartLegend.alignment = right o \"alignment\" alignment; maxLines = right o \"maxLines\" maxLines; position = right o \"position\" position; numberFormat = right o \"numberFormat\" numberFormat; textStyle = copy o \"textStyle\" }\n    { x with options = { x.options with legend = newNested } }\n  member x.titleTextStyle(?fontName:string,?fontSize:float,?bold:bool,?italic:bool,?color:string,?auraColor:string,?opacity:float) =\n    let o = x.options.titleTextStyle\n    let newNested = { ChartTextStyle.fontName = right o \"fontName\" fontName; fontSize = right o \"fontSize\" fontSize; bold = right o \"bold\" bold; italic = right o \"italic\" italic; color = right o \"color\" color; auraColor = right o \"auraColor\" auraColor; opacity = right o \"opacity\" opacity;  }\n    { x with options = { x.options with titleTextStyle = newNested } }\n  member x.tooltip(?isHtml:bool,?showColorCode:bool,?trigger:string) =\n    let o = x.options.tooltip\n    let newNested = { ChartTooltip.isHtml = right o \"isHtml\" isHtml; showColorCode = right o \"showColorCode\" showColorCode; trigger = right o \"trigger\" trigger; textStyle = copy o \"textStyle\" }\n    { x with options = { x.options with tooltip = newNested } }\n  member x.vAxis(?baseline:float,?baselineColor:string,?direction:float,?format:string,?logScale:bool,?textPosition:string,?ticks:seq<obj>,?title:string,?allowContainerBoundaryTextCufoff:bool,?slantedText:bool,?slantedTextAngle:float,?maxAlternation:float,?maxTextLines:float,?minTextSpacing:float,?showTextEvery:float,?maxValue:float,?minValue:float,?viewWindowMode:string) =\n    let o = x.options.vAxis\n    let newNested = { ChartAxis.baseline = right o \"baseline\" baseline; baselineColor = right o \"baselineColor\" baselineColor; direction = right o \"direction\" direction; format = right o \"format\" format; logScale = right o \"logScale\" logScale; textPosition = right o \"textPosition\" textPosition; ticks = right o \"ticks\" (Option.map Array.ofSeq ticks); title = right o \"title\" title; allowContainerBoundaryTextCufoff = right o \"allowContainerBoundaryTextCufoff\" allowContainerBoundaryTextCufoff; slantedText = right o \"slantedText\" slantedText; slantedTextAngle = right o \"slantedTextAngle\" slantedTextAngle; maxAlternation = right o \"maxAlternation\" maxAlternation; maxTextLines = right o \"maxTextLines\" maxTextLines; minTextSpacing = right o \"minTextSpacing\" minTextSpacing; showTextEvery = right o \"showTextEvery\" showTextEvery; maxValue = right o \"maxValue\" maxValue; minValue = right o \"minValue\" minValue; viewWindowMode = right o \"viewWindowMode\" viewWindowMode; gridlines = copy o \"gridlines\"; minorGridlines = copy o \"minorGridlines\"; textStyle = copy o \"textStyle\"; titleTextStyle = copy o \"titleTextStyle\"; viewWindow = copy o \"viewWindow\" }\n    { x with options = { x.options with vAxis = newNested } }\ntype Histogram = \n  { data : ChartData; typeName : string; \n    options : HistogramOptions }\n  interface Chart\n  member x.show(outputId) = Helpers.showChart x outputId\n  member x.set(?axisTitlesPosition:string,?backgroundColor:obj,?colors:seq<string>,?dataOpacity:float,?enableInteractivity:bool,?focusTarget:string,?fontSize:float,?fontName:string,?height:float,?interpolateNulls:bool,?isStacked:bool,?orientation:string,?reverseCategories:bool,?series:obj,?theme:string,?title:string,?titlePosition:string,?vAxes:obj,?width:float) = \n    let o = x.options\n    let newOptions = { x.options with axisTitlesPosition = right o \"axisTitlesPosition\" axisTitlesPosition; backgroundColor = right o \"backgroundColor\" backgroundColor; colors = right o \"colors\" (Option.map Array.ofSeq colors); dataOpacity = right o \"dataOpacity\" dataOpacity; enableInteractivity = right o \"enableInteractivity\" enableInteractivity; focusTarget = right o \"focusTarget\" focusTarget; fontSize = right o \"fontSize\" fontSize; fontName = right o \"fontName\" fontName; height = right o \"height\" height; interpolateNulls = right o \"interpolateNulls\" interpolateNulls; isStacked = right o \"isStacked\" isStacked; orientation = right o \"orientation\" orientation; reverseCategories = right o \"reverseCategories\" reverseCategories; series = right o \"series\" series; theme = right o \"theme\" theme; title = right o \"title\" title; titlePosition = right o \"titlePosition\" titlePosition; vAxes = right o \"vAxes\" vAxes; width = right o \"width\" width }\n    { x with options = newOptions }\n  member x.animation(?duration:float,?easing:string) =\n    let o = x.options.animation\n    let newNested = { TransitionAnimation.duration = right o \"duration\" duration; easing = right o \"easing\" easing;  }\n    { x with options = { x.options with animation = newNested } }\n  member x.bar(?groupWidth:obj) =\n    let o = x.options.bar\n    let newNested = { GroupWidth.groupWidth = right o \"groupWidth\" groupWidth;  }\n    { x with options = { x.options with bar = newNested } }\n  member x.chartArea(?top:obj,?left:obj,?width:obj,?height:obj) =\n    let o = x.options.chartArea\n    let newNested = { ChartArea.top = right o \"top\" top; left = right o \"left\" left; width = right o \"width\" width; height = right o \"height\" height;  }\n    { x with options = { x.options with chartArea = newNested } }\n  member x.hAxis(?baseline:float,?baselineColor:string,?direction:float,?format:string,?logScale:bool,?textPosition:string,?ticks:seq<obj>,?title:string,?allowContainerBoundaryTextCufoff:bool,?slantedText:bool,?slantedTextAngle:float,?maxAlternation:float,?maxTextLines:float,?minTextSpacing:float,?showTextEvery:float,?maxValue:float,?minValue:float,?viewWindowMode:string) =\n    let o = x.options.hAxis\n    let newNested = { ChartAxis.baseline = right o \"baseline\" baseline; baselineColor = right o \"baselineColor\" baselineColor; direction = right o \"direction\" direction; format = right o \"format\" format; logScale = right o \"logScale\" logScale; textPosition = right o \"textPosition\" textPosition; ticks = right o \"ticks\" (Option.map Array.ofSeq ticks); title = right o \"title\" title; allowContainerBoundaryTextCufoff = right o \"allowContainerBoundaryTextCufoff\" allowContainerBoundaryTextCufoff; slantedText = right o \"slantedText\" slantedText; slantedTextAngle = right o \"slantedTextAngle\" slantedTextAngle; maxAlternation = right o \"maxAlternation\" maxAlternation; maxTextLines = right o \"maxTextLines\" maxTextLines; minTextSpacing = right o \"minTextSpacing\" minTextSpacing; showTextEvery = right o \"showTextEvery\" showTextEvery; maxValue = right o \"maxValue\" maxValue; minValue = right o \"minValue\" minValue; viewWindowMode = right o \"viewWindowMode\" viewWindowMode; gridlines = copy o \"gridlines\"; minorGridlines = copy o \"minorGridlines\"; textStyle = copy o \"textStyle\"; titleTextStyle = copy o \"titleTextStyle\"; viewWindow = copy o \"viewWindow\" }\n    { x with options = { x.options with hAxis = newNested } }\n  member x.histogram(?bucketSize:float,?hideBucketItems:bool,?lastBucketPercentile:float) =\n    let o = x.options.histogram\n    let newNested = { HistogramHistogram.bucketSize = right o \"bucketSize\" bucketSize; hideBucketItems = right o \"hideBucketItems\" hideBucketItems; lastBucketPercentile = right o \"lastBucketPercentile\" lastBucketPercentile;  }\n    { x with options = { x.options with histogram = newNested } }\n  member x.legend(?alignment:string,?maxLines:float,?position:string,?numberFormat:string) =\n    let o = x.options.legend\n    let newNested = { ChartLegend.alignment = right o \"alignment\" alignment; maxLines = right o \"maxLines\" maxLines; position = right o \"position\" position; numberFormat = right o \"numberFormat\" numberFormat; textStyle = copy o \"textStyle\" }\n    { x with options = { x.options with legend = newNested } }\n  member x.titleTextStyle(?fontName:string,?fontSize:float,?bold:bool,?italic:bool,?color:string,?auraColor:string,?opacity:float) =\n    let o = x.options.titleTextStyle\n    let newNested = { ChartTextStyle.fontName = right o \"fontName\" fontName; fontSize = right o \"fontSize\" fontSize; bold = right o \"bold\" bold; italic = right o \"italic\" italic; color = right o \"color\" color; auraColor = right o \"auraColor\" auraColor; opacity = right o \"opacity\" opacity;  }\n    { x with options = { x.options with titleTextStyle = newNested } }\n  member x.tooltip(?isHtml:bool,?showColorCode:bool,?trigger:string) =\n    let o = x.options.tooltip\n    let newNested = { ChartTooltip.isHtml = right o \"isHtml\" isHtml; showColorCode = right o \"showColorCode\" showColorCode; trigger = right o \"trigger\" trigger; textStyle = copy o \"textStyle\" }\n    { x with options = { x.options with tooltip = newNested } }\n  member x.vAxis(?baseline:float,?baselineColor:string,?direction:float,?format:string,?logScale:bool,?textPosition:string,?ticks:seq<obj>,?title:string,?allowContainerBoundaryTextCufoff:bool,?slantedText:bool,?slantedTextAngle:float,?maxAlternation:float,?maxTextLines:float,?minTextSpacing:float,?showTextEvery:float,?maxValue:float,?minValue:float,?viewWindowMode:string) =\n    let o = x.options.vAxis\n    let newNested = { ChartAxis.baseline = right o \"baseline\" baseline; baselineColor = right o \"baselineColor\" baselineColor; direction = right o \"direction\" direction; format = right o \"format\" format; logScale = right o \"logScale\" logScale; textPosition = right o \"textPosition\" textPosition; ticks = right o \"ticks\" (Option.map Array.ofSeq ticks); title = right o \"title\" title; allowContainerBoundaryTextCufoff = right o \"allowContainerBoundaryTextCufoff\" allowContainerBoundaryTextCufoff; slantedText = right o \"slantedText\" slantedText; slantedTextAngle = right o \"slantedTextAngle\" slantedTextAngle; maxAlternation = right o \"maxAlternation\" maxAlternation; maxTextLines = right o \"maxTextLines\" maxTextLines; minTextSpacing = right o \"minTextSpacing\" minTextSpacing; showTextEvery = right o \"showTextEvery\" showTextEvery; maxValue = right o \"maxValue\" maxValue; minValue = right o \"minValue\" minValue; viewWindowMode = right o \"viewWindowMode\" viewWindowMode; gridlines = copy o \"gridlines\"; minorGridlines = copy o \"minorGridlines\"; textStyle = copy o \"textStyle\"; titleTextStyle = copy o \"titleTextStyle\"; viewWindow = copy o \"viewWindow\" }\n    { x with options = { x.options with vAxis = newNested } }\ntype Area = \n  { data : ChartData; typeName : string; \n    options : AreaChartOptions }\n  interface Chart\n  member x.show(outputId) = Helpers.showChart x outputId\n  member x.set(?aggregationTarget:string,?areaOpacity:float,?axisTitlesPosition:string,?backgroundColor:obj,?colors:seq<string>,?dataOpacity:float,?enableInteractivity:bool,?focusTarget:string,?fontSize:float,?fontName:string,?height:float,?interpolateNulls:bool,?isStacked:bool,?lineWidth:float,?orientation:string,?pointSize:float,?reverseCategories:bool,?selectionMode:string,?series:obj,?theme:string,?title:string,?titlePosition:string,?vAxes:obj,?width:float) = \n    let o = x.options\n    let newOptions = { x.options with aggregationTarget = right o \"aggregationTarget\" aggregationTarget; areaOpacity = right o \"areaOpacity\" areaOpacity; axisTitlesPosition = right o \"axisTitlesPosition\" axisTitlesPosition; backgroundColor = right o \"backgroundColor\" backgroundColor; colors = right o \"colors\" (Option.map Array.ofSeq colors); dataOpacity = right o \"dataOpacity\" dataOpacity; enableInteractivity = right o \"enableInteractivity\" enableInteractivity; focusTarget = right o \"focusTarget\" focusTarget; fontSize = right o \"fontSize\" fontSize; fontName = right o \"fontName\" fontName; height = right o \"height\" height; interpolateNulls = right o \"interpolateNulls\" interpolateNulls; isStacked = right o \"isStacked\" isStacked; lineWidth = right o \"lineWidth\" lineWidth; orientation = right o \"orientation\" orientation; pointSize = right o \"pointSize\" pointSize; reverseCategories = right o \"reverseCategories\" reverseCategories; selectionMode = right o \"selectionMode\" selectionMode; series = right o \"series\" series; theme = right o \"theme\" theme; title = right o \"title\" title; titlePosition = right o \"titlePosition\" titlePosition; vAxes = right o \"vAxes\" vAxes; width = right o \"width\" width }\n    { x with options = newOptions }\n  member x.animation(?duration:float,?easing:string) =\n    let o = x.options.animation\n    let newNested = { TransitionAnimation.duration = right o \"duration\" duration; easing = right o \"easing\" easing;  }\n    { x with options = { x.options with animation = newNested } }\n  member x.chartArea(?top:obj,?left:obj,?width:obj,?height:obj) =\n    let o = x.options.chartArea\n    let newNested = { ChartArea.top = right o \"top\" top; left = right o \"left\" left; width = right o \"width\" width; height = right o \"height\" height;  }\n    { x with options = { x.options with chartArea = newNested } }\n  member x.crosshair(?color:string,?opacity:float,?orientation:string,?trigger:string) =\n    let o = x.options.crosshair\n    let newNested = { ChartCrosshair.color = right o \"color\" color; opacity = right o \"opacity\" opacity; orientation = right o \"orientation\" orientation; trigger = right o \"trigger\" trigger; focused = copy o \"focused\"; selected = copy o \"selected\" }\n    { x with options = { x.options with crosshair = newNested } }\n  member x.explorer(?actions:seq<string>,?axis:string,?keepInBounds:bool,?maxZoomIn:float,?maxZoomOut:float,?zoomDelta:float) =\n    let o = x.options.explorer\n    let newNested = { ChartExplorer.actions = right o \"actions\" (Option.map Array.ofSeq actions); axis = right o \"axis\" axis; keepInBounds = right o \"keepInBounds\" keepInBounds; maxZoomIn = right o \"maxZoomIn\" maxZoomIn; maxZoomOut = right o \"maxZoomOut\" maxZoomOut; zoomDelta = right o \"zoomDelta\" zoomDelta;  }\n    { x with options = { x.options with explorer = newNested } }\n  member x.hAxis(?baseline:float,?baselineColor:string,?direction:float,?format:string,?logScale:bool,?textPosition:string,?ticks:seq<obj>,?title:string,?allowContainerBoundaryTextCufoff:bool,?slantedText:bool,?slantedTextAngle:float,?maxAlternation:float,?maxTextLines:float,?minTextSpacing:float,?showTextEvery:float,?maxValue:float,?minValue:float,?viewWindowMode:string) =\n    let o = x.options.hAxis\n    let newNested = { ChartAxis.baseline = right o \"baseline\" baseline; baselineColor = right o \"baselineColor\" baselineColor; direction = right o \"direction\" direction; format = right o \"format\" format; logScale = right o \"logScale\" logScale; textPosition = right o \"textPosition\" textPosition; ticks = right o \"ticks\" (Option.map Array.ofSeq ticks); title = right o \"title\" title; allowContainerBoundaryTextCufoff = right o \"allowContainerBoundaryTextCufoff\" allowContainerBoundaryTextCufoff; slantedText = right o \"slantedText\" slantedText; slantedTextAngle = right o \"slantedTextAngle\" slantedTextAngle; maxAlternation = right o \"maxAlternation\" maxAlternation; maxTextLines = right o \"maxTextLines\" maxTextLines; minTextSpacing = right o \"minTextSpacing\" minTextSpacing; showTextEvery = right o \"showTextEvery\" showTextEvery; maxValue = right o \"maxValue\" maxValue; minValue = right o \"minValue\" minValue; viewWindowMode = right o \"viewWindowMode\" viewWindowMode; gridlines = copy o \"gridlines\"; minorGridlines = copy o \"minorGridlines\"; textStyle = copy o \"textStyle\"; titleTextStyle = copy o \"titleTextStyle\"; viewWindow = copy o \"viewWindow\" }\n    { x with options = { x.options with hAxis = newNested } }\n  member x.legend(?alignment:string,?maxLines:float,?position:string,?numberFormat:string) =\n    let o = x.options.legend\n    let newNested = { ChartLegend.alignment = right o \"alignment\" alignment; maxLines = right o \"maxLines\" maxLines; position = right o \"position\" position; numberFormat = right o \"numberFormat\" numberFormat; textStyle = copy o \"textStyle\" }\n    { x with options = { x.options with legend = newNested } }\n  member x.titleTextStyle(?fontName:string,?fontSize:float,?bold:bool,?italic:bool,?color:string,?auraColor:string,?opacity:float) =\n    let o = x.options.titleTextStyle\n    let newNested = { ChartTextStyle.fontName = right o \"fontName\" fontName; fontSize = right o \"fontSize\" fontSize; bold = right o \"bold\" bold; italic = right o \"italic\" italic; color = right o \"color\" color; auraColor = right o \"auraColor\" auraColor; opacity = right o \"opacity\" opacity;  }\n    { x with options = { x.options with titleTextStyle = newNested } }\n  member x.tooltip(?isHtml:bool,?showColorCode:bool,?trigger:string) =\n    let o = x.options.tooltip\n    let newNested = { ChartTooltip.isHtml = right o \"isHtml\" isHtml; showColorCode = right o \"showColorCode\" showColorCode; trigger = right o \"trigger\" trigger; textStyle = copy o \"textStyle\" }\n    { x with options = { x.options with tooltip = newNested } }\n  member x.vAxis(?baseline:float,?baselineColor:string,?direction:float,?format:string,?logScale:bool,?textPosition:string,?ticks:seq<obj>,?title:string,?allowContainerBoundaryTextCufoff:bool,?slantedText:bool,?slantedTextAngle:float,?maxAlternation:float,?maxTextLines:float,?minTextSpacing:float,?showTextEvery:float,?maxValue:float,?minValue:float,?viewWindowMode:string) =\n    let o = x.options.vAxis\n    let newNested = { ChartAxis.baseline = right o \"baseline\" baseline; baselineColor = right o \"baselineColor\" baselineColor; direction = right o \"direction\" direction; format = right o \"format\" format; logScale = right o \"logScale\" logScale; textPosition = right o \"textPosition\" textPosition; ticks = right o \"ticks\" (Option.map Array.ofSeq ticks); title = right o \"title\" title; allowContainerBoundaryTextCufoff = right o \"allowContainerBoundaryTextCufoff\" allowContainerBoundaryTextCufoff; slantedText = right o \"slantedText\" slantedText; slantedTextAngle = right o \"slantedTextAngle\" slantedTextAngle; maxAlternation = right o \"maxAlternation\" maxAlternation; maxTextLines = right o \"maxTextLines\" maxTextLines; minTextSpacing = right o \"minTextSpacing\" minTextSpacing; showTextEvery = right o \"showTextEvery\" showTextEvery; maxValue = right o \"maxValue\" maxValue; minValue = right o \"minValue\" minValue; viewWindowMode = right o \"viewWindowMode\" viewWindowMode; gridlines = copy o \"gridlines\"; minorGridlines = copy o \"minorGridlines\"; textStyle = copy o \"textStyle\"; titleTextStyle = copy o \"titleTextStyle\"; viewWindow = copy o \"viewWindow\" }\n    { x with options = { x.options with vAxis = newNested } }\ntype Annotation = \n  { data : ChartData; typeName : string; \n    options : AnnotationChartOptions }\n  interface Chart\n  member x.show(outputId) = Helpers.showChart x outputId\n  member x.set(?allowHtml:bool,?allValuesSuffix:string,?annotationsWidth:float,?colors:seq<string>,?dateFormat:string,?displayAnnotations:bool,?displayAnnotationsFilter:bool,?displayDateTimeBarSeparator:bool,?displayExactValues:bool,?displayLegendDots:bool,?displayLegendValues:bool,?displayRangeSelector:bool,?displayZoomButtons:bool,?fill:float,?legendPosition:string,?max:float,?min:float,?numberFormats:obj,?scaleColumns:seq<float>,?scaleFormat:string,?scaleType:string,?thickness:float,?zoomEndTime:DateTime,?zoomStartTime:DateTime) = \n    let o = x.options\n    let newOptions = { x.options with allowHtml = right o \"allowHtml\" allowHtml; allValuesSuffix = right o \"allValuesSuffix\" allValuesSuffix; annotationsWidth = right o \"annotationsWidth\" annotationsWidth; colors = right o \"colors\" (Option.map Array.ofSeq colors); dateFormat = right o \"dateFormat\" dateFormat; displayAnnotations = right o \"displayAnnotations\" displayAnnotations; displayAnnotationsFilter = right o \"displayAnnotationsFilter\" displayAnnotationsFilter; displayDateTimeBarSeparator = right o \"displayDateTimeBarSeparator\" displayDateTimeBarSeparator; displayExactValues = right o \"displayExactValues\" displayExactValues; displayLegendDots = right o \"displayLegendDots\" displayLegendDots; displayLegendValues = right o \"displayLegendValues\" displayLegendValues; displayRangeSelector = right o \"displayRangeSelector\" displayRangeSelector; displayZoomButtons = right o \"displayZoomButtons\" displayZoomButtons; fill = right o \"fill\" fill; legendPosition = right o \"legendPosition\" legendPosition; max = right o \"max\" max; min = right o \"min\" min; numberFormats = right o \"numberFormats\" numberFormats; scaleColumns = right o \"scaleColumns\" (Option.map Array.ofSeq scaleColumns); scaleFormat = right o \"scaleFormat\" scaleFormat; scaleType = right o \"scaleType\" scaleType; thickness = right o \"thickness\" thickness; zoomEndTime = right o \"zoomEndTime\" zoomEndTime; zoomStartTime = right o \"zoomStartTime\" zoomStartTime }\n    { x with options = newOptions }\ntype SteppedArea = \n  { data : ChartData; typeName : string; \n    options : SteppedAreaChartOptions }\n  interface Chart\n  member x.show(outputId) = Helpers.showChart x outputId\n  member x.set(?aggregationTarget:string,?areaOpacity:float,?axisTitlesPosition:string,?backgroundColor:obj,?colors:seq<string>,?connectSteps:bool,?enableInteractivity:bool,?focusTarget:string,?fontSize:float,?fontName:string,?height:float,?interpolateNulls:bool,?isStacked:bool,?reverseCategories:bool,?selectionMode:string,?series:obj,?theme:string,?title:string,?titlePosition:string,?vAxes:obj,?width:float) = \n    let o = x.options\n    let newOptions = { x.options with aggregationTarget = right o \"aggregationTarget\" aggregationTarget; areaOpacity = right o \"areaOpacity\" areaOpacity; axisTitlesPosition = right o \"axisTitlesPosition\" axisTitlesPosition; backgroundColor = right o \"backgroundColor\" backgroundColor; colors = right o \"colors\" (Option.map Array.ofSeq colors); connectSteps = right o \"connectSteps\" connectSteps; enableInteractivity = right o \"enableInteractivity\" enableInteractivity; focusTarget = right o \"focusTarget\" focusTarget; fontSize = right o \"fontSize\" fontSize; fontName = right o \"fontName\" fontName; height = right o \"height\" height; interpolateNulls = right o \"interpolateNulls\" interpolateNulls; isStacked = right o \"isStacked\" isStacked; reverseCategories = right o \"reverseCategories\" reverseCategories; selectionMode = right o \"selectionMode\" selectionMode; series = right o \"series\" series; theme = right o \"theme\" theme; title = right o \"title\" title; titlePosition = right o \"titlePosition\" titlePosition; vAxes = right o \"vAxes\" vAxes; width = right o \"width\" width }\n    { x with options = newOptions }\n  member x.animation(?duration:float,?easing:string) =\n    let o = x.options.animation\n    let newNested = { TransitionAnimation.duration = right o \"duration\" duration; easing = right o \"easing\" easing;  }\n    { x with options = { x.options with animation = newNested } }\n  member x.chartArea(?top:obj,?left:obj,?width:obj,?height:obj) =\n    let o = x.options.chartArea\n    let newNested = { ChartArea.top = right o \"top\" top; left = right o \"left\" left; width = right o \"width\" width; height = right o \"height\" height;  }\n    { x with options = { x.options with chartArea = newNested } }\n  member x.hAxis(?baseline:float,?baselineColor:string,?direction:float,?format:string,?logScale:bool,?textPosition:string,?ticks:seq<obj>,?title:string,?allowContainerBoundaryTextCufoff:bool,?slantedText:bool,?slantedTextAngle:float,?maxAlternation:float,?maxTextLines:float,?minTextSpacing:float,?showTextEvery:float,?maxValue:float,?minValue:float,?viewWindowMode:string) =\n    let o = x.options.hAxis\n    let newNested = { ChartAxis.baseline = right o \"baseline\" baseline; baselineColor = right o \"baselineColor\" baselineColor; direction = right o \"direction\" direction; format = right o \"format\" format; logScale = right o \"logScale\" logScale; textPosition = right o \"textPosition\" textPosition; ticks = right o \"ticks\" (Option.map Array.ofSeq ticks); title = right o \"title\" title; allowContainerBoundaryTextCufoff = right o \"allowContainerBoundaryTextCufoff\" allowContainerBoundaryTextCufoff; slantedText = right o \"slantedText\" slantedText; slantedTextAngle = right o \"slantedTextAngle\" slantedTextAngle; maxAlternation = right o \"maxAlternation\" maxAlternation; maxTextLines = right o \"maxTextLines\" maxTextLines; minTextSpacing = right o \"minTextSpacing\" minTextSpacing; showTextEvery = right o \"showTextEvery\" showTextEvery; maxValue = right o \"maxValue\" maxValue; minValue = right o \"minValue\" minValue; viewWindowMode = right o \"viewWindowMode\" viewWindowMode; gridlines = copy o \"gridlines\"; minorGridlines = copy o \"minorGridlines\"; textStyle = copy o \"textStyle\"; titleTextStyle = copy o \"titleTextStyle\"; viewWindow = copy o \"viewWindow\" }\n    { x with options = { x.options with hAxis = newNested } }\n  member x.legend(?alignment:string,?maxLines:float,?position:string,?numberFormat:string) =\n    let o = x.options.legend\n    let newNested = { ChartLegend.alignment = right o \"alignment\" alignment; maxLines = right o \"maxLines\" maxLines; position = right o \"position\" position; numberFormat = right o \"numberFormat\" numberFormat; textStyle = copy o \"textStyle\" }\n    { x with options = { x.options with legend = newNested } }\n  member x.titleTextStyle(?fontName:string,?fontSize:float,?bold:bool,?italic:bool,?color:string,?auraColor:string,?opacity:float) =\n    let o = x.options.titleTextStyle\n    let newNested = { ChartTextStyle.fontName = right o \"fontName\" fontName; fontSize = right o \"fontSize\" fontSize; bold = right o \"bold\" bold; italic = right o \"italic\" italic; color = right o \"color\" color; auraColor = right o \"auraColor\" auraColor; opacity = right o \"opacity\" opacity;  }\n    { x with options = { x.options with titleTextStyle = newNested } }\n  member x.tooltip(?isHtml:bool,?showColorCode:bool,?trigger:string) =\n    let o = x.options.tooltip\n    let newNested = { ChartTooltip.isHtml = right o \"isHtml\" isHtml; showColorCode = right o \"showColorCode\" showColorCode; trigger = right o \"trigger\" trigger; textStyle = copy o \"textStyle\" }\n    { x with options = { x.options with tooltip = newNested } }\n  member x.vAxis(?baseline:float,?baselineColor:string,?direction:float,?format:string,?logScale:bool,?textPosition:string,?ticks:seq<obj>,?title:string,?allowContainerBoundaryTextCufoff:bool,?slantedText:bool,?slantedTextAngle:float,?maxAlternation:float,?maxTextLines:float,?minTextSpacing:float,?showTextEvery:float,?maxValue:float,?minValue:float,?viewWindowMode:string) =\n    let o = x.options.vAxis\n    let newNested = { ChartAxis.baseline = right o \"baseline\" baseline; baselineColor = right o \"baselineColor\" baselineColor; direction = right o \"direction\" direction; format = right o \"format\" format; logScale = right o \"logScale\" logScale; textPosition = right o \"textPosition\" textPosition; ticks = right o \"ticks\" (Option.map Array.ofSeq ticks); title = right o \"title\" title; allowContainerBoundaryTextCufoff = right o \"allowContainerBoundaryTextCufoff\" allowContainerBoundaryTextCufoff; slantedText = right o \"slantedText\" slantedText; slantedTextAngle = right o \"slantedTextAngle\" slantedTextAngle; maxAlternation = right o \"maxAlternation\" maxAlternation; maxTextLines = right o \"maxTextLines\" maxTextLines; minTextSpacing = right o \"minTextSpacing\" minTextSpacing; showTextEvery = right o \"showTextEvery\" showTextEvery; maxValue = right o \"maxValue\" maxValue; minValue = right o \"minValue\" minValue; viewWindowMode = right o \"viewWindowMode\" viewWindowMode; gridlines = copy o \"gridlines\"; minorGridlines = copy o \"minorGridlines\"; textStyle = copy o \"textStyle\"; titleTextStyle = copy o \"titleTextStyle\"; viewWindow = copy o \"viewWindow\" }\n    { x with options = { x.options with vAxis = newNested } }\ntype Pie = \n  { data : ChartData; typeName : string; \n    options : PieChartOptions }\n  interface Chart\n  member x.show(outputId) = Helpers.showChart x outputId\n  member x.set(?backgroundColor:obj,?colors:seq<string>,?enableInteractivity:bool,?fontSize:float,?fontName:string,?height:float,?is3D:bool,?pieHole:float,?pieSliceBorderColor:string,?pieSliceText:string,?pieStartAngle:float,?reverseCategories:bool,?pieResidueSliceColor:string,?pieResidueSliceLabel:string,?slices:obj,?sliceVisibilityThreshold:float,?title:string,?width:float) = \n    let o = x.options\n    let newOptions = { x.options with backgroundColor = right o \"backgroundColor\" backgroundColor; colors = right o \"colors\" (Option.map Array.ofSeq colors); enableInteractivity = right o \"enableInteractivity\" enableInteractivity; fontSize = right o \"fontSize\" fontSize; fontName = right o \"fontName\" fontName; height = right o \"height\" height; is3D = right o \"is3D\" is3D; pieHole = right o \"pieHole\" pieHole; pieSliceBorderColor = right o \"pieSliceBorderColor\" pieSliceBorderColor; pieSliceText = right o \"pieSliceText\" pieSliceText; pieStartAngle = right o \"pieStartAngle\" pieStartAngle; reverseCategories = right o \"reverseCategories\" reverseCategories; pieResidueSliceColor = right o \"pieResidueSliceColor\" pieResidueSliceColor; pieResidueSliceLabel = right o \"pieResidueSliceLabel\" pieResidueSliceLabel; slices = right o \"slices\" slices; sliceVisibilityThreshold = right o \"sliceVisibilityThreshold\" sliceVisibilityThreshold; title = right o \"title\" title; width = right o \"width\" width }\n    { x with options = newOptions }\n  member x.chartArea(?top:obj,?left:obj,?width:obj,?height:obj) =\n    let o = x.options.chartArea\n    let newNested = { ChartArea.top = right o \"top\" top; left = right o \"left\" left; width = right o \"width\" width; height = right o \"height\" height;  }\n    { x with options = { x.options with chartArea = newNested } }\n  member x.legend(?alignment:string,?maxLines:float,?position:string,?numberFormat:string) =\n    let o = x.options.legend\n    let newNested = { ChartLegend.alignment = right o \"alignment\" alignment; maxLines = right o \"maxLines\" maxLines; position = right o \"position\" position; numberFormat = right o \"numberFormat\" numberFormat; textStyle = copy o \"textStyle\" }\n    { x with options = { x.options with legend = newNested } }\n  member x.pieSliceTextStyle(?fontName:string,?fontSize:float,?bold:bool,?italic:bool,?color:string,?auraColor:string,?opacity:float) =\n    let o = x.options.pieSliceTextStyle\n    let newNested = { ChartTextStyle.fontName = right o \"fontName\" fontName; fontSize = right o \"fontSize\" fontSize; bold = right o \"bold\" bold; italic = right o \"italic\" italic; color = right o \"color\" color; auraColor = right o \"auraColor\" auraColor; opacity = right o \"opacity\" opacity;  }\n    { x with options = { x.options with pieSliceTextStyle = newNested } }\n  member x.titleTextStyle(?fontName:string,?fontSize:float,?bold:bool,?italic:bool,?color:string,?auraColor:string,?opacity:float) =\n    let o = x.options.titleTextStyle\n    let newNested = { ChartTextStyle.fontName = right o \"fontName\" fontName; fontSize = right o \"fontSize\" fontSize; bold = right o \"bold\" bold; italic = right o \"italic\" italic; color = right o \"color\" color; auraColor = right o \"auraColor\" auraColor; opacity = right o \"opacity\" opacity;  }\n    { x with options = { x.options with titleTextStyle = newNested } }\n  member x.tooltip(?isHtml:bool,?showColorCode:bool,?trigger:string) =\n    let o = x.options.tooltip\n    let newNested = { ChartTooltip.isHtml = right o \"isHtml\" isHtml; showColorCode = right o \"showColorCode\" showColorCode; trigger = right o \"trigger\" trigger; textStyle = copy o \"textStyle\" }\n    { x with options = { x.options with tooltip = newNested } }\ntype Bubble = \n  { data : ChartData; typeName : string; \n    options : BubbleChartOptions }\n  interface Chart\n  member x.show(outputId) = Helpers.showChart x outputId\n  member x.set(?axisTitlesPosition:string,?backgroundColor:obj,?colors:seq<string>,?enableInteractivity:bool,?fontSize:float,?fontName:string,?forceIFrame:bool,?height:float,?selectionMode:string,?series:obj,?sortBubblesBySize:bool,?theme:string,?title:string,?titlePosition:string,?width:float) = \n    let o = x.options\n    let newOptions = { x.options with axisTitlesPosition = right o \"axisTitlesPosition\" axisTitlesPosition; backgroundColor = right o \"backgroundColor\" backgroundColor; colors = right o \"colors\" (Option.map Array.ofSeq colors); enableInteractivity = right o \"enableInteractivity\" enableInteractivity; fontSize = right o \"fontSize\" fontSize; fontName = right o \"fontName\" fontName; forceIFrame = right o \"forceIFrame\" forceIFrame; height = right o \"height\" height; selectionMode = right o \"selectionMode\" selectionMode; series = right o \"series\" series; sortBubblesBySize = right o \"sortBubblesBySize\" sortBubblesBySize; theme = right o \"theme\" theme; title = right o \"title\" title; titlePosition = right o \"titlePosition\" titlePosition; width = right o \"width\" width }\n    { x with options = newOptions }\n  member x.animation(?duration:float,?easing:string) =\n    let o = x.options.animation\n    let newNested = { TransitionAnimation.duration = right o \"duration\" duration; easing = right o \"easing\" easing;  }\n    { x with options = { x.options with animation = newNested } }\n  member x.bubble(?opacity:float,?stroke:string) =\n    let o = x.options.bubble\n    let newNested = { ChartBubble.opacity = right o \"opacity\" opacity; stroke = right o \"stroke\" stroke; textStyle = copy o \"textStyle\" }\n    { x with options = { x.options with bubble = newNested } }\n  member x.chartArea(?top:obj,?left:obj,?width:obj,?height:obj) =\n    let o = x.options.chartArea\n    let newNested = { ChartArea.top = right o \"top\" top; left = right o \"left\" left; width = right o \"width\" width; height = right o \"height\" height;  }\n    { x with options = { x.options with chartArea = newNested } }\n  member x.colorAxis(?minValue:float,?maxValue:float,?values:seq<float>,?colors:seq<string>) =\n    let o = x.options.colorAxis\n    let newNested = { ChartColorAxis.minValue = right o \"minValue\" minValue; maxValue = right o \"maxValue\" maxValue; values = right o \"values\" (Option.map Array.ofSeq values); colors = right o \"colors\" (Option.map Array.ofSeq colors); legend = copy o \"legend\" }\n    { x with options = { x.options with colorAxis = newNested } }\n  member x.explorer(?actions:seq<string>,?axis:string,?keepInBounds:bool,?maxZoomIn:float,?maxZoomOut:float,?zoomDelta:float) =\n    let o = x.options.explorer\n    let newNested = { ChartExplorer.actions = right o \"actions\" (Option.map Array.ofSeq actions); axis = right o \"axis\" axis; keepInBounds = right o \"keepInBounds\" keepInBounds; maxZoomIn = right o \"maxZoomIn\" maxZoomIn; maxZoomOut = right o \"maxZoomOut\" maxZoomOut; zoomDelta = right o \"zoomDelta\" zoomDelta;  }\n    { x with options = { x.options with explorer = newNested } }\n  member x.hAxis(?baseline:float,?baselineColor:string,?direction:float,?format:string,?logScale:bool,?textPosition:string,?ticks:seq<obj>,?title:string,?allowContainerBoundaryTextCufoff:bool,?slantedText:bool,?slantedTextAngle:float,?maxAlternation:float,?maxTextLines:float,?minTextSpacing:float,?showTextEvery:float,?maxValue:float,?minValue:float,?viewWindowMode:string) =\n    let o = x.options.hAxis\n    let newNested = { ChartAxis.baseline = right o \"baseline\" baseline; baselineColor = right o \"baselineColor\" baselineColor; direction = right o \"direction\" direction; format = right o \"format\" format; logScale = right o \"logScale\" logScale; textPosition = right o \"textPosition\" textPosition; ticks = right o \"ticks\" (Option.map Array.ofSeq ticks); title = right o \"title\" title; allowContainerBoundaryTextCufoff = right o \"allowContainerBoundaryTextCufoff\" allowContainerBoundaryTextCufoff; slantedText = right o \"slantedText\" slantedText; slantedTextAngle = right o \"slantedTextAngle\" slantedTextAngle; maxAlternation = right o \"maxAlternation\" maxAlternation; maxTextLines = right o \"maxTextLines\" maxTextLines; minTextSpacing = right o \"minTextSpacing\" minTextSpacing; showTextEvery = right o \"showTextEvery\" showTextEvery; maxValue = right o \"maxValue\" maxValue; minValue = right o \"minValue\" minValue; viewWindowMode = right o \"viewWindowMode\" viewWindowMode; gridlines = copy o \"gridlines\"; minorGridlines = copy o \"minorGridlines\"; textStyle = copy o \"textStyle\"; titleTextStyle = copy o \"titleTextStyle\"; viewWindow = copy o \"viewWindow\" }\n    { x with options = { x.options with hAxis = newNested } }\n  member x.legend(?alignment:string,?maxLines:float,?position:string,?numberFormat:string) =\n    let o = x.options.legend\n    let newNested = { ChartLegend.alignment = right o \"alignment\" alignment; maxLines = right o \"maxLines\" maxLines; position = right o \"position\" position; numberFormat = right o \"numberFormat\" numberFormat; textStyle = copy o \"textStyle\" }\n    { x with options = { x.options with legend = newNested } }\n  member x.sizeAxis(?maxSize:float,?maxValue:float,?minSize:float,?minValue:float) =\n    let o = x.options.sizeAxis\n    let newNested = { ChartSizeAxis.maxSize = right o \"maxSize\" maxSize; maxValue = right o \"maxValue\" maxValue; minSize = right o \"minSize\" minSize; minValue = right o \"minValue\" minValue;  }\n    { x with options = { x.options with sizeAxis = newNested } }\n  member x.titleTextStyle(?fontName:string,?fontSize:float,?bold:bool,?italic:bool,?color:string,?auraColor:string,?opacity:float) =\n    let o = x.options.titleTextStyle\n    let newNested = { ChartTextStyle.fontName = right o \"fontName\" fontName; fontSize = right o \"fontSize\" fontSize; bold = right o \"bold\" bold; italic = right o \"italic\" italic; color = right o \"color\" color; auraColor = right o \"auraColor\" auraColor; opacity = right o \"opacity\" opacity;  }\n    { x with options = { x.options with titleTextStyle = newNested } }\n  member x.tooltip(?isHtml:bool,?showColorCode:bool,?trigger:string) =\n    let o = x.options.tooltip\n    let newNested = { ChartTooltip.isHtml = right o \"isHtml\" isHtml; showColorCode = right o \"showColorCode\" showColorCode; trigger = right o \"trigger\" trigger; textStyle = copy o \"textStyle\" }\n    { x with options = { x.options with tooltip = newNested } }\n  member x.vAxis(?baseline:float,?baselineColor:string,?direction:float,?format:string,?logScale:bool,?textPosition:string,?ticks:seq<obj>,?title:string,?allowContainerBoundaryTextCufoff:bool,?slantedText:bool,?slantedTextAngle:float,?maxAlternation:float,?maxTextLines:float,?minTextSpacing:float,?showTextEvery:float,?maxValue:float,?minValue:float,?viewWindowMode:string) =\n    let o = x.options.vAxis\n    let newNested = { ChartAxis.baseline = right o \"baseline\" baseline; baselineColor = right o \"baselineColor\" baselineColor; direction = right o \"direction\" direction; format = right o \"format\" format; logScale = right o \"logScale\" logScale; textPosition = right o \"textPosition\" textPosition; ticks = right o \"ticks\" (Option.map Array.ofSeq ticks); title = right o \"title\" title; allowContainerBoundaryTextCufoff = right o \"allowContainerBoundaryTextCufoff\" allowContainerBoundaryTextCufoff; slantedText = right o \"slantedText\" slantedText; slantedTextAngle = right o \"slantedTextAngle\" slantedTextAngle; maxAlternation = right o \"maxAlternation\" maxAlternation; maxTextLines = right o \"maxTextLines\" maxTextLines; minTextSpacing = right o \"minTextSpacing\" minTextSpacing; showTextEvery = right o \"showTextEvery\" showTextEvery; maxValue = right o \"maxValue\" maxValue; minValue = right o \"minValue\" minValue; viewWindowMode = right o \"viewWindowMode\" viewWindowMode; gridlines = copy o \"gridlines\"; minorGridlines = copy o \"minorGridlines\"; textStyle = copy o \"textStyle\"; titleTextStyle = copy o \"titleTextStyle\"; viewWindow = copy o \"viewWindow\" }\n    { x with options = { x.options with vAxis = newNested } }\ntype TreeMap = \n  { data : ChartData; typeName : string; \n    options : TreeMapOptions }\n  interface Chart\n  member x.show(outputId) = Helpers.showChart x outputId\n  member x.set(?fontColor:string,?fontFamily:string,?fontSize:float,?forceIFrame:bool,?headerColor:string,?headerHeight:float,?headerHighlightColor:string,?hintOpacity:float,?maxColor:string,?maxDepth:float,?maxHighlightColor:string,?maxPostDepth:float,?maxColorValue:float,?midColor:string,?midHighlightColor:string,?minColor:string,?minHighlightColor:string,?minColorValue:float,?showScale:bool,?showTooltips:bool,?title:string,?useWeightedAverageForAggregation:bool) = \n    let o = x.options\n    let newOptions = { x.options with fontColor = right o \"fontColor\" fontColor; fontFamily = right o \"fontFamily\" fontFamily; fontSize = right o \"fontSize\" fontSize; forceIFrame = right o \"forceIFrame\" forceIFrame; headerColor = right o \"headerColor\" headerColor; headerHeight = right o \"headerHeight\" headerHeight; headerHighlightColor = right o \"headerHighlightColor\" headerHighlightColor; hintOpacity = right o \"hintOpacity\" hintOpacity; maxColor = right o \"maxColor\" maxColor; maxDepth = right o \"maxDepth\" maxDepth; maxHighlightColor = right o \"maxHighlightColor\" maxHighlightColor; maxPostDepth = right o \"maxPostDepth\" maxPostDepth; maxColorValue = right o \"maxColorValue\" maxColorValue; midColor = right o \"midColor\" midColor; midHighlightColor = right o \"midHighlightColor\" midHighlightColor; minColor = right o \"minColor\" minColor; minHighlightColor = right o \"minHighlightColor\" minHighlightColor; minColorValue = right o \"minColorValue\" minColorValue; showScale = right o \"showScale\" showScale; showTooltips = right o \"showTooltips\" showTooltips; title = right o \"title\" title; useWeightedAverageForAggregation = right o \"useWeightedAverageForAggregation\" useWeightedAverageForAggregation }\n    { x with options = newOptions }\n  member x.textStyle(?fontName:string,?fontSize:float,?bold:bool,?italic:bool,?color:string,?auraColor:string,?opacity:float) =\n    let o = x.options.textStyle\n    let newNested = { ChartTextStyle.fontName = right o \"fontName\" fontName; fontSize = right o \"fontSize\" fontSize; bold = right o \"bold\" bold; italic = right o \"italic\" italic; color = right o \"color\" color; auraColor = right o \"auraColor\" auraColor; opacity = right o \"opacity\" opacity;  }\n    { x with options = { x.options with textStyle = newNested } }\n  member x.titleTextStyle(?fontName:string,?fontSize:float,?bold:bool,?italic:bool,?color:string,?auraColor:string,?opacity:float) =\n    let o = x.options.titleTextStyle\n    let newNested = { ChartTextStyle.fontName = right o \"fontName\" fontName; fontSize = right o \"fontSize\" fontSize; bold = right o \"bold\" bold; italic = right o \"italic\" italic; color = right o \"color\" color; auraColor = right o \"auraColor\" auraColor; opacity = right o \"opacity\" opacity;  }\n    { x with options = { x.options with titleTextStyle = newNested } }\ntype Table = \n  { data : ChartData; typeName : string; \n    options : TableOptions }\n  interface Chart\n  member x.show(outputId) = Helpers.showChart x outputId\n  member x.set(?allowHtml:bool,?alternatingRowStyle:bool,?firstRowNumber:float,?height:string,?page:string,?pageSize:float,?rtlTable:bool,?scrollLeftStartPosition:float,?showRowNumber:bool,?sort:string,?sortAscending:bool,?sortColumn:float,?startPage:float,?width:string) = \n    let o = x.options\n    let newOptions = { x.options with allowHtml = right o \"allowHtml\" allowHtml; alternatingRowStyle = right o \"alternatingRowStyle\" alternatingRowStyle; firstRowNumber = right o \"firstRowNumber\" firstRowNumber; height = right o \"height\" height; page = right o \"page\" page; pageSize = right o \"pageSize\" pageSize; rtlTable = right o \"rtlTable\" rtlTable; scrollLeftStartPosition = right o \"scrollLeftStartPosition\" scrollLeftStartPosition; showRowNumber = right o \"showRowNumber\" showRowNumber; sort = right o \"sort\" sort; sortAscending = right o \"sortAscending\" sortAscending; sortColumn = right o \"sortColumn\" sortColumn; startPage = right o \"startPage\" startPage; width = right o \"width\" width }\n    { x with options = newOptions }\n  member x.cssClassName(?headerRow:string,?tableRow:string,?oddTableRow:string,?selectedTableRow:string,?hoverTableRow:string,?headerCell:string,?tableCell:string,?rowNumberCell:string) =\n    let o = x.options.cssClassName\n    let newNested = { CssClassNames.headerRow = right o \"headerRow\" headerRow; tableRow = right o \"tableRow\" tableRow; oddTableRow = right o \"oddTableRow\" oddTableRow; selectedTableRow = right o \"selectedTableRow\" selectedTableRow; hoverTableRow = right o \"hoverTableRow\" hoverTableRow; headerCell = right o \"headerCell\" headerCell; tableCell = right o \"tableCell\" tableCell; rowNumberCell = right o \"rowNumberCell\" rowNumberCell;  }\n    { x with options = { x.options with cssClassName = newNested } }\ntype Timeline = \n  { data : ChartData; typeName : string; \n    options : TimelineOptions }\n  interface Chart\n  member x.show(outputId) = Helpers.showChart x outputId\n  member x.set(?avoidOverlappingGridLines:bool,?backgroundColor:obj,?colors:seq<string>,?enableInteractivity:bool,?forceIFrame:bool,?height:float,?width:float) = \n    let o = x.options\n    let newOptions = { x.options with avoidOverlappingGridLines = right o \"avoidOverlappingGridLines\" avoidOverlappingGridLines; backgroundColor = right o \"backgroundColor\" backgroundColor; colors = right o \"colors\" (Option.map Array.ofSeq colors); enableInteractivity = right o \"enableInteractivity\" enableInteractivity; forceIFrame = right o \"forceIFrame\" forceIFrame; height = right o \"height\" height; width = right o \"width\" width }\n    { x with options = newOptions }\n  member x.timeline(?colorByRowLabel:bool,?groupByRowLabel:bool,?showRowLabels:bool,?singleColor:string) =\n    let o = x.options.timeline\n    let newNested = { TimelineTimeline.colorByRowLabel = right o \"colorByRowLabel\" colorByRowLabel; groupByRowLabel = right o \"groupByRowLabel\" groupByRowLabel; showRowLabels = right o \"showRowLabels\" showRowLabels; singleColor = right o \"singleColor\" singleColor; barLabelStyle = copy o \"barLabelStyle\"; rowLabelStyle = copy o \"rowLabelStyle\" }\n    { x with options = { x.options with timeline = newNested } }\ntype Candlestick = \n  { data : ChartData; typeName : string; \n    options : CandlestickChartOptions }\n  interface Chart\n  member x.show(outputId) = Helpers.showChart x outputId\n  member x.set(?aggregationTarget:string,?axisTitlesPosition:string,?backgroundColor:obj,?colors:seq<string>,?enableInteractivity:bool,?focusTarget:string,?fontSize:float,?fontName:string,?height:float,?orientation:string,?reverseCategories:bool,?selectionMode:string,?series:obj,?theme:string,?title:string,?titlePosition:string,?vAxes:obj,?width:float) = \n    let o = x.options\n    let newOptions = { x.options with aggregationTarget = right o \"aggregationTarget\" aggregationTarget; axisTitlesPosition = right o \"axisTitlesPosition\" axisTitlesPosition; backgroundColor = right o \"backgroundColor\" backgroundColor; colors = right o \"colors\" (Option.map Array.ofSeq colors); enableInteractivity = right o \"enableInteractivity\" enableInteractivity; focusTarget = right o \"focusTarget\" focusTarget; fontSize = right o \"fontSize\" fontSize; fontName = right o \"fontName\" fontName; height = right o \"height\" height; orientation = right o \"orientation\" orientation; reverseCategories = right o \"reverseCategories\" reverseCategories; selectionMode = right o \"selectionMode\" selectionMode; series = right o \"series\" series; theme = right o \"theme\" theme; title = right o \"title\" title; titlePosition = right o \"titlePosition\" titlePosition; vAxes = right o \"vAxes\" vAxes; width = right o \"width\" width }\n    { x with options = newOptions }\n  member x.animation(?duration:float,?easing:string) =\n    let o = x.options.animation\n    let newNested = { TransitionAnimation.duration = right o \"duration\" duration; easing = right o \"easing\" easing;  }\n    { x with options = { x.options with animation = newNested } }\n  member x.bar(?groupWidth:obj) =\n    let o = x.options.bar\n    let newNested = { GroupWidth.groupWidth = right o \"groupWidth\" groupWidth;  }\n    { x with options = { x.options with bar = newNested } }\n  member x.candlestick(?hollowIsRising:bool) =\n    let o = x.options.candlestick\n    let newNested = { CandlestickCandlestick.hollowIsRising = right o \"hollowIsRising\" hollowIsRising; fallingColor = copy o \"fallingColor\"; risingColor = copy o \"risingColor\" }\n    { x with options = { x.options with candlestick = newNested } }\n  member x.chartArea(?top:obj,?left:obj,?width:obj,?height:obj) =\n    let o = x.options.chartArea\n    let newNested = { ChartArea.top = right o \"top\" top; left = right o \"left\" left; width = right o \"width\" width; height = right o \"height\" height;  }\n    { x with options = { x.options with chartArea = newNested } }\n  member x.hAxis(?baseline:float,?baselineColor:string,?direction:float,?format:string,?logScale:bool,?textPosition:string,?ticks:seq<obj>,?title:string,?allowContainerBoundaryTextCufoff:bool,?slantedText:bool,?slantedTextAngle:float,?maxAlternation:float,?maxTextLines:float,?minTextSpacing:float,?showTextEvery:float,?maxValue:float,?minValue:float,?viewWindowMode:string) =\n    let o = x.options.hAxis\n    let newNested = { ChartAxis.baseline = right o \"baseline\" baseline; baselineColor = right o \"baselineColor\" baselineColor; direction = right o \"direction\" direction; format = right o \"format\" format; logScale = right o \"logScale\" logScale; textPosition = right o \"textPosition\" textPosition; ticks = right o \"ticks\" (Option.map Array.ofSeq ticks); title = right o \"title\" title; allowContainerBoundaryTextCufoff = right o \"allowContainerBoundaryTextCufoff\" allowContainerBoundaryTextCufoff; slantedText = right o \"slantedText\" slantedText; slantedTextAngle = right o \"slantedTextAngle\" slantedTextAngle; maxAlternation = right o \"maxAlternation\" maxAlternation; maxTextLines = right o \"maxTextLines\" maxTextLines; minTextSpacing = right o \"minTextSpacing\" minTextSpacing; showTextEvery = right o \"showTextEvery\" showTextEvery; maxValue = right o \"maxValue\" maxValue; minValue = right o \"minValue\" minValue; viewWindowMode = right o \"viewWindowMode\" viewWindowMode; gridlines = copy o \"gridlines\"; minorGridlines = copy o \"minorGridlines\"; textStyle = copy o \"textStyle\"; titleTextStyle = copy o \"titleTextStyle\"; viewWindow = copy o \"viewWindow\" }\n    { x with options = { x.options with hAxis = newNested } }\n  member x.legend(?alignment:string,?maxLines:float,?position:string,?numberFormat:string) =\n    let o = x.options.legend\n    let newNested = { ChartLegend.alignment = right o \"alignment\" alignment; maxLines = right o \"maxLines\" maxLines; position = right o \"position\" position; numberFormat = right o \"numberFormat\" numberFormat; textStyle = copy o \"textStyle\" }\n    { x with options = { x.options with legend = newNested } }\n  member x.titleTextStyle(?fontName:string,?fontSize:float,?bold:bool,?italic:bool,?color:string,?auraColor:string,?opacity:float) =\n    let o = x.options.titleTextStyle\n    let newNested = { ChartTextStyle.fontName = right o \"fontName\" fontName; fontSize = right o \"fontSize\" fontSize; bold = right o \"bold\" bold; italic = right o \"italic\" italic; color = right o \"color\" color; auraColor = right o \"auraColor\" auraColor; opacity = right o \"opacity\" opacity;  }\n    { x with options = { x.options with titleTextStyle = newNested } }\n  member x.tooltip(?isHtml:bool,?showColorCode:bool,?trigger:string) =\n    let o = x.options.tooltip\n    let newNested = { ChartTooltip.isHtml = right o \"isHtml\" isHtml; showColorCode = right o \"showColorCode\" showColorCode; trigger = right o \"trigger\" trigger; textStyle = copy o \"textStyle\" }\n    { x with options = { x.options with tooltip = newNested } }\n  member x.vAxis(?baseline:float,?baselineColor:string,?direction:float,?format:string,?logScale:bool,?textPosition:string,?ticks:seq<obj>,?title:string,?allowContainerBoundaryTextCufoff:bool,?slantedText:bool,?slantedTextAngle:float,?maxAlternation:float,?maxTextLines:float,?minTextSpacing:float,?showTextEvery:float,?maxValue:float,?minValue:float,?viewWindowMode:string) =\n    let o = x.options.vAxis\n    let newNested = { ChartAxis.baseline = right o \"baseline\" baseline; baselineColor = right o \"baselineColor\" baselineColor; direction = right o \"direction\" direction; format = right o \"format\" format; logScale = right o \"logScale\" logScale; textPosition = right o \"textPosition\" textPosition; ticks = right o \"ticks\" (Option.map Array.ofSeq ticks); title = right o \"title\" title; allowContainerBoundaryTextCufoff = right o \"allowContainerBoundaryTextCufoff\" allowContainerBoundaryTextCufoff; slantedText = right o \"slantedText\" slantedText; slantedTextAngle = right o \"slantedTextAngle\" slantedTextAngle; maxAlternation = right o \"maxAlternation\" maxAlternation; maxTextLines = right o \"maxTextLines\" maxTextLines; minTextSpacing = right o \"minTextSpacing\" minTextSpacing; showTextEvery = right o \"showTextEvery\" showTextEvery; maxValue = right o \"maxValue\" maxValue; minValue = right o \"minValue\" minValue; viewWindowMode = right o \"viewWindowMode\" viewWindowMode; gridlines = copy o \"gridlines\"; minorGridlines = copy o \"minorGridlines\"; textStyle = copy o \"textStyle\"; titleTextStyle = copy o \"titleTextStyle\"; viewWindow = copy o \"viewWindow\" }\n    { x with options = { x.options with vAxis = newNested } }\n\ntype GeoChartOptions with\n  static member empty =\n    { GeoChartOptions.backgroundColor = undefined<_>(); colorAxis = undefined<_>(); datalessRegionColor = undefined<_>(); displayMode = undefined<_>(); enableRegionInteractivity = undefined<_>(); height = undefined<_>(); keepAspectRatio = undefined<_>(); legend = undefined<_>(); region = undefined<_>(); magnifyingGlass = undefined<_>(); markerOpacity = undefined<_>(); resolution = undefined<_>(); sizeAxis = undefined<_>(); tooltip = undefined<_>(); width = undefined<_>() }\ntype ScatterChartOptions with\n  static member empty =\n    { ScatterChartOptions.aggregationTarget = undefined<_>(); animation = undefined<_>(); annotations = undefined<_>(); axisTitlesPosition = undefined<_>(); backgroundColor = undefined<_>(); chartArea = undefined<_>(); colors = undefined<_>(); crosshair = undefined<_>(); curveType = undefined<_>(); dataOpacity = undefined<_>(); enableInteractivity = undefined<_>(); explorer = undefined<_>(); fontSize = undefined<_>(); fontName = undefined<_>(); forceIFrame = undefined<_>(); hAxis = undefined<_>(); height = undefined<_>(); legend = undefined<_>(); lineWidth = undefined<_>(); pointSize = undefined<_>(); selectionMode = undefined<_>(); series = undefined<_>(); theme = undefined<_>(); title = undefined<_>(); titlePosition = undefined<_>(); titleTextStyle = undefined<_>(); tooltip = undefined<_>(); trendlines = undefined<_>(); vAxis = undefined<_>(); width = undefined<_>() }\ntype ColumnChartOptions with\n  static member empty =\n    { ColumnChartOptions.aggregationTarget = undefined<_>(); animation = undefined<_>(); annotations = undefined<_>(); axisTitlesPosition = undefined<_>(); backgroundColor = undefined<_>(); bar = undefined<_>(); chartArea = undefined<_>(); colors = undefined<_>(); enableInteractivity = undefined<_>(); focusTarget = undefined<_>(); fontSize = undefined<_>(); fontName = undefined<_>(); hAxis = undefined<_>(); height = undefined<_>(); isStacked = undefined<_>(); legend = undefined<_>(); reverseCategories = undefined<_>(); selectionMode = undefined<_>(); series = undefined<_>(); theme = undefined<_>(); title = undefined<_>(); titlePosition = undefined<_>(); titleTextStyle = undefined<_>(); tooltip = undefined<_>(); vAxes = undefined<_>(); vAxis = undefined<_>(); width = undefined<_>() }\ntype LineChartOptions with\n  static member empty =\n    { LineChartOptions.aggregationTarget = undefined<_>(); animation = undefined<_>(); annotations = undefined<_>(); axisTitlesPosition = undefined<_>(); backgroundColor = undefined<_>(); chartArea = undefined<_>(); colors = undefined<_>(); crosshair = undefined<_>(); curveType = undefined<_>(); dataOpacity = undefined<_>(); enableInteractivity = undefined<_>(); explorer = undefined<_>(); focusTarget = undefined<_>(); fontSize = undefined<_>(); fontName = undefined<_>(); hAxis = undefined<_>(); height = undefined<_>(); interpolateNulls = undefined<_>(); legend = undefined<_>(); lineWidth = undefined<_>(); orientation = undefined<_>(); pointSize = undefined<_>(); reverseCategories = undefined<_>(); selectionMode = undefined<_>(); series = undefined<_>(); theme = undefined<_>(); title = undefined<_>(); titlePosition = undefined<_>(); titleTextStyle = undefined<_>(); tooltip = undefined<_>(); vAxes = undefined<_>(); vAxis = undefined<_>(); width = undefined<_>() }\ntype BarChartOptions with\n  static member empty =\n    { BarChartOptions.aggregationTarget = undefined<_>(); animation = undefined<_>(); annotations = undefined<_>(); axisTitlesPosition = undefined<_>(); backgroundColor = undefined<_>(); bar = undefined<_>(); chartArea = undefined<_>(); colors = undefined<_>(); dataOpacity = undefined<_>(); enableInteractivity = undefined<_>(); focusTarget = undefined<_>(); fontSize = undefined<_>(); fontName = undefined<_>(); hAxes = undefined<_>(); hAxis = undefined<_>(); height = undefined<_>(); isStacked = undefined<_>(); legend = undefined<_>(); reverseCategories = undefined<_>(); series = undefined<_>(); theme = undefined<_>(); title = undefined<_>(); titlePosition = undefined<_>(); titleTextStyle = undefined<_>(); tooltip = undefined<_>(); vAxes = undefined<_>(); vAxis = undefined<_>(); width = undefined<_>() }\ntype HistogramOptions with\n  static member empty =\n    { HistogramOptions.animation = undefined<_>(); axisTitlesPosition = undefined<_>(); backgroundColor = undefined<_>(); bar = undefined<_>(); chartArea = undefined<_>(); colors = undefined<_>(); dataOpacity = undefined<_>(); enableInteractivity = undefined<_>(); focusTarget = undefined<_>(); fontSize = undefined<_>(); fontName = undefined<_>(); hAxis = undefined<_>(); histogram = undefined<_>(); height = undefined<_>(); interpolateNulls = undefined<_>(); isStacked = undefined<_>(); legend = undefined<_>(); orientation = undefined<_>(); reverseCategories = undefined<_>(); series = undefined<_>(); theme = undefined<_>(); title = undefined<_>(); titlePosition = undefined<_>(); titleTextStyle = undefined<_>(); tooltip = undefined<_>(); vAxes = undefined<_>(); vAxis = undefined<_>(); width = undefined<_>() }\ntype AreaChartOptions with\n  static member empty =\n    { AreaChartOptions.aggregationTarget = undefined<_>(); animation = undefined<_>(); areaOpacity = undefined<_>(); axisTitlesPosition = undefined<_>(); backgroundColor = undefined<_>(); chartArea = undefined<_>(); colors = undefined<_>(); crosshair = undefined<_>(); dataOpacity = undefined<_>(); enableInteractivity = undefined<_>(); explorer = undefined<_>(); focusTarget = undefined<_>(); fontSize = undefined<_>(); fontName = undefined<_>(); hAxis = undefined<_>(); height = undefined<_>(); interpolateNulls = undefined<_>(); isStacked = undefined<_>(); legend = undefined<_>(); lineWidth = undefined<_>(); orientation = undefined<_>(); pointSize = undefined<_>(); reverseCategories = undefined<_>(); selectionMode = undefined<_>(); series = undefined<_>(); theme = undefined<_>(); title = undefined<_>(); titlePosition = undefined<_>(); titleTextStyle = undefined<_>(); tooltip = undefined<_>(); vAxes = undefined<_>(); vAxis = undefined<_>(); width = undefined<_>() }\ntype AnnotationChartOptions with\n  static member empty =\n    { AnnotationChartOptions.allowHtml = undefined<_>(); allValuesSuffix = undefined<_>(); annotationsWidth = undefined<_>(); colors = undefined<_>(); dateFormat = undefined<_>(); displayAnnotations = undefined<_>(); displayAnnotationsFilter = undefined<_>(); displayDateTimeBarSeparator = undefined<_>(); displayExactValues = undefined<_>(); displayLegendDots = undefined<_>(); displayLegendValues = undefined<_>(); displayRangeSelector = undefined<_>(); displayZoomButtons = undefined<_>(); fill = undefined<_>(); legendPosition = undefined<_>(); max = undefined<_>(); min = undefined<_>(); numberFormats = undefined<_>(); scaleColumns = undefined<_>(); scaleFormat = undefined<_>(); scaleType = undefined<_>(); thickness = undefined<_>(); zoomEndTime = undefined<_>(); zoomStartTime = undefined<_>() }\ntype SteppedAreaChartOptions with\n  static member empty =\n    { SteppedAreaChartOptions.aggregationTarget = undefined<_>(); animation = undefined<_>(); areaOpacity = undefined<_>(); axisTitlesPosition = undefined<_>(); backgroundColor = undefined<_>(); chartArea = undefined<_>(); colors = undefined<_>(); connectSteps = undefined<_>(); enableInteractivity = undefined<_>(); focusTarget = undefined<_>(); fontSize = undefined<_>(); fontName = undefined<_>(); hAxis = undefined<_>(); height = undefined<_>(); interpolateNulls = undefined<_>(); isStacked = undefined<_>(); legend = undefined<_>(); reverseCategories = undefined<_>(); selectionMode = undefined<_>(); series = undefined<_>(); theme = undefined<_>(); title = undefined<_>(); titlePosition = undefined<_>(); titleTextStyle = undefined<_>(); tooltip = undefined<_>(); vAxes = undefined<_>(); vAxis = undefined<_>(); width = undefined<_>() }\ntype PieChartOptions with\n  static member empty =\n    { PieChartOptions.backgroundColor = undefined<_>(); chartArea = undefined<_>(); colors = undefined<_>(); enableInteractivity = undefined<_>(); fontSize = undefined<_>(); fontName = undefined<_>(); height = undefined<_>(); is3D = undefined<_>(); legend = undefined<_>(); pieHole = undefined<_>(); pieSliceBorderColor = undefined<_>(); pieSliceText = undefined<_>(); pieSliceTextStyle = undefined<_>(); pieStartAngle = undefined<_>(); reverseCategories = undefined<_>(); pieResidueSliceColor = undefined<_>(); pieResidueSliceLabel = undefined<_>(); slices = undefined<_>(); sliceVisibilityThreshold = undefined<_>(); title = undefined<_>(); titleTextStyle = undefined<_>(); tooltip = undefined<_>(); width = undefined<_>() }\ntype BubbleChartOptions with\n  static member empty =\n    { BubbleChartOptions.animation = undefined<_>(); axisTitlesPosition = undefined<_>(); backgroundColor = undefined<_>(); bubble = undefined<_>(); chartArea = undefined<_>(); colors = undefined<_>(); colorAxis = undefined<_>(); enableInteractivity = undefined<_>(); explorer = undefined<_>(); fontSize = undefined<_>(); fontName = undefined<_>(); forceIFrame = undefined<_>(); hAxis = undefined<_>(); height = undefined<_>(); legend = undefined<_>(); selectionMode = undefined<_>(); series = undefined<_>(); sizeAxis = undefined<_>(); sortBubblesBySize = undefined<_>(); theme = undefined<_>(); title = undefined<_>(); titlePosition = undefined<_>(); titleTextStyle = undefined<_>(); tooltip = undefined<_>(); vAxis = undefined<_>(); width = undefined<_>() }\ntype TreeMapOptions with\n  static member empty =\n    { TreeMapOptions.fontColor = undefined<_>(); fontFamily = undefined<_>(); fontSize = undefined<_>(); forceIFrame = undefined<_>(); headerColor = undefined<_>(); headerHeight = undefined<_>(); headerHighlightColor = undefined<_>(); hintOpacity = undefined<_>(); maxColor = undefined<_>(); maxDepth = undefined<_>(); maxHighlightColor = undefined<_>(); maxPostDepth = undefined<_>(); maxColorValue = undefined<_>(); midColor = undefined<_>(); midHighlightColor = undefined<_>(); minColor = undefined<_>(); minHighlightColor = undefined<_>(); minColorValue = undefined<_>(); showScale = undefined<_>(); showTooltips = undefined<_>(); textStyle = undefined<_>(); title = undefined<_>(); titleTextStyle = undefined<_>(); useWeightedAverageForAggregation = undefined<_>() }\ntype TableOptions with\n  static member empty =\n    { TableOptions.allowHtml = undefined<_>(); alternatingRowStyle = undefined<_>(); cssClassName = undefined<_>(); firstRowNumber = undefined<_>(); height = undefined<_>(); page = undefined<_>(); pageSize = undefined<_>(); rtlTable = undefined<_>(); scrollLeftStartPosition = undefined<_>(); showRowNumber = undefined<_>(); sort = undefined<_>(); sortAscending = undefined<_>(); sortColumn = undefined<_>(); startPage = undefined<_>(); width = undefined<_>() }\ntype TimelineOptions with\n  static member empty =\n    { TimelineOptions.avoidOverlappingGridLines = undefined<_>(); backgroundColor = undefined<_>(); colors = undefined<_>(); enableInteractivity = undefined<_>(); forceIFrame = undefined<_>(); height = undefined<_>(); timeline = undefined<_>(); width = undefined<_>() }\ntype CandlestickChartOptions with\n  static member empty =\n    { CandlestickChartOptions.aggregationTarget = undefined<_>(); animation = undefined<_>(); axisTitlesPosition = undefined<_>(); backgroundColor = undefined<_>(); bar = undefined<_>(); candlestick = undefined<_>(); chartArea = undefined<_>(); colors = undefined<_>(); enableInteractivity = undefined<_>(); focusTarget = undefined<_>(); fontSize = undefined<_>(); fontName = undefined<_>(); hAxis = undefined<_>(); height = undefined<_>(); legend = undefined<_>(); orientation = undefined<_>(); reverseCategories = undefined<_>(); selectionMode = undefined<_>(); series = undefined<_>(); theme = undefined<_>(); title = undefined<_>(); titlePosition = undefined<_>(); titleTextStyle = undefined<_>(); tooltip = undefined<_>(); vAxes = undefined<_>(); vAxis = undefined<_>(); width = undefined<_>() }\n\ntype options =\n  static member chartSizeAxis(?maxSize:float,?maxValue:float,?minSize:float,?minValue:float) =\n    { ChartSizeAxis.maxSize = orDefault maxSize; maxValue = orDefault maxValue; minSize = orDefault minSize; minValue = orDefault minValue }\n  static member chartTextStyle(?fontName:string,?fontSize:float,?bold:bool,?italic:bool,?color:string,?auraColor:string,?opacity:float) =\n    { ChartTextStyle.fontName = orDefault fontName; fontSize = orDefault fontSize; bold = orDefault bold; italic = orDefault italic; color = orDefault color; auraColor = orDefault auraColor; opacity = orDefault opacity }\n  static member chartTooltip(?isHtml:bool,?showColorCode:bool,?textStyle:ChartTextStyle,?trigger:string) =\n    { ChartTooltip.isHtml = orDefault isHtml; showColorCode = orDefault showColorCode; textStyle = orDefault textStyle; trigger = orDefault trigger }\n  static member chartLegend(?alignment:string,?maxLines:float,?position:string,?textStyle:ChartTextStyle,?numberFormat:string) =\n    { ChartLegend.alignment = orDefault alignment; maxLines = orDefault maxLines; position = orDefault position; textStyle = orDefault textStyle; numberFormat = orDefault numberFormat }\n  static member chartColorAxis(?minValue:float,?maxValue:float,?values:seq<float>,?colors:seq<string>,?legend:ChartLegend) =\n    { ChartColorAxis.minValue = orDefault minValue; maxValue = orDefault maxValue; values = orDefault (Option.map Array.ofSeq values); colors = orDefault (Option.map Array.ofSeq colors); legend = orDefault legend }\n  static member geoChartMagnifyingGlass(?enable:bool,?zoomFactor:float) =\n    { GeoChartMagnifyingGlass.enable = orDefault enable; zoomFactor = orDefault zoomFactor }\n  static member chartBoxStyleGradient(?color1:string,?color2:string,?x1:string,?y1:string,?x2:string,?y2:string,?useObjectBoundingBoxUnits:bool) =\n    { ChartBoxStyleGradient.color1 = orDefault color1; color2 = orDefault color2; x1 = orDefault x1; y1 = orDefault y1; x2 = orDefault x2; y2 = orDefault y2; useObjectBoundingBoxUnits = orDefault useObjectBoundingBoxUnits }\n  static member chartBoxStyle(?stroke:string,?strokeWidth:float,?rx:float,?ry:float,?gradient:ChartBoxStyleGradient) =\n    { ChartBoxStyle.stroke = orDefault stroke; strokeWidth = orDefault strokeWidth; rx = orDefault rx; ry = orDefault ry; gradient = orDefault gradient }\n  static member chartAnnotations(?boxStyle:ChartBoxStyle,?textStyle:ChartTextStyle) =\n    { ChartAnnotations.boxStyle = orDefault boxStyle; textStyle = orDefault textStyle }\n  static member chartCrosshairFocused(?color:string,?opacity:float) =\n    { ChartCrosshairFocused.color = orDefault color; opacity = orDefault opacity }\n  static member chartCrosshairSelected(?color:string,?opacity:float) =\n    { ChartCrosshairSelected.color = orDefault color; opacity = orDefault opacity }\n  static member chartCrosshair(?color:string,?focused:ChartCrosshairFocused,?opacity:float,?orientation:string,?selected:ChartCrosshairSelected,?trigger:string) =\n    { ChartCrosshair.color = orDefault color; focused = orDefault focused; opacity = orDefault opacity; orientation = orDefault orientation; selected = orDefault selected; trigger = orDefault trigger }\n  static member chartExplorer(?actions:seq<string>,?axis:string,?keepInBounds:bool,?maxZoomIn:float,?maxZoomOut:float,?zoomDelta:float) =\n    { ChartExplorer.actions = orDefault (Option.map Array.ofSeq actions); axis = orDefault axis; keepInBounds = orDefault keepInBounds; maxZoomIn = orDefault maxZoomIn; maxZoomOut = orDefault maxZoomOut; zoomDelta = orDefault zoomDelta }\n  static member chartStroke(?stroke:string,?strokeWidth:float,?fill:string) =\n    { ChartStroke.stroke = orDefault stroke; strokeWidth = orDefault strokeWidth; fill = orDefault fill }\n  static member chartArea(?top:obj,?left:obj,?width:obj,?height:obj) =\n    { ChartArea.top = orDefault top; left = orDefault left; width = orDefault width; height = orDefault height }\n  static member transitionAnimation(?duration:float,?easing:string) =\n    { TransitionAnimation.duration = orDefault duration; easing = orDefault easing }\n  static member chartGridlines(?color:string,?count:float) =\n    { ChartGridlines.color = orDefault color; count = orDefault count }\n  static member chartViewWindow(?max:float,?min:float) =\n    { ChartViewWindow.max = orDefault max; min = orDefault min }\n  static member chartAxis(?baseline:float,?baselineColor:string,?direction:float,?format:string,?gridlines:ChartGridlines,?minorGridlines:ChartGridlines,?logScale:bool,?textPosition:string,?textStyle:ChartTextStyle,?ticks:seq<obj>,?title:string,?titleTextStyle:ChartTextStyle,?allowContainerBoundaryTextCufoff:bool,?slantedText:bool,?slantedTextAngle:float,?maxAlternation:float,?maxTextLines:float,?minTextSpacing:float,?showTextEvery:float,?maxValue:float,?minValue:float,?viewWindowMode:string,?viewWindow:ChartViewWindow) =\n    { ChartAxis.baseline = orDefault baseline; baselineColor = orDefault baselineColor; direction = orDefault direction; format = orDefault format; gridlines = orDefault gridlines; minorGridlines = orDefault minorGridlines; logScale = orDefault logScale; textPosition = orDefault textPosition; textStyle = orDefault textStyle; ticks = orDefault (Option.map Array.ofSeq ticks); title = orDefault title; titleTextStyle = orDefault titleTextStyle; allowContainerBoundaryTextCufoff = orDefault allowContainerBoundaryTextCufoff; slantedText = orDefault slantedText; slantedTextAngle = orDefault slantedTextAngle; maxAlternation = orDefault maxAlternation; maxTextLines = orDefault maxTextLines; minTextSpacing = orDefault minTextSpacing; showTextEvery = orDefault showTextEvery; maxValue = orDefault maxValue; minValue = orDefault minValue; viewWindowMode = orDefault viewWindowMode; viewWindow = orDefault viewWindow }\n  static member chartBoundingBox(?left:float,?top:float,?width:float,?height:float) =\n    { ChartBoundingBox.left = orDefault left; top = orDefault top; width = orDefault width; height = orDefault height }\n  static member groupWidth(?groupWidth:obj) =\n    { GroupWidth.groupWidth = orDefault groupWidth }\n  static member trendline(?color:string,?lineWidth:float,?labelInLegend:string,?opacity:float,?pointSize:float,?pointsVisible:bool,?showR2:bool,?``type``:string,?visibleInLegend:float) =\n    { Trendline.color = orDefault color; lineWidth = orDefault lineWidth; labelInLegend = orDefault labelInLegend; opacity = orDefault opacity; pointSize = orDefault pointSize; pointsVisible = orDefault pointsVisible; showR2 = orDefault showR2; ``type`` = orDefault ``type``; visibleInLegend = orDefault visibleInLegend }\n  static member histogramHistogram(?bucketSize:float,?hideBucketItems:bool,?lastBucketPercentile:float) =\n    { HistogramHistogram.bucketSize = orDefault bucketSize; hideBucketItems = orDefault hideBucketItems; lastBucketPercentile = orDefault lastBucketPercentile }\n  static member chartBubble(?opacity:float,?stroke:string,?textStyle:ChartTextStyle) =\n    { ChartBubble.opacity = orDefault opacity; stroke = orDefault stroke; textStyle = orDefault textStyle }\n  static member cssClassNames(?headerRow:string,?tableRow:string,?oddTableRow:string,?selectedTableRow:string,?hoverTableRow:string,?headerCell:string,?tableCell:string,?rowNumberCell:string) =\n    { CssClassNames.headerRow = orDefault headerRow; tableRow = orDefault tableRow; oddTableRow = orDefault oddTableRow; selectedTableRow = orDefault selectedTableRow; hoverTableRow = orDefault hoverTableRow; headerCell = orDefault headerCell; tableCell = orDefault tableCell; rowNumberCell = orDefault rowNumberCell }\n  static member labelStyle(?color:string,?fontName:string,?fontSize:string) =\n    { LabelStyle.color = orDefault color; fontName = orDefault fontName; fontSize = orDefault fontSize }\n  static member timelineTimeline(?barLabelStyle:LabelStyle,?colorByRowLabel:bool,?groupByRowLabel:bool,?rowLabelStyle:LabelStyle,?showRowLabels:bool,?singleColor:string) =\n    { TimelineTimeline.barLabelStyle = orDefault barLabelStyle; colorByRowLabel = orDefault colorByRowLabel; groupByRowLabel = orDefault groupByRowLabel; rowLabelStyle = orDefault rowLabelStyle; showRowLabels = orDefault showRowLabels; singleColor = orDefault singleColor }\n  static member candlestickCandlestick(?hollowIsRising:bool,?fallingColor:ChartStroke,?risingColor:ChartStroke) =\n    { CandlestickCandlestick.hollowIsRising = orDefault hollowIsRising; fallingColor = orDefault fallingColor; risingColor = orDefault risingColor }\n","var nativeIsArray = Array.isArray\nvar toString = Object.prototype.toString\n\nmodule.exports = nativeIsArray || isArray\n\nfunction isArray(obj) {\n    return toString.call(obj) === \"[object Array]\"\n}\n","var version = require(\"./version\")\n\nVirtualPatch.NONE = 0\nVirtualPatch.VTEXT = 1\nVirtualPatch.VNODE = 2\nVirtualPatch.WIDGET = 3\nVirtualPatch.PROPS = 4\nVirtualPatch.ORDER = 5\nVirtualPatch.INSERT = 6\nVirtualPatch.REMOVE = 7\nVirtualPatch.THUNK = 8\n\nmodule.exports = VirtualPatch\n\nfunction VirtualPatch(type, vNode, patch) {\n    this.type = Number(type)\n    this.vNode = vNode\n    this.patch = patch\n}\n\nVirtualPatch.prototype.version = version\nVirtualPatch.prototype.type = \"VirtualPatch\"\n","var version = require(\"./version\")\n\nmodule.exports = isVirtualNode\n\nfunction isVirtualNode(x) {\n    return x && x.type === \"VirtualNode\" && x.version === version\n}\n","var version = require(\"./version\")\n\nmodule.exports = isVirtualText\n\nfunction isVirtualText(x) {\n    return x && x.type === \"VirtualText\" && x.version === version\n}\n","module.exports = isWidget\n\nfunction isWidget(w) {\n    return w && w.type === \"Widget\"\n}\n","module.exports = isThunk\r\n\r\nfunction isThunk(t) {\r\n    return t && t.type === \"Thunk\"\r\n}\r\n","var isVNode = require(\"./is-vnode\")\nvar isVText = require(\"./is-vtext\")\nvar isWidget = require(\"./is-widget\")\nvar isThunk = require(\"./is-thunk\")\n\nmodule.exports = handleThunk\n\nfunction handleThunk(a, b) {\n    var renderedA = a\n    var renderedB = b\n\n    if (isThunk(b)) {\n        renderedB = renderThunk(b, a)\n    }\n\n    if (isThunk(a)) {\n        renderedA = renderThunk(a, null)\n    }\n\n    return {\n        a: renderedA,\n        b: renderedB\n    }\n}\n\nfunction renderThunk(thunk, previous) {\n    var renderedThunk = thunk.vnode\n\n    if (!renderedThunk) {\n        renderedThunk = thunk.vnode = thunk.render(previous)\n    }\n\n    if (!(isVNode(renderedThunk) ||\n            isVText(renderedThunk) ||\n            isWidget(renderedThunk))) {\n        throw new Error(\"thunk did not return a valid node\");\n    }\n\n    return renderedThunk\n}\n","module.exports = isHook\n\nfunction isHook(hook) {\n    return hook &&\n      (typeof hook.hook === \"function\" && !hook.hasOwnProperty(\"hook\") ||\n       typeof hook.unhook === \"function\" && !hook.hasOwnProperty(\"unhook\"))\n}\n","var isObject = require(\"is-object\")\nvar isHook = require(\"../vnode/is-vhook\")\n\nmodule.exports = diffProps\n\nfunction diffProps(a, b) {\n    var diff\n\n    for (var aKey in a) {\n        if (!(aKey in b)) {\n            diff = diff || {}\n            diff[aKey] = undefined\n        }\n\n        var aValue = a[aKey]\n        var bValue = b[aKey]\n\n        if (aValue === bValue) {\n            continue\n        } else if (isObject(aValue) && isObject(bValue)) {\n            if (getPrototype(bValue) !== getPrototype(aValue)) {\n                diff = diff || {}\n                diff[aKey] = bValue\n            } else if (isHook(bValue)) {\n                 diff = diff || {}\n                 diff[aKey] = bValue\n            } else {\n                var objectDiff = diffProps(aValue, bValue)\n                if (objectDiff) {\n                    diff = diff || {}\n                    diff[aKey] = objectDiff\n                }\n            }\n        } else {\n            diff = diff || {}\n            diff[aKey] = bValue\n        }\n    }\n\n    for (var bKey in b) {\n        if (!(bKey in a)) {\n            diff = diff || {}\n            diff[bKey] = b[bKey]\n        }\n    }\n\n    return diff\n}\n\nfunction getPrototype(value) {\n  if (Object.getPrototypeOf) {\n    return Object.getPrototypeOf(value)\n  } else if (value.__proto__) {\n    return value.__proto__\n  } else if (value.constructor) {\n    return value.constructor.prototype\n  }\n}\n","var isArray = require(\"x-is-array\")\n\nvar VPatch = require(\"../vnode/vpatch\")\nvar isVNode = require(\"../vnode/is-vnode\")\nvar isVText = require(\"../vnode/is-vtext\")\nvar isWidget = require(\"../vnode/is-widget\")\nvar isThunk = require(\"../vnode/is-thunk\")\nvar handleThunk = require(\"../vnode/handle-thunk\")\n\nvar diffProps = require(\"./diff-props\")\n\nmodule.exports = diff\n\nfunction diff(a, b) {\n    var patch = { a: a }\n    walk(a, b, patch, 0)\n    return patch\n}\n\nfunction walk(a, b, patch, index) {\n    if (a === b) {\n        return\n    }\n\n    var apply = patch[index]\n    var applyClear = false\n\n    if (isThunk(a) || isThunk(b)) {\n        thunks(a, b, patch, index)\n    } else if (b == null) {\n\n        // If a is a widget we will add a remove patch for it\n        // Otherwise any child widgets/hooks must be destroyed.\n        // This prevents adding two remove patches for a widget.\n        if (!isWidget(a)) {\n            clearState(a, patch, index)\n            apply = patch[index]\n        }\n\n        apply = appendPatch(apply, new VPatch(VPatch.REMOVE, a, b))\n    } else if (isVNode(b)) {\n        if (isVNode(a)) {\n            if (a.tagName === b.tagName &&\n                a.namespace === b.namespace &&\n                a.key === b.key) {\n                var propsPatch = diffProps(a.properties, b.properties)\n                if (propsPatch) {\n                    apply = appendPatch(apply,\n                        new VPatch(VPatch.PROPS, a, propsPatch))\n                }\n                apply = diffChildren(a, b, patch, apply, index)\n            } else {\n                apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))\n                applyClear = true\n            }\n        } else {\n            apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))\n            applyClear = true\n        }\n    } else if (isVText(b)) {\n        if (!isVText(a)) {\n            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))\n            applyClear = true\n        } else if (a.text !== b.text) {\n            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))\n        }\n    } else if (isWidget(b)) {\n        if (!isWidget(a)) {\n            applyClear = true\n        }\n\n        apply = appendPatch(apply, new VPatch(VPatch.WIDGET, a, b))\n    }\n\n    if (apply) {\n        patch[index] = apply\n    }\n\n    if (applyClear) {\n        clearState(a, patch, index)\n    }\n}\n\nfunction diffChildren(a, b, patch, apply, index) {\n    var aChildren = a.children\n    var orderedSet = reorder(aChildren, b.children)\n    var bChildren = orderedSet.children\n\n    var aLen = aChildren.length\n    var bLen = bChildren.length\n    var len = aLen > bLen ? aLen : bLen\n\n    for (var i = 0; i < len; i++) {\n        var leftNode = aChildren[i]\n        var rightNode = bChildren[i]\n        index += 1\n\n        if (!leftNode) {\n            if (rightNode) {\n                // Excess nodes in b need to be added\n                apply = appendPatch(apply,\n                    new VPatch(VPatch.INSERT, null, rightNode))\n            }\n        } else {\n            walk(leftNode, rightNode, patch, index)\n        }\n\n        if (isVNode(leftNode) && leftNode.count) {\n            index += leftNode.count\n        }\n    }\n\n    if (orderedSet.moves) {\n        // Reorder nodes last\n        apply = appendPatch(apply, new VPatch(\n            VPatch.ORDER,\n            a,\n            orderedSet.moves\n        ))\n    }\n\n    return apply\n}\n\nfunction clearState(vNode, patch, index) {\n    // TODO: Make this a single walk, not two\n    unhook(vNode, patch, index)\n    destroyWidgets(vNode, patch, index)\n}\n\n// Patch records for all destroyed widgets must be added because we need\n// a DOM node reference for the destroy function\nfunction destroyWidgets(vNode, patch, index) {\n    if (isWidget(vNode)) {\n        if (typeof vNode.destroy === \"function\") {\n            patch[index] = appendPatch(\n                patch[index],\n                new VPatch(VPatch.REMOVE, vNode, null)\n            )\n        }\n    } else if (isVNode(vNode) && (vNode.hasWidgets || vNode.hasThunks)) {\n        var children = vNode.children\n        var len = children.length\n        for (var i = 0; i < len; i++) {\n            var child = children[i]\n            index += 1\n\n            destroyWidgets(child, patch, index)\n\n            if (isVNode(child) && child.count) {\n                index += child.count\n            }\n        }\n    } else if (isThunk(vNode)) {\n        thunks(vNode, null, patch, index)\n    }\n}\n\n// Create a sub-patch for thunks\nfunction thunks(a, b, patch, index) {\n    var nodes = handleThunk(a, b)\n    var thunkPatch = diff(nodes.a, nodes.b)\n    if (hasPatches(thunkPatch)) {\n        patch[index] = new VPatch(VPatch.THUNK, null, thunkPatch)\n    }\n}\n\nfunction hasPatches(patch) {\n    for (var index in patch) {\n        if (index !== \"a\") {\n            return true\n        }\n    }\n\n    return false\n}\n\n// Execute hooks when two nodes are identical\nfunction unhook(vNode, patch, index) {\n    if (isVNode(vNode)) {\n        if (vNode.hooks) {\n            patch[index] = appendPatch(\n                patch[index],\n                new VPatch(\n                    VPatch.PROPS,\n                    vNode,\n                    undefinedKeys(vNode.hooks)\n                )\n            )\n        }\n\n        if (vNode.descendantHooks || vNode.hasThunks) {\n            var children = vNode.children\n            var len = children.length\n            for (var i = 0; i < len; i++) {\n                var child = children[i]\n                index += 1\n\n                unhook(child, patch, index)\n\n                if (isVNode(child) && child.count) {\n                    index += child.count\n                }\n            }\n        }\n    } else if (isThunk(vNode)) {\n        thunks(vNode, null, patch, index)\n    }\n}\n\nfunction undefinedKeys(obj) {\n    var result = {}\n\n    for (var key in obj) {\n        result[key] = undefined\n    }\n\n    return result\n}\n\n// List diff, naive left to right reordering\nfunction reorder(aChildren, bChildren) {\n    // O(M) time, O(M) memory\n    var bChildIndex = keyIndex(bChildren)\n    var bKeys = bChildIndex.keys\n    var bFree = bChildIndex.free\n\n    if (bFree.length === bChildren.length) {\n        return {\n            children: bChildren,\n            moves: null\n        }\n    }\n\n    // O(N) time, O(N) memory\n    var aChildIndex = keyIndex(aChildren)\n    var aKeys = aChildIndex.keys\n    var aFree = aChildIndex.free\n\n    if (aFree.length === aChildren.length) {\n        return {\n            children: bChildren,\n            moves: null\n        }\n    }\n\n    // O(MAX(N, M)) memory\n    var newChildren = []\n\n    var freeIndex = 0\n    var freeCount = bFree.length\n    var deletedItems = 0\n\n    // Iterate through a and match a node in b\n    // O(N) time,\n    for (var i = 0 ; i < aChildren.length; i++) {\n        var aItem = aChildren[i]\n        var itemIndex\n\n        if (aItem.key) {\n            if (bKeys.hasOwnProperty(aItem.key)) {\n                // Match up the old keys\n                itemIndex = bKeys[aItem.key]\n                newChildren.push(bChildren[itemIndex])\n\n            } else {\n                // Remove old keyed items\n                itemIndex = i - deletedItems++\n                newChildren.push(null)\n            }\n        } else {\n            // Match the item in a with the next free item in b\n            if (freeIndex < freeCount) {\n                itemIndex = bFree[freeIndex++]\n                newChildren.push(bChildren[itemIndex])\n            } else {\n                // There are no free items in b to match with\n                // the free items in a, so the extra free nodes\n                // are deleted.\n                itemIndex = i - deletedItems++\n                newChildren.push(null)\n            }\n        }\n    }\n\n    var lastFreeIndex = freeIndex >= bFree.length ?\n        bChildren.length :\n        bFree[freeIndex]\n\n    // Iterate through b and append any new keys\n    // O(M) time\n    for (var j = 0; j < bChildren.length; j++) {\n        var newItem = bChildren[j]\n\n        if (newItem.key) {\n            if (!aKeys.hasOwnProperty(newItem.key)) {\n                // Add any new keyed items\n                // We are adding new items to the end and then sorting them\n                // in place. In future we should insert new items in place.\n                newChildren.push(newItem)\n            }\n        } else if (j >= lastFreeIndex) {\n            // Add any leftover non-keyed items\n            newChildren.push(newItem)\n        }\n    }\n\n    var simulate = newChildren.slice()\n    var simulateIndex = 0\n    var removes = []\n    var inserts = []\n    var simulateItem\n\n    for (var k = 0; k < bChildren.length;) {\n        var wantedItem = bChildren[k]\n        simulateItem = simulate[simulateIndex]\n\n        // remove items\n        while (simulateItem === null && simulate.length) {\n            removes.push(remove(simulate, simulateIndex, null))\n            simulateItem = simulate[simulateIndex]\n        }\n\n        if (!simulateItem || simulateItem.key !== wantedItem.key) {\n            // if we need a key in this position...\n            if (wantedItem.key) {\n                if (simulateItem && simulateItem.key) {\n                    // if an insert doesn't put this key in place, it needs to move\n                    if (bKeys[simulateItem.key] !== k + 1) {\n                        removes.push(remove(simulate, simulateIndex, simulateItem.key))\n                        simulateItem = simulate[simulateIndex]\n                        // if the remove didn't put the wanted item in place, we need to insert it\n                        if (!simulateItem || simulateItem.key !== wantedItem.key) {\n                            inserts.push({key: wantedItem.key, to: k})\n                        }\n                        // items are matching, so skip ahead\n                        else {\n                            simulateIndex++\n                        }\n                    }\n                    else {\n                        inserts.push({key: wantedItem.key, to: k})\n                    }\n                }\n                else {\n                    inserts.push({key: wantedItem.key, to: k})\n                }\n                k++\n            }\n            // a key in simulate has no matching wanted key, remove it\n            else if (simulateItem && simulateItem.key) {\n                removes.push(remove(simulate, simulateIndex, simulateItem.key))\n            }\n        }\n        else {\n            simulateIndex++\n            k++\n        }\n    }\n\n    // remove all the remaining nodes from simulate\n    while(simulateIndex < simulate.length) {\n        simulateItem = simulate[simulateIndex]\n        removes.push(remove(simulate, simulateIndex, simulateItem && simulateItem.key))\n    }\n\n    // If the only moves we have are deletes then we can just\n    // let the delete patch remove these items.\n    if (removes.length === deletedItems && !inserts.length) {\n        return {\n            children: newChildren,\n            moves: null\n        }\n    }\n\n    return {\n        children: newChildren,\n        moves: {\n            removes: removes,\n            inserts: inserts\n        }\n    }\n}\n\nfunction remove(arr, index, key) {\n    arr.splice(index, 1)\n\n    return {\n        from: index,\n        key: key\n    }\n}\n\nfunction keyIndex(children) {\n    var keys = {}\n    var free = []\n    var length = children.length\n\n    for (var i = 0; i < length; i++) {\n        var child = children[i]\n\n        if (child.key) {\n            keys[child.key] = i\n        } else {\n            free.push(i)\n        }\n    }\n\n    return {\n        keys: keys,     // A hash of key name to index\n        free: free      // An array of unkeyed item indices\n    }\n}\n\nfunction appendPatch(apply, patch) {\n    if (apply) {\n        if (isArray(apply)) {\n            apply.push(patch)\n        } else {\n            apply = [apply, patch]\n        }\n\n        return apply\n    } else {\n        return patch\n    }\n}\n","var slice = Array.prototype.slice\n\nmodule.exports = iterativelyWalk\n\nfunction iterativelyWalk(nodes, cb) {\n    if (!('length' in nodes)) {\n        nodes = [nodes]\n    }\n    \n    nodes = slice.call(nodes)\n\n    while(nodes.length) {\n        var node = nodes.shift(),\n            ret = cb(node)\n\n        if (ret) {\n            return ret\n        }\n\n        if (node.childNodes && node.childNodes.length) {\n            nodes = slice.call(node.childNodes).concat(nodes)\n        }\n    }\n}\n","module.exports = Comment\n\nfunction Comment(data, owner) {\n    if (!(this instanceof Comment)) {\n        return new Comment(data, owner)\n    }\n\n    this.data = data\n    this.nodeValue = data\n    this.length = data.length\n    this.ownerDocument = owner || null\n}\n\nComment.prototype.nodeType = 8\nComment.prototype.nodeName = \"#comment\"\n\nComment.prototype.toString = function _Comment_toString() {\n    return \"[object Comment]\"\n}\n","module.exports = DOMText\n\nfunction DOMText(value, owner) {\n    if (!(this instanceof DOMText)) {\n        return new DOMText(value)\n    }\n\n    this.data = value || \"\"\n    this.length = this.data.length\n    this.ownerDocument = owner || null\n}\n\nDOMText.prototype.type = \"DOMTextNode\"\nDOMText.prototype.nodeType = 3\nDOMText.prototype.nodeName = \"#text\"\n\nDOMText.prototype.toString = function _Text_toString() {\n    return this.data\n}\n\nDOMText.prototype.replaceData = function replaceData(index, length, value) {\n    var current = this.data\n    var left = current.substring(0, index)\n    var right = current.substring(index + length, current.length)\n    this.data = left + value + right\n    this.length = this.data.length\n}\n","module.exports = dispatchEvent\n\nfunction dispatchEvent(ev) {\n    var elem = this\n    var type = ev.type\n\n    if (!ev.target) {\n        ev.target = elem\n    }\n\n    if (!elem.listeners) {\n        elem.listeners = {}\n    }\n\n    var listeners = elem.listeners[type]\n\n    if (listeners) {\n        return listeners.forEach(function (listener) {\n            ev.currentTarget = elem\n            if (typeof listener === 'function') {\n                listener(ev)\n            } else {\n                listener.handleEvent(ev)\n            }\n        })\n    }\n\n    if (elem.parentNode) {\n        elem.parentNode.dispatchEvent(ev)\n    }\n}\n","module.exports = addEventListener\n\nfunction addEventListener(type, listener) {\n    var elem = this\n\n    if (!elem.listeners) {\n        elem.listeners = {}\n    }\n\n    if (!elem.listeners[type]) {\n        elem.listeners[type] = []\n    }\n\n    if (elem.listeners[type].indexOf(listener) === -1) {\n        elem.listeners[type].push(listener)\n    }\n}\n","module.exports = removeEventListener\n\nfunction removeEventListener(type, listener) {\n    var elem = this\n\n    if (!elem.listeners) {\n        return\n    }\n\n    if (!elem.listeners[type]) {\n        return\n    }\n\n    var list = elem.listeners[type]\n    var index = list.indexOf(listener)\n    if (index !== -1) {\n        list.splice(index, 1)\n    }\n}\n","module.exports = serializeNode\n\nvar voidElements = [\"area\",\"base\",\"br\",\"col\",\"embed\",\"hr\",\"img\",\"input\",\"keygen\",\"link\",\"menuitem\",\"meta\",\"param\",\"source\",\"track\",\"wbr\"];\n\nfunction serializeNode(node) {\n    switch (node.nodeType) {\n        case 3:\n            return escapeText(node.data)\n        case 8:\n            return \"<!--\" + node.data + \"-->\"\n        default:\n            return serializeElement(node)\n    }\n}\n\nfunction serializeElement(elem) {\n    var strings = []\n\n    var tagname = elem.tagName\n\n    if (elem.namespaceURI === \"http://www.w3.org/1999/xhtml\") {\n        tagname = tagname.toLowerCase()\n    }\n\n    strings.push(\"<\" + tagname + properties(elem) + datasetify(elem))\n\n    if (voidElements.indexOf(tagname) > -1) {\n        strings.push(\" />\")\n    } else {\n        strings.push(\">\")\n\n        if (elem.childNodes.length) {\n            strings.push.apply(strings, elem.childNodes.map(serializeNode))\n        } else if (elem.textContent || elem.innerText) {\n            strings.push(escapeText(elem.textContent || elem.innerText))\n        } else if (elem.innerHTML) {\n            strings.push(elem.innerHTML)\n        }\n\n        strings.push(\"</\" + tagname + \">\")\n    }\n\n    return strings.join(\"\")\n}\n\nfunction isProperty(elem, key) {\n    var type = typeof elem[key]\n\n    if (key === \"style\" && Object.keys(elem.style).length > 0) {\n      return true\n    }\n\n    return elem.hasOwnProperty(key) &&\n        (type === \"string\" || type === \"boolean\" || type === \"number\") &&\n        key !== \"nodeName\" && key !== \"className\" && key !== \"tagName\" &&\n        key !== \"textContent\" && key !== \"innerText\" && key !== \"namespaceURI\" &&  key !== \"innerHTML\"\n}\n\nfunction stylify(styles) {\n    if (typeof styles === 'string') return styles\n    var attr = \"\"\n    Object.keys(styles).forEach(function (key) {\n        var value = styles[key]\n        key = key.replace(/[A-Z]/g, function(c) {\n            return \"-\" + c.toLowerCase();\n        })\n        attr += key + \":\" + value + \";\"\n    })\n    return attr\n}\n\nfunction datasetify(elem) {\n    var ds = elem.dataset\n    var props = []\n\n    for (var key in ds) {\n        props.push({ name: \"data-\" + key, value: ds[key] })\n    }\n\n    return props.length ? stringify(props) : \"\"\n}\n\nfunction stringify(list) {\n    var attributes = []\n    list.forEach(function (tuple) {\n        var name = tuple.name\n        var value = tuple.value\n\n        if (name === \"style\") {\n            value = stylify(value)\n        }\n\n        attributes.push(name + \"=\" + \"\\\"\" + escapeAttributeValue(value) + \"\\\"\")\n    })\n\n    return attributes.length ? \" \" + attributes.join(\" \") : \"\"\n}\n\nfunction properties(elem) {\n    var props = []\n    for (var key in elem) {\n        if (isProperty(elem, key)) {\n            props.push({ name: key, value: elem[key] })\n        }\n    }\n\n    for (var ns in elem._attributes) {\n      for (var attribute in elem._attributes[ns]) {\n        var prop = elem._attributes[ns][attribute]\n        var name = (prop.prefix ? prop.prefix + \":\" : \"\") + attribute\n        props.push({ name: name, value: prop.value })\n      }\n    }\n\n    if (elem.className) {\n        props.push({ name: \"class\", value: elem.className })\n    }\n\n    return props.length ? stringify(props) : \"\"\n}\n\nfunction escapeText(s) {\n    var str = '';\n\n    if (typeof(s) === 'string') { \n        str = s; \n    } else if (s) {\n        str = s.toString();\n    }\n\n    return str\n        .replace(/&/g, \"&amp;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\")\n}\n\nfunction escapeAttributeValue(str) {\n    return escapeText(str).replace(/\"/g, \"&quot;\")\n}\n","var domWalk = require(\"dom-walk\")\nvar dispatchEvent = require(\"./event/dispatch-event.js\")\nvar addEventListener = require(\"./event/add-event-listener.js\")\nvar removeEventListener = require(\"./event/remove-event-listener.js\")\nvar serializeNode = require(\"./serialize.js\")\n\nvar htmlns = \"http://www.w3.org/1999/xhtml\"\n\nmodule.exports = DOMElement\n\nfunction DOMElement(tagName, owner, namespace) {\n    if (!(this instanceof DOMElement)) {\n        return new DOMElement(tagName)\n    }\n\n    var ns = namespace === undefined ? htmlns : (namespace || null)\n\n    this.tagName = ns === htmlns ? String(tagName).toUpperCase() : tagName\n    this.nodeName = this.tagName\n    this.className = \"\"\n    this.dataset = {}\n    this.childNodes = []\n    this.parentNode = null\n    this.style = {}\n    this.ownerDocument = owner || null\n    this.namespaceURI = ns\n    this._attributes = {}\n\n    if (this.tagName === 'INPUT') {\n      this.type = 'text'\n    }\n}\n\nDOMElement.prototype.type = \"DOMElement\"\nDOMElement.prototype.nodeType = 1\n\nDOMElement.prototype.appendChild = function _Element_appendChild(child) {\n    if (child.parentNode) {\n        child.parentNode.removeChild(child)\n    }\n\n    this.childNodes.push(child)\n    child.parentNode = this\n\n    return child\n}\n\nDOMElement.prototype.replaceChild =\n    function _Element_replaceChild(elem, needle) {\n        // TODO: Throw NotFoundError if needle.parentNode !== this\n\n        if (elem.parentNode) {\n            elem.parentNode.removeChild(elem)\n        }\n\n        var index = this.childNodes.indexOf(needle)\n\n        needle.parentNode = null\n        this.childNodes[index] = elem\n        elem.parentNode = this\n\n        return needle\n    }\n\nDOMElement.prototype.removeChild = function _Element_removeChild(elem) {\n    // TODO: Throw NotFoundError if elem.parentNode !== this\n\n    var index = this.childNodes.indexOf(elem)\n    this.childNodes.splice(index, 1)\n\n    elem.parentNode = null\n    return elem\n}\n\nDOMElement.prototype.insertBefore =\n    function _Element_insertBefore(elem, needle) {\n        // TODO: Throw NotFoundError if referenceElement is a dom node\n        // and parentNode !== this\n\n        if (elem.parentNode) {\n            elem.parentNode.removeChild(elem)\n        }\n\n        var index = needle === null || needle === undefined ?\n            -1 :\n            this.childNodes.indexOf(needle)\n\n        if (index > -1) {\n            this.childNodes.splice(index, 0, elem)\n        } else {\n            this.childNodes.push(elem)\n        }\n\n        elem.parentNode = this\n        return elem\n    }\n\nDOMElement.prototype.setAttributeNS =\n    function _Element_setAttributeNS(namespace, name, value) {\n        var prefix = null\n        var localName = name\n        var colonPosition = name.indexOf(\":\")\n        if (colonPosition > -1) {\n            prefix = name.substr(0, colonPosition)\n            localName = name.substr(colonPosition + 1)\n        }\n        if (this.tagName === 'INPUT' && name === 'type') {\n          this.type = value;\n        }\n        else {\n          var attributes = this._attributes[namespace] || (this._attributes[namespace] = {})\n          attributes[localName] = {value: value, prefix: prefix}\n        }\n    }\n\nDOMElement.prototype.getAttributeNS =\n    function _Element_getAttributeNS(namespace, name) {\n        var attributes = this._attributes[namespace];\n        var value = attributes && attributes[name] && attributes[name].value\n        if (this.tagName === 'INPUT' && name === 'type') {\n          return this.type;\n        }\n        if (typeof value !== \"string\") {\n            return null\n        }\n        return value\n    }\n\nDOMElement.prototype.removeAttributeNS =\n    function _Element_removeAttributeNS(namespace, name) {\n        var attributes = this._attributes[namespace];\n        if (attributes) {\n            delete attributes[name]\n        }\n    }\n\nDOMElement.prototype.hasAttributeNS =\n    function _Element_hasAttributeNS(namespace, name) {\n        var attributes = this._attributes[namespace]\n        return !!attributes && name in attributes;\n    }\n\nDOMElement.prototype.setAttribute = function _Element_setAttribute(name, value) {\n    return this.setAttributeNS(null, name, value)\n}\n\nDOMElement.prototype.getAttribute = function _Element_getAttribute(name) {\n    return this.getAttributeNS(null, name)\n}\n\nDOMElement.prototype.removeAttribute = function _Element_removeAttribute(name) {\n    return this.removeAttributeNS(null, name)\n}\n\nDOMElement.prototype.hasAttribute = function _Element_hasAttribute(name) {\n    return this.hasAttributeNS(null, name)\n}\n\nDOMElement.prototype.removeEventListener = removeEventListener\nDOMElement.prototype.addEventListener = addEventListener\nDOMElement.prototype.dispatchEvent = dispatchEvent\n\n// Un-implemented\nDOMElement.prototype.focus = function _Element_focus() {\n    return void 0\n}\n\nDOMElement.prototype.toString = function _Element_toString() {\n    return serializeNode(this)\n}\n\nDOMElement.prototype.getElementsByClassName = function _Element_getElementsByClassName(classNames) {\n    var classes = classNames.split(\" \");\n    var elems = []\n\n    domWalk(this, function (node) {\n        if (node.nodeType === 1) {\n            var nodeClassName = node.className || \"\"\n            var nodeClasses = nodeClassName.split(\" \")\n\n            if (classes.every(function (item) {\n                return nodeClasses.indexOf(item) !== -1\n            })) {\n                elems.push(node)\n            }\n        }\n    })\n\n    return elems\n}\n\nDOMElement.prototype.getElementsByTagName = function _Element_getElementsByTagName(tagName) {\n    tagName = tagName.toLowerCase()\n    var elems = []\n\n    domWalk(this.childNodes, function (node) {\n        if (node.nodeType === 1 && (tagName === '*' || node.tagName.toLowerCase() === tagName)) {\n            elems.push(node)\n        }\n    })\n\n    return elems\n}\n\nDOMElement.prototype.contains = function _Element_contains(element) {\n    return domWalk(this, function (node) {\n        return element === node\n    }) || false\n}\n","var DOMElement = require(\"./dom-element.js\")\n\nmodule.exports = DocumentFragment\n\nfunction DocumentFragment(owner) {\n    if (!(this instanceof DocumentFragment)) {\n        return new DocumentFragment()\n    }\n\n    this.childNodes = []\n    this.parentNode = null\n    this.ownerDocument = owner || null\n}\n\nDocumentFragment.prototype.type = \"DocumentFragment\"\nDocumentFragment.prototype.nodeType = 11\nDocumentFragment.prototype.nodeName = \"#document-fragment\"\n\nDocumentFragment.prototype.appendChild  = DOMElement.prototype.appendChild\nDocumentFragment.prototype.replaceChild = DOMElement.prototype.replaceChild\nDocumentFragment.prototype.removeChild  = DOMElement.prototype.removeChild\n\nDocumentFragment.prototype.toString =\n    function _DocumentFragment_toString() {\n        return this.childNodes.map(function (node) {\n            return String(node)\n        }).join(\"\")\n    }\n","module.exports = Event\n\nfunction Event(family) {}\n\nEvent.prototype.initEvent = function _Event_initEvent(type, bubbles, cancelable) {\n    this.type = type\n    this.bubbles = bubbles\n    this.cancelable = cancelable\n}\n\nEvent.prototype.preventDefault = function _Event_preventDefault() {\n    \n}\n","var domWalk = require(\"dom-walk\")\n\nvar Comment = require(\"./dom-comment.js\")\nvar DOMText = require(\"./dom-text.js\")\nvar DOMElement = require(\"./dom-element.js\")\nvar DocumentFragment = require(\"./dom-fragment.js\")\nvar Event = require(\"./event.js\")\nvar dispatchEvent = require(\"./event/dispatch-event.js\")\nvar addEventListener = require(\"./event/add-event-listener.js\")\nvar removeEventListener = require(\"./event/remove-event-listener.js\")\n\nmodule.exports = Document;\n\nfunction Document() {\n    if (!(this instanceof Document)) {\n        return new Document();\n    }\n\n    this.head = this.createElement(\"head\")\n    this.body = this.createElement(\"body\")\n    this.documentElement = this.createElement(\"html\")\n    this.documentElement.appendChild(this.head)\n    this.documentElement.appendChild(this.body)\n    this.childNodes = [this.documentElement]\n    this.nodeType = 9\n}\n\nvar proto = Document.prototype;\nproto.createTextNode = function createTextNode(value) {\n    return new DOMText(value, this)\n}\n\nproto.createElementNS = function createElementNS(namespace, tagName) {\n    var ns = namespace === null ? null : String(namespace)\n    return new DOMElement(tagName, this, ns)\n}\n\nproto.createElement = function createElement(tagName) {\n    return new DOMElement(tagName, this)\n}\n\nproto.createDocumentFragment = function createDocumentFragment() {\n    return new DocumentFragment(this)\n}\n\nproto.createEvent = function createEvent(family) {\n    return new Event(family)\n}\n\nproto.createComment = function createComment(data) {\n    return new Comment(data, this)\n}\n\nproto.getElementById = function getElementById(id) {\n    id = String(id)\n\n    var result = domWalk(this.childNodes, function (node) {\n        if (String(node.id) === id) {\n            return node\n        }\n    })\n\n    return result || null\n}\n\nproto.getElementsByClassName = DOMElement.prototype.getElementsByClassName\nproto.getElementsByTagName = DOMElement.prototype.getElementsByTagName\nproto.contains = DOMElement.prototype.contains\n\nproto.removeEventListener = removeEventListener\nproto.addEventListener = addEventListener\nproto.dispatchEvent = dispatchEvent\n","var isObject = require(\"is-object\")\nvar isHook = require(\"../vnode/is-vhook.js\")\n\nmodule.exports = applyProperties\n\nfunction applyProperties(node, props, previous) {\n    for (var propName in props) {\n        var propValue = props[propName]\n\n        if (propValue === undefined) {\n            removeProperty(node, propName, propValue, previous);\n        } else if (isHook(propValue)) {\n            removeProperty(node, propName, propValue, previous)\n            if (propValue.hook) {\n                propValue.hook(node,\n                    propName,\n                    previous ? previous[propName] : undefined)\n            }\n        } else {\n            if (isObject(propValue)) {\n                patchObject(node, props, previous, propName, propValue);\n            } else {\n                node[propName] = propValue\n            }\n        }\n    }\n}\n\nfunction removeProperty(node, propName, propValue, previous) {\n    if (previous) {\n        var previousValue = previous[propName]\n\n        if (!isHook(previousValue)) {\n            if (propName === \"attributes\") {\n                for (var attrName in previousValue) {\n                    node.removeAttribute(attrName)\n                }\n            } else if (propName === \"style\") {\n                for (var i in previousValue) {\n                    node.style[i] = \"\"\n                }\n            } else if (typeof previousValue === \"string\") {\n                node[propName] = \"\"\n            } else {\n                node[propName] = null\n            }\n        } else if (previousValue.unhook) {\n            previousValue.unhook(node, propName, propValue)\n        }\n    }\n}\n\nfunction patchObject(node, props, previous, propName, propValue) {\n    var previousValue = previous ? previous[propName] : undefined\n\n    // Set attributes\n    if (propName === \"attributes\") {\n        for (var attrName in propValue) {\n            var attrValue = propValue[attrName]\n\n            if (attrValue === undefined) {\n                node.removeAttribute(attrName)\n            } else {\n                node.setAttribute(attrName, attrValue)\n            }\n        }\n\n        return\n    }\n\n    if(previousValue && isObject(previousValue) &&\n        getPrototype(previousValue) !== getPrototype(propValue)) {\n        node[propName] = propValue\n        return\n    }\n\n    if (!isObject(node[propName])) {\n        node[propName] = {}\n    }\n\n    var replacer = propName === \"style\" ? \"\" : undefined\n\n    for (var k in propValue) {\n        var value = propValue[k]\n        node[propName][k] = (value === undefined) ? replacer : value\n    }\n}\n\nfunction getPrototype(value) {\n    if (Object.getPrototypeOf) {\n        return Object.getPrototypeOf(value)\n    } else if (value.__proto__) {\n        return value.__proto__\n    } else if (value.constructor) {\n        return value.constructor.prototype\n    }\n}\n","var document = require(\"global/document\")\n\nvar applyProperties = require(\"./apply-properties\")\n\nvar isVNode = require(\"../vnode/is-vnode.js\")\nvar isVText = require(\"../vnode/is-vtext.js\")\nvar isWidget = require(\"../vnode/is-widget.js\")\nvar handleThunk = require(\"../vnode/handle-thunk.js\")\n\nmodule.exports = createElement\n\nfunction createElement(vnode, opts) {\n    var doc = opts ? opts.document || document : document\n    var warn = opts ? opts.warn : null\n\n    vnode = handleThunk(vnode).a\n\n    if (isWidget(vnode)) {\n        return vnode.init()\n    } else if (isVText(vnode)) {\n        return doc.createTextNode(vnode.text)\n    } else if (!isVNode(vnode)) {\n        if (warn) {\n            warn(\"Item is not a valid virtual dom node\", vnode)\n        }\n        return null\n    }\n\n    var node = (vnode.namespace === null) ?\n        doc.createElement(vnode.tagName) :\n        doc.createElementNS(vnode.namespace, vnode.tagName)\n\n    var props = vnode.properties\n    applyProperties(node, props)\n\n    var children = vnode.children\n\n    for (var i = 0; i < children.length; i++) {\n        var childNode = createElement(children[i], opts)\n        if (childNode) {\n            node.appendChild(childNode)\n        }\n    }\n\n    return node\n}\n","// Maps a virtual DOM tree onto a real DOM tree in an efficient manner.\n// We don't want to read all of the DOM nodes in the tree so we use\n// the in-order tree indexing to eliminate recursion down certain branches.\n// We only recurse into a DOM node if we know that it contains a child of\n// interest.\n\nvar noChild = {}\n\nmodule.exports = domIndex\n\nfunction domIndex(rootNode, tree, indices, nodes) {\n    if (!indices || indices.length === 0) {\n        return {}\n    } else {\n        indices.sort(ascending)\n        return recurse(rootNode, tree, indices, nodes, 0)\n    }\n}\n\nfunction recurse(rootNode, tree, indices, nodes, rootIndex) {\n    nodes = nodes || {}\n\n\n    if (rootNode) {\n        if (indexInRange(indices, rootIndex, rootIndex)) {\n            nodes[rootIndex] = rootNode\n        }\n\n        var vChildren = tree.children\n\n        if (vChildren) {\n\n            var childNodes = rootNode.childNodes\n\n            for (var i = 0; i < tree.children.length; i++) {\n                rootIndex += 1\n\n                var vChild = vChildren[i] || noChild\n                var nextIndex = rootIndex + (vChild.count || 0)\n\n                // skip recursion down the tree if there are no nodes down here\n                if (indexInRange(indices, rootIndex, nextIndex)) {\n                    recurse(childNodes[i], vChild, indices, nodes, rootIndex)\n                }\n\n                rootIndex = nextIndex\n            }\n        }\n    }\n\n    return nodes\n}\n\n// Binary search for an index in the interval [left, right]\nfunction indexInRange(indices, left, right) {\n    if (indices.length === 0) {\n        return false\n    }\n\n    var minIndex = 0\n    var maxIndex = indices.length - 1\n    var currentIndex\n    var currentItem\n\n    while (minIndex <= maxIndex) {\n        currentIndex = ((maxIndex + minIndex) / 2) >> 0\n        currentItem = indices[currentIndex]\n\n        if (minIndex === maxIndex) {\n            return currentItem >= left && currentItem <= right\n        } else if (currentItem < left) {\n            minIndex = currentIndex + 1\n        } else  if (currentItem > right) {\n            maxIndex = currentIndex - 1\n        } else {\n            return true\n        }\n    }\n\n    return false;\n}\n\nfunction ascending(a, b) {\n    return a > b ? 1 : -1\n}\n","var isWidget = require(\"../vnode/is-widget.js\")\n\nmodule.exports = updateWidget\n\nfunction updateWidget(a, b) {\n    if (isWidget(a) && isWidget(b)) {\n        if (\"name\" in a && \"name\" in b) {\n            return a.id === b.id\n        } else {\n            return a.init === b.init\n        }\n    }\n\n    return false\n}\n","var applyProperties = require(\"./apply-properties\")\n\nvar isWidget = require(\"../vnode/is-widget.js\")\nvar VPatch = require(\"../vnode/vpatch.js\")\n\nvar updateWidget = require(\"./update-widget\")\n\nmodule.exports = applyPatch\n\nfunction applyPatch(vpatch, domNode, renderOptions) {\n    var type = vpatch.type\n    var vNode = vpatch.vNode\n    var patch = vpatch.patch\n\n    switch (type) {\n        case VPatch.REMOVE:\n            return removeNode(domNode, vNode)\n        case VPatch.INSERT:\n            return insertNode(domNode, patch, renderOptions)\n        case VPatch.VTEXT:\n            return stringPatch(domNode, vNode, patch, renderOptions)\n        case VPatch.WIDGET:\n            return widgetPatch(domNode, vNode, patch, renderOptions)\n        case VPatch.VNODE:\n            return vNodePatch(domNode, vNode, patch, renderOptions)\n        case VPatch.ORDER:\n            reorderChildren(domNode, patch)\n            return domNode\n        case VPatch.PROPS:\n            applyProperties(domNode, patch, vNode.properties)\n            return domNode\n        case VPatch.THUNK:\n            return replaceRoot(domNode,\n                renderOptions.patch(domNode, patch, renderOptions))\n        default:\n            return domNode\n    }\n}\n\nfunction removeNode(domNode, vNode) {\n    var parentNode = domNode.parentNode\n\n    if (parentNode) {\n        parentNode.removeChild(domNode)\n    }\n\n    destroyWidget(domNode, vNode);\n\n    return null\n}\n\nfunction insertNode(parentNode, vNode, renderOptions) {\n    var newNode = renderOptions.render(vNode, renderOptions)\n\n    if (parentNode) {\n        parentNode.appendChild(newNode)\n    }\n\n    return parentNode\n}\n\nfunction stringPatch(domNode, leftVNode, vText, renderOptions) {\n    var newNode\n\n    if (domNode.nodeType === 3) {\n        domNode.replaceData(0, domNode.length, vText.text)\n        newNode = domNode\n    } else {\n        var parentNode = domNode.parentNode\n        newNode = renderOptions.render(vText, renderOptions)\n\n        if (parentNode && newNode !== domNode) {\n            parentNode.replaceChild(newNode, domNode)\n        }\n    }\n\n    return newNode\n}\n\nfunction widgetPatch(domNode, leftVNode, widget, renderOptions) {\n    var updating = updateWidget(leftVNode, widget)\n    var newNode\n\n    if (updating) {\n        newNode = widget.update(leftVNode, domNode) || domNode\n    } else {\n        newNode = renderOptions.render(widget, renderOptions)\n    }\n\n    var parentNode = domNode.parentNode\n\n    if (parentNode && newNode !== domNode) {\n        parentNode.replaceChild(newNode, domNode)\n    }\n\n    if (!updating) {\n        destroyWidget(domNode, leftVNode)\n    }\n\n    return newNode\n}\n\nfunction vNodePatch(domNode, leftVNode, vNode, renderOptions) {\n    var parentNode = domNode.parentNode\n    var newNode = renderOptions.render(vNode, renderOptions)\n\n    if (parentNode && newNode !== domNode) {\n        parentNode.replaceChild(newNode, domNode)\n    }\n\n    return newNode\n}\n\nfunction destroyWidget(domNode, w) {\n    if (typeof w.destroy === \"function\" && isWidget(w)) {\n        w.destroy(domNode)\n    }\n}\n\nfunction reorderChildren(domNode, moves) {\n    var childNodes = domNode.childNodes\n    var keyMap = {}\n    var node\n    var remove\n    var insert\n\n    for (var i = 0; i < moves.removes.length; i++) {\n        remove = moves.removes[i]\n        node = childNodes[remove.from]\n        if (remove.key) {\n            keyMap[remove.key] = node\n        }\n        domNode.removeChild(node)\n    }\n\n    var length = childNodes.length\n    for (var j = 0; j < moves.inserts.length; j++) {\n        insert = moves.inserts[j]\n        node = keyMap[insert.key]\n        // this is the weirdest bug i've ever seen in webkit\n        domNode.insertBefore(node, insert.to >= length++ ? null : childNodes[insert.to])\n    }\n}\n\nfunction replaceRoot(oldRoot, newRoot) {\n    if (oldRoot && newRoot && oldRoot !== newRoot && oldRoot.parentNode) {\n        oldRoot.parentNode.replaceChild(newRoot, oldRoot)\n    }\n\n    return newRoot;\n}\n","var document = require(\"global/document\")\nvar isArray = require(\"x-is-array\")\n\nvar render = require(\"./create-element\")\nvar domIndex = require(\"./dom-index\")\nvar patchOp = require(\"./patch-op\")\nmodule.exports = patch\n\nfunction patch(rootNode, patches, renderOptions) {\n    renderOptions = renderOptions || {}\n    renderOptions.patch = renderOptions.patch && renderOptions.patch !== patch\n        ? renderOptions.patch\n        : patchRecursive\n    renderOptions.render = renderOptions.render || render\n\n    return renderOptions.patch(rootNode, patches, renderOptions)\n}\n\nfunction patchRecursive(rootNode, patches, renderOptions) {\n    var indices = patchIndices(patches)\n\n    if (indices.length === 0) {\n        return rootNode\n    }\n\n    var index = domIndex(rootNode, patches.a, indices)\n    var ownerDocument = rootNode.ownerDocument\n\n    if (!renderOptions.document && ownerDocument !== document) {\n        renderOptions.document = ownerDocument\n    }\n\n    for (var i = 0; i < indices.length; i++) {\n        var nodeIndex = indices[i]\n        rootNode = applyPatch(rootNode,\n            index[nodeIndex],\n            patches[nodeIndex],\n            renderOptions)\n    }\n\n    return rootNode\n}\n\nfunction applyPatch(rootNode, domNode, patchList, renderOptions) {\n    if (!domNode) {\n        return rootNode\n    }\n\n    var newNode\n\n    if (isArray(patchList)) {\n        for (var i = 0; i < patchList.length; i++) {\n            newNode = patchOp(patchList[i], domNode, renderOptions)\n\n            if (domNode === rootNode) {\n                rootNode = newNode\n            }\n        }\n    } else {\n        newNode = patchOp(patchList, domNode, renderOptions)\n\n        if (domNode === rootNode) {\n            rootNode = newNode\n        }\n    }\n\n    return rootNode\n}\n\nfunction patchIndices(patches) {\n    var indices = []\n\n    for (var key in patches) {\n        if (key !== \"a\") {\n            indices.push(Number(key))\n        }\n    }\n\n    return indices\n}\n","var version = require(\"./version\")\nvar isVNode = require(\"./is-vnode\")\nvar isWidget = require(\"./is-widget\")\nvar isThunk = require(\"./is-thunk\")\nvar isVHook = require(\"./is-vhook\")\n\nmodule.exports = VirtualNode\n\nvar noProperties = {}\nvar noChildren = []\n\nfunction VirtualNode(tagName, properties, children, key, namespace) {\n    this.tagName = tagName\n    this.properties = properties || noProperties\n    this.children = children || noChildren\n    this.key = key != null ? String(key) : undefined\n    this.namespace = (typeof namespace === \"string\") ? namespace : null\n\n    var count = (children && children.length) || 0\n    var descendants = 0\n    var hasWidgets = false\n    var hasThunks = false\n    var descendantHooks = false\n    var hooks\n\n    for (var propName in properties) {\n        if (properties.hasOwnProperty(propName)) {\n            var property = properties[propName]\n            if (isVHook(property) && property.unhook) {\n                if (!hooks) {\n                    hooks = {}\n                }\n\n                hooks[propName] = property\n            }\n        }\n    }\n\n    for (var i = 0; i < count; i++) {\n        var child = children[i]\n        if (isVNode(child)) {\n            descendants += child.count || 0\n\n            if (!hasWidgets && child.hasWidgets) {\n                hasWidgets = true\n            }\n\n            if (!hasThunks && child.hasThunks) {\n                hasThunks = true\n            }\n\n            if (!descendantHooks && (child.hooks || child.descendantHooks)) {\n                descendantHooks = true\n            }\n        } else if (!hasWidgets && isWidget(child)) {\n            if (typeof child.destroy === \"function\") {\n                hasWidgets = true\n            }\n        } else if (!hasThunks && isThunk(child)) {\n            hasThunks = true;\n        }\n    }\n\n    this.count = count + descendants\n    this.hasWidgets = hasWidgets\n    this.hasThunks = hasThunks\n    this.hooks = hooks\n    this.descendantHooks = descendantHooks\n}\n\nVirtualNode.prototype.version = version\nVirtualNode.prototype.type = \"VirtualNode\"\n","var version = require(\"./version\")\n\nmodule.exports = VirtualText\n\nfunction VirtualText(text) {\n    this.text = String(text)\n}\n\nVirtualText.prototype.version = version\nVirtualText.prototype.type = \"VirtualText\"\n","'use strict';\n\nvar split = require('browser-split');\n\nvar classIdSplit = /([\\.#]?[a-zA-Z0-9\\u007F-\\uFFFF_:-]+)/;\nvar notClassId = /^\\.|#/;\n\nmodule.exports = parseTag;\n\nfunction parseTag(tag, props) {\n    if (!tag) {\n        return 'DIV';\n    }\n\n    var noId = !(props.hasOwnProperty('id'));\n\n    var tagParts = split(tag, classIdSplit);\n    var tagName = null;\n\n    if (notClassId.test(tagParts[1])) {\n        tagName = 'DIV';\n    }\n\n    var classes, part, type, i;\n\n    for (i = 0; i < tagParts.length; i++) {\n        part = tagParts[i];\n\n        if (!part) {\n            continue;\n        }\n\n        type = part.charAt(0);\n\n        if (!tagName) {\n            tagName = part;\n        } else if (type === '.') {\n            classes = classes || [];\n            classes.push(part.substring(1, part.length));\n        } else if (type === '#' && noId) {\n            props.id = part.substring(1, part.length);\n        }\n    }\n\n    if (classes) {\n        if (props.className) {\n            classes.push(props.className);\n        }\n\n        props.className = classes.join(' ');\n    }\n\n    return props.namespace ? tagName : tagName.toUpperCase();\n}\n","'use strict';\n\nmodule.exports = SoftSetHook;\n\nfunction SoftSetHook(value) {\n    if (!(this instanceof SoftSetHook)) {\n        return new SoftSetHook(value);\n    }\n\n    this.value = value;\n}\n\nSoftSetHook.prototype.hook = function (node, propertyName) {\n    if (node[propertyName] !== this.value) {\n        node[propertyName] = this.value;\n    }\n};\n","'use strict';\n\n/*global window, global*/\n\nvar root = typeof window !== 'undefined' ?\n    window : typeof global !== 'undefined' ?\n    global : {};\n\nmodule.exports = Individual;\n\nfunction Individual(key, value) {\n    if (key in root) {\n        return root[key];\n    }\n\n    root[key] = value;\n\n    return value;\n}\n","'use strict';\n\nvar Individual = require('./index.js');\n\nmodule.exports = OneVersion;\n\nfunction OneVersion(moduleName, version, defaultValue) {\n    var key = '__INDIVIDUAL_ONE_VERSION_' + moduleName;\n    var enforceKey = key + '_ENFORCE_SINGLETON';\n\n    var versionValue = Individual(enforceKey, version);\n\n    if (versionValue !== version) {\n        throw new Error('Can only have one copy of ' +\n            moduleName + '.\\n' +\n            'You already have version ' + versionValue +\n            ' installed.\\n' +\n            'This means you cannot install version ' + version);\n    }\n\n    return Individual(key, defaultValue);\n}\n","'use strict';\n\nvar OneVersionConstraint = require('individual/one-version');\n\nvar MY_VERSION = '7';\nOneVersionConstraint('ev-store', MY_VERSION);\n\nvar hashKey = '__EV_STORE_KEY@' + MY_VERSION;\n\nmodule.exports = EvStore;\n\nfunction EvStore(elem) {\n    var hash = elem[hashKey];\n\n    if (!hash) {\n        hash = elem[hashKey] = {};\n    }\n\n    return hash;\n}\n","'use strict';\n\nvar EvStore = require('ev-store');\n\nmodule.exports = EvHook;\n\nfunction EvHook(value) {\n    if (!(this instanceof EvHook)) {\n        return new EvHook(value);\n    }\n\n    this.value = value;\n}\n\nEvHook.prototype.hook = function (node, propertyName) {\n    var es = EvStore(node);\n    var propName = propertyName.substr(3);\n\n    es[propName] = this.value;\n};\n\nEvHook.prototype.unhook = function(node, propertyName) {\n    var es = EvStore(node);\n    var propName = propertyName.substr(3);\n\n    es[propName] = undefined;\n};\n","'use strict';\n\nvar isArray = require('x-is-array');\n\nvar VNode = require('../vnode/vnode.js');\nvar VText = require('../vnode/vtext.js');\nvar isVNode = require('../vnode/is-vnode');\nvar isVText = require('../vnode/is-vtext');\nvar isWidget = require('../vnode/is-widget');\nvar isHook = require('../vnode/is-vhook');\nvar isVThunk = require('../vnode/is-thunk');\n\nvar parseTag = require('./parse-tag.js');\nvar softSetHook = require('./hooks/soft-set-hook.js');\nvar evHook = require('./hooks/ev-hook.js');\n\nmodule.exports = h;\n\nfunction h(tagName, properties, children) {\n    var childNodes = [];\n    var tag, props, key, namespace;\n\n    if (!children && isChildren(properties)) {\n        children = properties;\n        props = {};\n    }\n\n    props = props || properties || {};\n    tag = parseTag(tagName, props);\n\n    // support keys\n    if (props.hasOwnProperty('key')) {\n        key = props.key;\n        props.key = undefined;\n    }\n\n    // support namespace\n    if (props.hasOwnProperty('namespace')) {\n        namespace = props.namespace;\n        props.namespace = undefined;\n    }\n\n    // fix cursor bug\n    if (tag === 'INPUT' &&\n        !namespace &&\n        props.hasOwnProperty('value') &&\n        props.value !== undefined &&\n        !isHook(props.value)\n    ) {\n        props.value = softSetHook(props.value);\n    }\n\n    transformProperties(props);\n\n    if (children !== undefined && children !== null) {\n        addChild(children, childNodes, tag, props);\n    }\n\n\n    return new VNode(tag, props, childNodes, key, namespace);\n}\n\nfunction addChild(c, childNodes, tag, props) {\n    if (typeof c === 'string') {\n        childNodes.push(new VText(c));\n    } else if (typeof c === 'number') {\n        childNodes.push(new VText(String(c)));\n    } else if (isChild(c)) {\n        childNodes.push(c);\n    } else if (isArray(c)) {\n        for (var i = 0; i < c.length; i++) {\n            addChild(c[i], childNodes, tag, props);\n        }\n    } else if (c === null || c === undefined) {\n        return;\n    } else {\n        throw UnexpectedVirtualElement({\n            foreignObject: c,\n            parentVnode: {\n                tagName: tag,\n                properties: props\n            }\n        });\n    }\n}\n\nfunction transformProperties(props) {\n    for (var propName in props) {\n        if (props.hasOwnProperty(propName)) {\n            var value = props[propName];\n\n            if (isHook(value)) {\n                continue;\n            }\n\n            if (propName.substr(0, 3) === 'ev-') {\n                // add ev-foo support\n                props[propName] = evHook(value);\n            }\n        }\n    }\n}\n\nfunction isChild(x) {\n    return isVNode(x) || isVText(x) || isWidget(x) || isVThunk(x);\n}\n\nfunction isChildren(x) {\n    return typeof x === 'string' || isArray(x) || isChild(x);\n}\n\nfunction UnexpectedVirtualElement(data) {\n    var err = new Error();\n\n    err.type = 'virtual-hyperscript.unexpected.virtual-element';\n    err.message = 'Unexpected virtual child passed to h().\\n' +\n        'Expected a VNode / Vthunk / VWidget / string but:\\n' +\n        'got:\\n' +\n        errorString(data.foreignObject) +\n        '.\\n' +\n        'The parent vnode is:\\n' +\n        errorString(data.parentVnode)\n        '\\n' +\n        'Suggested fix: change your `h(..., [ ... ])` callsite.';\n    err.foreignObject = data.foreignObject;\n    err.parentVnode = data.parentVnode;\n\n    return err;\n}\n\nfunction errorString(obj) {\n    try {\n        return JSON.stringify(obj, null, '    ');\n    } catch (e) {\n        return String(obj);\n    }\n}\n","import { createDisposable } from \"./Util\";\r\nimport FSymbol from \"./Symbol\";\r\nvar Observer = (function () {\r\n    function Observer(onNext, onError, onCompleted) {\r\n        this.OnNext = onNext;\r\n        this.OnError = onError || (function (e) { });\r\n        this.OnCompleted = onCompleted || function () { };\r\n    }\r\n    Observer.prototype[FSymbol.reflection] = function () {\r\n        return { interfaces: [\"System.IObserver\"] };\r\n    };\r\n    return Observer;\r\n}());\r\nexport { Observer };\r\nvar Observable = (function () {\r\n    function Observable(subscribe) {\r\n        this.Subscribe = subscribe;\r\n    }\r\n    Observable.prototype[FSymbol.reflection] = function () {\r\n        return { interfaces: [\"System.IObservable\"] };\r\n    };\r\n    return Observable;\r\n}());\r\nexport function protect(f, succeed, fail) {\r\n    try {\r\n        return succeed(f());\r\n    }\r\n    catch (e) {\r\n        fail(e);\r\n    }\r\n}\r\nexport function add(callback, source) {\r\n    source.Subscribe(new Observer(callback));\r\n}\r\nexport function choose(chooser, source) {\r\n    return new Observable(function (observer) {\r\n        return source.Subscribe(new Observer(function (t) {\r\n            return protect(function () { return chooser(t); }, function (u) { if (u != null)\r\n                observer.OnNext(u); }, observer.OnError);\r\n        }, observer.OnError, observer.OnCompleted));\r\n    });\r\n}\r\nexport function filter(predicate, source) {\r\n    return choose(function (x) { return predicate(x) ? x : null; }, source);\r\n}\r\nexport function map(mapping, source) {\r\n    return new Observable(function (observer) {\r\n        return source.Subscribe(new Observer(function (t) {\r\n            protect(function () { return mapping(t); }, observer.OnNext, observer.OnError);\r\n        }, observer.OnError, observer.OnCompleted));\r\n    });\r\n}\r\nexport function merge(source1, source2) {\r\n    return new Observable(function (observer) {\r\n        var stopped = false, completed1 = false, completed2 = false;\r\n        var h1 = source1.Subscribe(new Observer(function (v) { if (!stopped)\r\n            observer.OnNext(v); }, function (e) {\r\n            if (!stopped) {\r\n                stopped = true;\r\n                observer.OnError(e);\r\n            }\r\n        }, function () {\r\n            if (!stopped) {\r\n                completed1 = true;\r\n                if (completed2) {\r\n                    stopped = true;\r\n                    observer.OnCompleted();\r\n                }\r\n            }\r\n        }));\r\n        var h2 = source2.Subscribe(new Observer(function (v) { if (!stopped) {\r\n            observer.OnNext(v);\r\n        } }, function (e) {\r\n            if (!stopped) {\r\n                stopped = true;\r\n                observer.OnError(e);\r\n            }\r\n        }, function () {\r\n            if (!stopped) {\r\n                completed2 = true;\r\n                if (completed1) {\r\n                    stopped = true;\r\n                    observer.OnCompleted();\r\n                }\r\n            }\r\n        }));\r\n        return createDisposable(function () {\r\n            h1.Dispose();\r\n            h2.Dispose();\r\n        });\r\n    });\r\n}\r\nexport function pairwise(source) {\r\n    return new Observable(function (observer) {\r\n        var last = null;\r\n        return source.Subscribe(new Observer(function (next) {\r\n            if (last != null)\r\n                observer.OnNext([last, next]);\r\n            last = next;\r\n        }, observer.OnError, observer.OnCompleted));\r\n    });\r\n}\r\nexport function partition(predicate, source) {\r\n    return [filter(predicate, source), filter(function (x) { return !predicate(x); }, source)];\r\n}\r\nexport function scan(collector, state, source) {\r\n    return new Observable(function (observer) {\r\n        return source.Subscribe(new Observer(function (t) {\r\n            protect(function () { return collector(state, t); }, function (u) { state = u; observer.OnNext(u); }, observer.OnError);\r\n        }, observer.OnError, observer.OnCompleted));\r\n    });\r\n}\r\nexport function split(splitter, source) {\r\n    return [choose(function (v) { return splitter(v).valueIfChoice1; }, source), choose(function (v) { return splitter(v).valueIfChoice2; }, source)];\r\n}\r\nexport function subscribe(callback, source) {\r\n    return source.Subscribe(new Observer(callback));\r\n}\r\n","﻿module TheGamma.Html\n\nopen Fable.Core\nopen Fable.Helpers\nopen Fable.Import.Browser\nopen Fable.Core.JsInterop\nopen TheGamma.Common\n\nmodule FsOption = FSharp.Core.Option\n\n[<Fable.Core.Emit(\"jQuery($0).chosen()\")>]\nlet private chosen (el:HTMLElement) : unit = failwith \"JS\"\n\n[<Fable.Core.Emit(\"jQuery($0).on($1, $2)\")>]\nlet private on (el:HTMLElement) (evt:string) (f:unit -> unit) : unit = failwith \"JS\"\n\n[<Emit(\"$0[$1]\")>]\nlet private getProperty (o:obj) (s:string) = failwith \"!\"\n\n[<Emit(\"$0[$1] = $2\")>]\nlet private setProperty (o:obj) (s:string) (v:obj) = failwith \"!\"\n\n[<Fable.Core.Emit(\"event\")>]\nlet private event () : Event = failwith \"JS\"\n\ntype DomAttribute = \n  | Event of (HTMLElement -> Event -> unit)\n  | Attribute of string\n  | Property of obj\n\ntype DomNode = \n  | Text of string\n  | Delayed of string * DomNode * (string -> unit)\n  | Element of ns:string * tag:string * attributes:(string * DomAttribute)[] * children : DomNode[] * onRender : (HTMLElement -> unit) option\n  | Part of func:(HTMLElement -> unit)\n\nlet createTree ns tag args children =\n    let attrs = ResizeArray<_>()\n    let props = ResizeArray<_>()\n    for k, v in args do\n      match k, v with \n      | k, Attribute v ->\n          attrs.Add (k, box v)\n      | k, Property o ->\n          props.Add(k, o)\n      | k, Event f ->\n          props.Add (\"on\" + k, box (fun o -> f (getProperty o \"target\") o ))\n    let attrs = JsInterop.createObj attrs\n    let ns = if ns = null || ns = \"\" then [] else [\"namespace\", box ns]\n    let props = JsInterop.createObj (Seq.append (ns @ [\"attributes\", attrs]) props)\n    let elem = Virtualdom.h(tag, props, children)\n    elem\n\nlet mutable counter = 0\n\nlet rec renderVirtual node = \n  match node with\n  | Text(s) -> \n      box s\n  | Element(ns, tag, attrs, children, None) ->\n      createTree ns tag attrs (Array.map renderVirtual children)\n  | Delayed(symbol, body, func) ->\n      counter <- counter + 1\n      let id = sprintf \"delayed_%d\" counter\n\n      // Virtual dom calls our hook when it creates HTML element, but\n      // we still need to wait until it is added to the HTML tree\n      let rec waitForAdded n (el:HTMLElement) = \n        if el.parentElement <> null then \n          el?dataset?renderedSymbol <- symbol\n          el?id <- id\n          func id\n        elif n > 0 then window.setTimeout((fun () -> waitForAdded  (n-1) el), 1) |> ignore\n        else Log.error(\"html\", \"Delayed element was not created in time\")\n\n      // Magic as per https://github.com/Matt-Es`ch/virtual-dom/blob/master/docs/hooks.md\n      let Hook = box(fun () -> ())\n      Hook?prototype?hook <- fun (node:HTMLElement) propertyName previousValue ->\n        if unbox node?dataset?renderedSymbol <> symbol then\n          waitForAdded 10 node\n      let h = createNew Hook ()\n\n      createTree null \"div\" [\"renderhk\", Property h] [| renderVirtual body |]\n  | Element _ ->\n      failwith \"renderVirtual: Does not support elements with after-render handlers\"\n  | Part _ ->\n      failwith \"renderVirtual: Does not support parts\"\n\nlet rec render node = \n  match node with\n  | Text(s) -> \n      document.createTextNode(s) :> Node, ignore\n\n  | Delayed(_, _, func) ->\n      counter <- counter + 1\n      let el = document.createElement(\"div\")\n      el.id <- sprintf \"delayed_%d\" counter\n      el :> Node, (fun () -> func el.id)\n\n  | Part(func) ->\n      let el = document.createElement(\"div\")\n      el :> Node, (fun () -> func el)\n\n  | Element(ns, tag, attrs, children, f) ->\n      let el = \n        if ns = null || ns = \"\" then document.createElement(tag)\n        else document.createElementNS(ns, tag) :?> HTMLElement\n      let rc = Array.map render children\n      for c, _ in rc do el.appendChild(c) |> ignore\n      for k, a in attrs do \n        match a with\n        | Property(o) -> setProperty el k o\n        | Attribute(v) -> el.setAttribute(k, v)\n        | Event(f) -> el.addEventListener(k, U2.Case1(EventListener(f el)))\n      let onRender () = \n        for _, f in rc do f()\n        f |> FsOption.iter (fun f -> f el)\n      el :> Node, onRender\n\nlet renderTo (node:HTMLElement) dom = \n  while box node.lastChild <> null do ignore(node.removeChild(node.lastChild))\n  let el, f = render dom\n  node.appendChild(el) |> ignore\n  f()\n\nlet createVirtualDomAsyncApp id initial r u = \n  let event = new Event<'T>()\n  let trigger e = event.Trigger(e)  \n  let mutable container = document.createElement(\"div\") :> Node\n  document.getElementById(id).innerHTML <- \"\"\n  document.getElementById(id).appendChild(container) |> ignore\n  let mutable tree = Fable.Core.JsInterop.createObj []\n  let mutable state = initial\n\n  let handleEvent evt = Async.StartImmediate <| async {\n    match evt with \n    | Some e -> \n        let! ns = u state e \n        state <- ns\n    | _ -> ()\n    let newTree = r trigger state |> renderVirtual\n    let patches = Virtualdom.diff tree newTree\n    container <- Virtualdom.patch container patches\n    tree <- newTree }\n  \n  handleEvent None\n  event.Publish.Add(Some >> handleEvent)\n\nlet createVirtualDomApp id initial r u = \n  let event = new Event<'T>()\n  let trigger e = event.Trigger(e)  \n  let mutable container = document.createElement(\"div\") :> Node\n  document.getElementById(id).innerHTML <- \"\"\n  document.getElementById(id).appendChild(container) |> ignore\n  let mutable tree = Fable.Core.JsInterop.createObj []\n  let mutable state = initial\n\n  let handleEvent evt = \n    state <- match evt with Some e -> u state e | _ -> state\n    let newTree = r trigger state |> renderVirtual\n    let patches = Virtualdom.diff tree newTree\n    container <- Virtualdom.patch container patches\n    tree <- newTree\n  \n  handleEvent None\n  event.Publish.Add(Some >> handleEvent)\n  \nlet text s = Text(s)\nlet (=>) k v = k, Attribute(v)\nlet (=!>) k f = k, Event(f)\n\n\ntype El(ns) = \n  member x.Namespace = ns\n  static member (?) (el:El, n:string) = fun a b ->\n    let n, f = \n      if n <> \"chosen\" then n, None\n      else \"select\", Some (fun el ->\n        chosen el\n        for k, v in a do\n          match v with\n          | Event f -> on el k (fun () -> f el (event()))\n          | _ -> ()\n      )\n    Element(el.Namespace, n, Array.ofList a, Array.ofList b, f)\n\n  member x.delayed sym body f =\n    Delayed(sym, body, f)\n\n  member x.part (initial:'State) (fold:'State -> 'Event -> 'State) = \n    let evt = Control.Event<_>()\n    let mutable state = initial\n    let mutable container = None\n    let mutable renderer = None\n    let render () =\n      match container, renderer with\n      | Some el, Some r -> r state |> renderTo el\n      | _ -> ()\n    evt.Publish.Add(fun e -> state <- fold state e; render ())\n\n    evt.Trigger,\n    fun (r:'State -> DomNode) ->\n      renderer <- Some r\n      Part(fun el -> \n        container <- Some el\n        render() )\n\nlet h = El(null)\nlet s = El(\"http://www.w3.org/2000/svg\")\n","﻿module TheGamma.Ast\n\n/// Create a node with given range and value\nlet node rng node =\n  { Entity = None\n    WhiteBefore = []\n    WhiteAfter = [] \n    Node = node\n    Range = rng }\n\n/// Does an identifier need escaping?\nlet needsEscaping (s:string) = \n  (s.[0] >= '0' && s.[0] <= '9') ||\n  (s.ToCharArray() |> Array.exists (fun c -> not ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9')) ))\n\n/// Escape identifier if it needs escaping\nlet escapeIdent s = \n  if s = \"\" then \"''\"\n  elif needsEscaping s then \"'\" + s + \"'\" else s\n\n/// Union ranges, assuming Start <= End for each of them\nlet unionRanges r1 r2 =\n  { Start = min r1.Start r2.Start; End = max r1.End r2.End }\n\n/// Is the first range a strict sub-range of the second range\nlet strictSubRange first second = \n  (first.Start > second.Start && first.End <= second.End) ||\n  (first.Start >= second.Start && first.End < second.End)\n\n/// Format a single token (as it looks in the soruce code)\nlet formatToken = function\n  | TokenKind.LParen -> \"(\"\n  | TokenKind.RParen -> \")\"\n  | TokenKind.Equals -> \"=\"\n  | TokenKind.Dot -> \".\"\n  | TokenKind.Comma -> \",\"\n  | TokenKind.Colon -> \":\"\n  | TokenKind.Let -> \"let\"\n  | TokenKind.LSquare -> \"[\"\n  | TokenKind.RSquare -> \"]\"\n  | TokenKind.Fun -> \"fun\"\n  | TokenKind.Arrow -> \"->\"\n  | TokenKind.Operator Operator.Modulo -> \"%\"\n  | TokenKind.Operator Operator.Divide -> \"/\"\n  | TokenKind.Operator Operator.GreaterThan -> \">\"\n  | TokenKind.Operator Operator.GreaterThanOrEqual -> \">=\"\n  | TokenKind.Operator Operator.LessThan -> \"<\"\n  | TokenKind.Operator Operator.LessThanOrEqual -> \"<=\"\n  | TokenKind.Operator Operator.Minus -> \"-\"\n  | TokenKind.Operator Operator.Multiply -> \"*\"\n  | TokenKind.Operator Operator.Plus -> \"+\"\n  | TokenKind.Operator Operator.Power -> \"^\"\n  | TokenKind.Operator Operator.Equals -> \"=\"\n  | TokenKind.Boolean true -> \"true\"\n  | TokenKind.Boolean false -> \"false\"\n  | TokenKind.Number(s, _) -> s\n  | TokenKind.String(s) -> \"\\\"\" + s.Replace(\"\\\\\", \"\\\\\\\\\").Replace(\"\\n\", \"\\\\n\").Replace(\"\\\"\", \"\\\\\\\"\") + \"\\\"\"\n  | TokenKind.Ident(i) -> i\n  | TokenKind.QIdent(q) -> \"'\" + q + \"'\"\n  | TokenKind.White(w) -> w\n  | TokenKind.Newline -> \"\\n\"\n  | TokenKind.Error(c) -> string c\n  | TokenKind.EndOfFile -> \"\"\n\n/// Return human readable description of a token\nlet formatTokenInfo = function\n  | TokenKind.LParen -> \"left parenthesis `(`\"\n  | TokenKind.RParen -> \"right parenthesis `)`\"\n  | TokenKind.Equals -> \"equals sign `=`\"\n  | TokenKind.Dot -> \"dot character `.`\"\n  | TokenKind.Comma -> \"comma character `,`\"\n  | TokenKind.Colon -> \"colon character `:`\"\n  | TokenKind.Let -> \"`let` keyword\"\n  | TokenKind.LSquare -> \"left square bracket `[`\"\n  | TokenKind.RSquare -> \"right square bracket `]`\"\n  | TokenKind.Fun -> \"`fun` keyword\"\n  | TokenKind.Arrow -> \"arrow sign `->`\"\n  | TokenKind.Operator Operator.Equals -> \"equals operator `=`\"\n  | TokenKind.Operator Operator.Divide -> \"division sign `/`\"\n  | TokenKind.Operator Operator.Modulo -> \"modulo operator `%`\"\n  | TokenKind.Operator Operator.GreaterThan -> \"greater than sign `>`\"\n  | TokenKind.Operator Operator.GreaterThanOrEqual -> \"greater than or equals sign `>=`\"\n  | TokenKind.Operator Operator.LessThan -> \"less than sign `<`\"\n  | TokenKind.Operator Operator.LessThanOrEqual -> \"less than or equals sign `<=`\"\n  | TokenKind.Operator Operator.Minus -> \"minus sign `-`\"\n  | TokenKind.Operator Operator.Multiply -> \"multiplication sign `*`\"\n  | TokenKind.Operator Operator.Plus -> \"plus sign `+`\"\n  | TokenKind.Operator Operator.Power -> \"exponentiation sign `^`\"\n  | TokenKind.Boolean true -> \"logical `true` value\"\n  | TokenKind.Boolean false -> \"logical `false` value\"\n  | TokenKind.Number(s, _) -> sprintf \"numerical value `%s`\" s\n  | TokenKind.String(s) -> sprintf \"string value `%s`\" (s.Replace(\"`\", \"'\"))\n  | TokenKind.Ident(i) -> sprintf \"identifer `%s`\" i\n  | TokenKind.QIdent(q) -> sprintf \"quoted identifer `'%s'`\" q\n  | TokenKind.White(w) -> \"whitespace\"\n  | TokenKind.Newline -> \"end of line\"\n  | TokenKind.Error('`') -> \"back-tick character\"\n  | TokenKind.Error(c) -> sprintf \"other character `%s`\" (string c)\n  | TokenKind.EndOfFile -> \"end of file\"\n\n/// Turns series of tokens into string, using their Token value\nlet formatTokens (tokens:seq<Token>) = \n  tokens |> Seq.map (fun t -> formatToken t.Token) |> String.concat \"\"\n\n/// When formatting expression, we append strings and then join them (should be fast in JS)\ntype FormattingContext = \n  { Strings : ResizeArray<string> }\n  member x.Add(tok) = x.Strings.Add(formatToken tok)\n\nlet formatNode (ctx:FormattingContext) f node =\n  for t in node.WhiteBefore do ctx.Add(t.Token)\n  f ctx node.Node\n  for t in node.WhiteAfter do ctx.Add(t.Token)\n  \nlet formatName (ctx:FormattingContext) (name:Name) = \n  if name.Name = \"\" then ()\n  elif needsEscaping name.Name then ctx.Add(TokenKind.QIdent name.Name)\n  else ctx.Add(TokenKind.Ident name.Name)\n\nlet rec formatArgument (ctx:FormattingContext) (arg:Argument) =\n  match arg.Name with \n  | Some name -> \n      formatNode ctx formatName name\n      ctx.Add(TokenKind.Equals)\n  | _ -> ()\n  formatNode ctx formatExpression arg.Value\n\n/// Format a single parsed expression, preserving the parsed whitespace\nand formatExpression (ctx:FormattingContext) expr = \n  match expr with\n  | Expr.Variable(n) -> \n      formatNode ctx formatName n\n  | Expr.Member(inst, mem) -> \n      formatNode ctx formatExpression inst\n      ctx.Add(TokenKind.Dot)\n      formatNode ctx formatExpression mem\n  | Expr.Call(inst, args) ->\n      formatNode ctx formatExpression inst\n      ctx.Add(TokenKind.LParen)\n      args |> formatNode ctx (fun ctx args -> \n        args |> List.iteri (fun i arg ->\n          if i <> 0 then ctx.Add(TokenKind.Comma)\n          formatArgument ctx arg ) )\n      ctx.Add(TokenKind.RParen)\n  | Expr.String s -> ctx.Add(TokenKind.String s)\n  | Expr.Number n -> ctx.Add(TokenKind.Number(string n, n))\n  | Expr.Boolean b -> ctx.Add(TokenKind.Boolean b)\n  | Expr.Binary(l, op, r) ->\n      formatNode ctx formatExpression l\n      op |> formatNode ctx (fun ctx op -> ctx.Add(TokenKind.Operator op))\n      formatNode ctx formatExpression r  \n  | Expr.Function(n, e) ->\n      ctx.Add(TokenKind.Fun)\n      formatNode ctx formatName n\n      ctx.Add(TokenKind.Arrow)\n      formatNode ctx formatExpression e\n  | Expr.Placeholder(n, e) ->\n      ctx.Add(TokenKind.LSquare)\n      formatNode ctx formatName n\n      ctx.Add(TokenKind.Colon)\n      formatNode ctx formatExpression e\n      ctx.Add(TokenKind.RSquare)\n  | Expr.List els ->\n      ctx.Add(TokenKind.LSquare)\n      for e in els do formatNode ctx formatExpression e\n      ctx.Add(TokenKind.RSquare)\n  | Expr.Empty -> ()\n\n/// Format a single parsed command, preserving the parsed whitespace\nlet formatCommand (ctx:FormattingContext) cmd = \n  match cmd with\n  | Command.Expr e -> \n      formatNode ctx formatExpression e\n  | Command.Let(n, e) -> \n      ctx.Add(TokenKind.Let)\n      formatNode ctx formatName n\n      ctx.Add(TokenKind.Equals)\n      formatNode ctx formatExpression e\n\n/// Format single parsed expression, preserving the parsed whitespace\nlet formatSingleExpression expr = \n  let ctx = { Strings = ResizeArray<_>() }\n  formatNode ctx formatExpression expr\n  System.String.Concat(ctx.Strings)\n\n/// Format parsed program, preserving the parsed whitespace\nlet formatProgram (prog:Program) = \n  let ctx = { Strings = ResizeArray<_>() }\n  prog.Body |> formatNode ctx (fun ctx cmds ->\n    for cmd in cmds do formatNode ctx (formatCommand) cmd)\n  System.String.Concat(ctx.Strings)\n\n/// Format all white space after the given expression\nlet formatWhiteAfterExpr nd = \n  let wa = \n    match nd.Node with \n    | Expr.Variable(n) -> n.WhiteAfter @ nd.WhiteAfter \n    | _ -> nd.WhiteAfter\n  String.concat \"\" [ for t in wa -> formatToken t.Token ]\n\n/// Format all white space before the given expression\nlet formatWhiteBeforeExpr nd = \n  let wa = \n    match nd.Node with \n    | Expr.Variable(n) -> nd.WhiteBefore @ n.WhiteBefore \n    | Expr.Member(_, m & { Node = Expr.Variable n }) -> nd.WhiteBefore @ m.WhiteBefore @ n.WhiteBefore\n    | _ -> nd.WhiteBefore\n  String.concat \"\" [ for t in wa -> formatToken t.Token ]\n\n/// Format entity kind into something readable\nlet formatEntityKind = function\n  | EntityKind.GlobalValue _ -> \"global value\"\n  | EntityKind.Variable _ -> \"variable\"\n  | EntityKind.Binding _ -> \"binding\"\n  | EntityKind.Operator(_, op, _) -> (formatToken (TokenKind.Operator op)) + \" operator\"\n  | EntityKind.List _ -> \"list\"\n  | EntityKind.Constant(Constant.Empty) -> \"empty value\"\n  | EntityKind.Constant(Constant.Number n) -> sprintf \"number `%f`\" n \n  | EntityKind.Constant(Constant.String n) -> sprintf \"string `%s`\" n \n  | EntityKind.Constant(Constant.Boolean true) -> \"`true` value\" \n  | EntityKind.Constant(Constant.Boolean false) -> \"`false` value\" \n  | EntityKind.Function _ -> \"function\"\n  | EntityKind.LetCommand _ -> \"let command\"\n  | EntityKind.RunCommand _ -> \"run command\"\n  | EntityKind.Program _ -> \"program\"\n  | EntityKind.Root _ -> \"root\"\n  | EntityKind.CallSite _ -> \"call site\"\n  | EntityKind.NamedParam _ -> \"named param\"\n  | EntityKind.Call _ -> \"call\"\n  | EntityKind.ArgumentList _ -> \"argument list\"\n  | EntityKind.Member _ -> \"member\"\n  | EntityKind.MemberAccess _ -> \"member access\"\n  | EntityKind.MemberName _ -> \"member name\"\n  | EntityKind.Placeholder _ -> \"placeholder\"\n\n/// Return entity name (or anonymous) and all its antecedants\nlet rec entityCodeNameAndAntecedents = function\n  | EntityKind.Root -> 0, [], \"<root>\"\n  | EntityKind.Program(ans) -> 1, ans, \"<program>\"\n  | EntityKind.RunCommand(an) -> 2, [an], \"<do>\"\n  | EntityKind.LetCommand(an1, an2) -> 3, [an1; an2], \"<let>\"\n  | EntityKind.Operator(an1, op, an2) -> 4, [an1; an2], (formatToken (TokenKind.Operator op))\n  | EntityKind.List(ans) -> 5, ans, \"<list>\"\n  | EntityKind.Constant(Constant.String s) -> 6, [], s\n  | EntityKind.Constant(Constant.Number n) -> 7, [], (string n)\n  | EntityKind.Constant(Constant.Boolean b) -> 8, [], (string b)\n  | EntityKind.Constant(Constant.Empty) -> 9, [], \"<empty>\"\n  | EntityKind.Function(an1, an2) -> 10, [an1; an2], \"<function>\"\n  | EntityKind.GlobalValue(n, _) -> 11, [], n.Name\n  | EntityKind.Variable(n, an) -> 12, [an], n.Name\n  | EntityKind.Binding(n, an) -> 13, [an], n.Name\n  | EntityKind.ArgumentList(ans) -> 14, ans, \"<args>\"\n  | EntityKind.Call(an1, an2) -> 15, [an1; an2], \"<call>\"\n  | EntityKind.Member(an1, an2) -> 16, [an1; an2], \"<member>\"\n  | EntityKind.MemberAccess(an) -> 17, [an], \"<member access>\"\n  | EntityKind.NamedParam(n, an) -> 18, [an], n.Name\n  | EntityKind.Placeholder(n, an) -> 19, [an], n.Name\n  | EntityKind.CallSite(an, Choice1Of2 s) -> 20, [an], s\n  | EntityKind.CallSite(an, Choice2Of2 m) -> 21, [an], string m\n  | EntityKind.MemberName(n) -> 22, [], n.Name\n\n/// Return the entity representing the name just before call in call chain\nlet rec lastChainElement ent = \n  match ent.Kind with\n  | EntityKind.Variable _ -> ent\n  | EntityKind.Member(_, mem) -> mem\n  | EntityKind.MemberAccess(mem) -> lastChainElement mem\n  | _ -> ent\n\n// Provide easy access to entity's antecedents\ntype Entity with\n  member x.Antecedents = let _, ans, _ = entityCodeNameAndAntecedents x.Kind in ans\n  member x.Name = let _, _, name = entityCodeNameAndAntecedents x.Kind in name\n\n/// Return full name of the type\nlet rec formatType = function\n  | Type.Delayed _ -> \"delayed type\"\n  | Type.Primitive PrimitiveType.Bool -> \"bool\"\n  | Type.Primitive PrimitiveType.Date -> \"date\"\n  | Type.Primitive PrimitiveType.Number -> \"number\"\n  | Type.Primitive PrimitiveType.String -> \"string\"\n  | Type.Primitive PrimitiveType.Unit -> \"unit\"\n  | Type.Object obj ->  \n      try \n        let mem = obj.Members\n        let mems = mem |> Seq.truncate 5 |> Seq.map (fun m -> m.Name) |> String.concat \", \"\n        \"{ \" + if mem.Length > 5 then mems + \", ...\" else mems + \" }\"\n      with _ -> \"{ members }\"\n  | Type.Method(tin, tout) -> \n      let tout = match tout [for ma in tin -> ma.Type, None ] with Some t -> formatType t | _ -> \"?\"\n      let tin = \n        [ for ma in tin -> \n            sprintf \"%s%s%s:%s\" (if ma.Optional then \"?\" else \"\") \n              (if ma.Static then \"!\" else \"\") ma.Name (formatType ma.Type) ]\n        |> String.concat \", \" \n      \"(\" + tin + \") -> \" + tout\n  | Type.List t -> \"list<\" + formatType t + \">\"\n  | Type.Any -> \"any\"\n\n/// Return readable name of the top-level node in the type\nlet formatTypeInfo = function\n  | Type.Delayed _ -> \"delayed type\"\n  | Type.Primitive PrimitiveType.Bool -> \"bool\"\n  | Type.Primitive PrimitiveType.Date -> \"date\"\n  | Type.Primitive PrimitiveType.Number -> \"number\"\n  | Type.Primitive PrimitiveType.String -> \"string\"\n  | Type.Primitive PrimitiveType.Unit -> \"unit\"\n  | Type.Object _ -> \"object type\"\n  | Type.Method _ -> \"method type\"\n  | Type.List _ -> \"list type\"\n  | Type.Any _ -> \"unknown\"\n\n/// When pattern matching using `ExprNode`, this function lets you rebuild\n/// the original node from the original expression, new expressions & names\nlet rebuildExprNode e es ns =\n  match e, es, ns with\n  | Expr.Placeholder(_, _), [e], [n] -> Expr.Placeholder(n, e)\n  | Expr.List(_), els, [] -> Expr.List(els)\n  | Expr.Function(_), [e], [n] -> Expr.Function(n, e)\n  | Expr.Member(_, _), [e1; e2], [] -> Expr.Member(e1, e2)\n  | Expr.Binary(_, op, _), [e1; e2], [] -> Expr.Binary(e1, op, e2)\n  | Expr.Call(_, args), e::es, ns ->\n      let rec rebuildArgs args es ns =\n        match args, es, ns with\n        | { Argument.Name = None }::args, e::es, ns -> { Value = e; Name = None }::(rebuildArgs args es ns)\n        | { Argument.Name = Some _ }::args, e::es, n::ns -> { Value = e; Name = Some n }::(rebuildArgs args es ns)\n        | [], [], [] -> []\n        | _ -> failwith \"rebuildExprNode: Wrong call length\"\n      Expr.Call(e, { args with Node = rebuildArgs args.Node es ns })\n  | Expr.Variable _, [], [n] -> Expr.Variable(n)\n  | Expr.Placeholder _, _, _ -> failwith \"rebuildExprNode: Wrong placeholder length\"\n  | Expr.Variable _, _, _ -> failwith \"rebuildExprNode: Wrong variable length\"\n  | Expr.Member _, _, _ -> failwith \"rebuildExprNode: Wrong member length\"\n  | Expr.Call _, _, _ -> failwith \"rebuildExprNode: Wrong call length\"\n  | Expr.List _, _, _ -> failwith \"rebuildExprNode: Wrong list length\"\n  | Expr.Function _, _, _ -> failwith \"rebuildExprNode: Wrong function length\"\n  | Expr.Binary _, _, _ -> failwith \"rebuildExprNode: Wrong binary operator argument length\"\n  | Expr.Number _, _, _\n  | Expr.Boolean _, _, _\n  | Expr.String _, _, _\n  | Expr.Empty, _, _ -> failwith \"rebuildExprNode: Not a node\"\n\n/// ExprNode matches when an expression contains nested expressions or names,\n/// ExprLeaf matches when an expression is a primitive (number, bool, etc..)\nlet (|ExprLeaf|ExprNode|) e = \n  match e with\n  | Expr.Placeholder(n, e) -> ExprNode([e], [n])\n  | Expr.Member(e1, e2) -> ExprNode([e1; e2], [])\n  | Expr.Call(e, args) -> ExprNode(e::[for a in args.Node -> a.Value ], (args.Node |> List.choose (fun a -> a.Name)))\n  | Expr.Variable(n) -> ExprNode([], [n])\n  | Expr.List(els) -> ExprNode(els, [])\n  | Expr.Function(n, b) -> ExprNode([b], [n])\n  | Expr.Binary(l, op, r) -> ExprNode([l; r], [])\n  | Expr.Number _\n  | Expr.Boolean _\n  | Expr.String _\n  | Expr.Empty -> ExprLeaf()\n\n/// Find object member with the specified name \nlet (|FindMember|_|) (name:Name) (obj:ObjectType) = \n  obj.Members |> Seq.tryPick (fun m -> if m.Name = name.Name then Some(m) else None) \n\n/// Return the first metadata item with the specified context & type (or None)\nlet pickMetaByType ctx typ metas = \n  metas |> List.tryPick (fun m -> \n    if m.Context = ctx && m.Type = typ then Some(m.Data)\n    else None)\n\n","﻿// ------------------------------------------------------------------------------------------------\n// Interpreter is used to partially evaluate parts of program as needed\n// ------------------------------------------------------------------------------------------------\nmodule TheGamma.Interpreter\n\nopen TheGamma\nopen TheGamma.Ast\nopen TheGamma.Common\nopen TheGamma.Babel\nopen TheGamma.Babel.BabelOperators\nopen Fable.Helpers.Babel\nopen System.Collections.Generic\n\n// ------------------------------------------------------------------------------------------------\n// Wrappers around `eval` that let us treat runtime values as `Expressions` we can pass to babel\n// ------------------------------------------------------------------------------------------------\n\n/// Creates an array of objects and list of expressions that refer\n/// to them as if they were stored in an array, e.g. `_stored[0]` and `_stored[1]`\nlet storeArguments values =\n  values |> Array.ofList, \n  values |> List.mapi (fun i _ ->\n    MemberExpression\n      ( IdentifierExpression(\"_stored\", None),\n        NumericLiteral(float i, None), true, None ))\n\n/// Evalaute Babel expression, assuming `_stored` is in scope\nlet evaluateExpression (_stored:RuntimeValue[]) (expr:Expression) =\n  let prog = { Babel.Program.location = None; Babel.Program.body = [ExpressionStatement(expr, None)] }\n  let code = babel.transformFromAst(Serializer.serializeProgram prog, \"\", { presets = [| \"es2015\" |] })\n  Log.trace(\"interpreter\", \"Interpreter evaluating: %O using values %O\", code.code, _stored)\n  try\n    // HACK (1/2): Get fable to reference everything\n    let s = TheGamma.Series.series<int, int>.create(async { return [||] }, \"\", \"\", \"\") \n    TheGamma.TypeProvidersRuntime.RuntimeContext(\"lol\", \"\", \"troll\") |> ignore\n    TheGamma.TypeProvidersRuntime.trimLeft |> ignore\n    TheGamma.TypeProvidersRuntime.convertTupleSequence |> ignore\n    TheGamma.TypeProvidersRuntime.convertSequence |> ignore\n    TheGamma.GoogleCharts.chart.bar |> ignore\n    TheGamma.table<int, int>.create(s) |> ignore\n    TheGamma.General.date.now() |> ignore\n    TheGamma.Series.series<int, int>.values([| 1 |]) |> ignore    \n    TheGamma.placeholder.create(\"\") |> ignore\n    TheGamma.Interactive.youguess.line |> ignore\n\n    // HACK (2/2) The name `_stored` may appear in the generated code!\n    _stored.Length |> ignore\n    eval(code.code)\n  with e ->\n    Log.exn(\"interpreter\", \"Evaluation failed: %O\", e)\n    reraise()\n\n/// Store given arguments and evalaute expression\nlet evaluateExpr args exprBuilder =\n  let _stored, args = storeArguments args\n  evaluateExpression _stored (exprBuilder args)\n\n/// If the value is object with 'preview' method or property, evaluate it!\nlet evaluatePreview (ent:Entity) value = \n  let previewName = {Name.Name=\"preview\"}\n  Log.trace(\"interpreter\", \"Evaluating preview on: %O (%s)\", ent, Ast.formatType ent.Type.Value)\n  match ent.Type with\n  | Some(Type.Object(FindMember previewName mem)) ->       \n      // Member access or member access & call, depending on whether the member is a method\n      match mem.Type with\n      | Type.Method(_, _) -> evaluateExpr [value] (fun inst -> mem.Emitter.Emit(List.head inst) /@/ []) |> Some\n      | _ -> evaluateExpr [value] (fun inst -> mem.Emitter.Emit(List.head inst)) |> Some\n  | _ -> None\n\n// ------------------------------------------------------------------------------------------------\n// Recursively walk over entities & evaluate (starting from antecedents)\n// ------------------------------------------------------------------------------------------------\n\nlet rec evaluateEntity (e:Entity) = \n  match e.Kind with\n  // Constants, variables & global values (using expression stored in GlobalValue entity)\n  | EntityKind.Constant(Constant.Boolean b) -> Some(unbox b)\n  | EntityKind.Constant(Constant.Number n) -> Some(unbox n)\n  | EntityKind.Constant(Constant.String s) -> Some(unbox s)\n  | EntityKind.Constant(Constant.Empty) -> Some(unbox null)\n\n  | EntityKind.Variable(_, value) ->\n      value.Value |> Option.map (fun v -> v.Value)\n\n  | EntityKind.GlobalValue(name, expr) ->\n      match expr with\n      | Some expr -> Some(evaluateExpression [| |] expr)\n      | _ -> None\n\n  // Member access and call - method call is member access followed by a call\n  | EntityKind.Member(inst, { Kind = EntityKind.MemberName(name) }) ->\n      match inst.Type.Value with \n      | Type.Object(FindMember name mem) -> \n          Some(evaluateExpr [getValue inst] (fun inst -> mem.Emitter.Emit(List.head inst)))\n      | _ -> None\n\n  | EntityKind.MemberAccess(mem) ->\n      Some(getValue mem)\n  \n  | EntityKind.Call(inst, { Kind = EntityKind.ArgumentList(args) }) ->\n      // Split arguments between index-based and position-based\n      let pb = args |> List.takeWhile (function { Kind = EntityKind.NamedParam _ } -> false | _ -> true)  \n      let nb = args |> List.skipWhile (function { Kind = EntityKind.NamedParam _ } -> false | _ -> true)  \n\n      let positionBased = \n        pb |> List.map (getValue) |> Array.ofList\n      let nameBased =   \n        nb |> List.choose(function \n          | { Kind = EntityKind.NamedParam(name, value) } -> Some(name.Name, getValue value)\n          | _ -> None) |> dict\n\n      // Get expected arguments from the method type\n      let expectedArgs = \n        match inst.Type.Value with\n        | Type.Method(args, resTy) -> args\n        | _ -> []\n\n      // Evalate arguments and instance and run the call \n      let pars = expectedArgs |> List.mapi (fun i ma ->\n        if i < positionBased.Length then positionBased.[i]\n        elif nameBased.ContainsKey(ma.Name) then nameBased.[ma.Name]\n        else (unbox null) )\n\n      match inst with \n      | { Kind = EntityKind.MemberAccess { Kind = EntityKind.Member(inst, { Kind = EntityKind.MemberName(n) }) } } ->\n          let instValue = getValue inst\n          match inst.Type with \n          | Some(Type.Object(FindMember n mem)) ->\n              evaluateExpr (instValue::pars) (fun stored -> mem.Emitter.Emit(List.head stored) /@/ List.tail stored)\n          | _ ->\n              evaluateExpr (instValue::pars) (fun stored -> ((List.head stored) /?/ str n.Name) /@/ List.tail stored)\n      | _ ->\n          let instValue = getValue inst\n          evaluateExpr (instValue::pars) (fun stored -> List.head stored /@/ List.tail stored)\n\n  | EntityKind.Member(inst, _) ->\n      Log.error(\"interpreter\", \"typeCheckEntity: Member access is missing member name!\")\n      None\n  | EntityKind.Call(inst, _) ->\n      Log.error(\"interpreter\", \"typeCheckEntity: Call to %s is missing argument list!\", (lastChainElement inst).Name)\n      None\n\n  // Binary operators - most map to JavaScript except for power, which is a JS function\n  | EntityKind.Operator(l, Operator.Power, r) ->\n      evaluateExpr [getValue l; getValue r] (function \n        | [l; r] -> ident(\"Math\")?pow /@/ [l; r]\n        | _ -> failwith \"evaluateEntity: Expected two arguments\") |> Some      \n\n  | EntityKind.Operator(l, op, r) ->\n      evaluateExpr [getValue l; getValue r] (function \n        | [l; r] -> \n            let op = \n              match op with\n              | Operator.Modulo -> BinaryModulus\n              | Operator.Equals -> BinaryEqualStrict\n              | Operator.Plus -> BinaryPlus\n              | Operator.Minus -> BinaryMinus\n              | Operator.Multiply -> BinaryMultiply\n              | Operator.Divide -> BinaryDivide\n              | Operator.GreaterThan -> BinaryGreater\n              | Operator.LessThan -> BinaryLess\n              | Operator.GreaterThanOrEqual -> BinaryGreaterOrEqual\n              | Operator.LessThanOrEqual -> BinaryLessOrEqual\n              | Operator.Power -> failwith \"evaluateEntity: Power is not a binary operation\"\n            BinaryExpression(op, l, r, None)\n        | _ -> failwith \"evaluateEntity: Expected two arguments\") |> Some            \n\n  // Other simple language constructs\n  | EntityKind.List(ents) ->\n      evaluateExpr (List.map (getValue) ents) (fun elements ->\n        ArrayExpression(elements, None)) |> Some\n\n  | EntityKind.Placeholder(_, body) ->\n      Some(getValue body)\n\n  // The following entities do not represent anything that has a value      \n  | EntityKind.ArgumentList _\n  | EntityKind.NamedParam _\n  | EntityKind.MemberName _\n  | EntityKind.Binding _\n  | EntityKind.Root _\n  | EntityKind.CallSite _ ->\n      Some(unbox null)\n\n  | EntityKind.Function _\n  | EntityKind.Program _ \n  | EntityKind.LetCommand _ \n  | EntityKind.RunCommand _ -> \n      Log.error(\"interpreter\", \"Cannot evaluate entity (probably not supported yet): %O\", e)\n      None\n\n// Evaluate value and lazily generate preview, if it is None\nand ensureValue (e:Entity) = \n  if e.Value.IsNone then\n    match evaluateEntity e with\n    | Some value ->\n        e.Value <- Some { Value = value; Preview = Lazy.Create(fun () -> evaluatePreview e value) }\n    | _ -> ()\n\n/// Get value assumes that `evaluateEntityTree` evaluated antecedents already\nand getValue (e:Entity) = \n  if e.Value.IsNone then Log.error(\"interpreter\", \"getValue: Value of entity %O has not been evaluated.\", e)\n  e.Value.Value.Value\n\n/// Evalaute antecedents (caching them in `visited`) and then evalaute `e`\nlet evaluateEntityTree (e:Entity) = \n  let visited = Dictionary<Symbol, bool>()\n  let rec loop (e:Entity) = \n    if not (visited.ContainsKey(e.Symbol)) && e.Value.IsNone then\n      visited.[e.Symbol] <- true\n      for e in e.Antecedents do loop e\n      ensureValue e\n  loop e\n  e.Value \n\n// ------------------------------------------------------------------------------------------------\n// Public interface - creating global entities and evaluating entities\n// ------------------------------------------------------------------------------------------------\n\nlet globalEntity name meta typ expr = \n  { Kind = EntityKind.GlobalValue({ Name = name }, expr)\n    Symbol = createSymbol()\n    Type = Some typ\n    Meta = meta\n    Value = None\n    Errors = [] }\n\nlet evaluate (globals:seq<Entity>) (e:Entity) = \n  //Log.trace(\"interpreter\", \"Evaluating entity %s (%O)\", e.Name, e.Kind)\n  let res = evaluateEntityTree e\n  //Log.trace(\"interpreter\", \"Evaluated entity %s (%O) = %O\", e.Name, e.Kind, res)\n  res\n","﻿module TheGamma.Types\nopen TheGamma.Common\n\n// ------------------------------------------------------------------------------------------------\n// Helper functions for working with types\n// ------------------------------------------------------------------------------------------------\n\nlet rec listsEqual l1 l2 f = \n  match l1, l2 with\n  | [], [] -> true\n  | x::xs, y::ys when f x y -> listsEqual xs ys f\n  | _ -> false \n\nlet optionsEqual o1 o2 f = \n  match o1, o2 with\n  | None, None -> true\n  | Some v1, Some v2 -> f v1 v2\n  | _ -> false\n\nlet rec typesEqual t1 t2 = \n  match t1, t2 with\n  | Type.Any, _ | _, Type.Any -> true\n  | Type.List t1, Type.List t2 -> typesEqual t1 t2\n  | Type.Method(a1, r1), Type.Method(a2, r2) -> \n      optionsEqual (r1 [for ma in a1 -> ma.Type, None]) (r2 [for ma in a2 -> ma.Type, None]) typesEqual &&\n      listsEqual a1 a2 (fun m1 m2 -> m1.Name = m2.Name && m1.Optional = m2.Optional && m1.Static = m2.Static && typesEqual m1.Type m2.Type)\n  | Type.Object(o1), Type.Object(o2) -> o1.TypeEquals(o2)\n  | Type.Primitive n1, Type.Primitive n2 -> n1 = n2  \n  | _ -> false\n","﻿// ------------------------------------------------------------------------------------------------\n// F# provider makes it possible to use Fable-compiled F# types (even with generics!)\n// ------------------------------------------------------------------------------------------------\nmodule TheGamma.TypeProviders.FSharpProvider\n\nopen TheGamma\nopen TheGamma.Babel\nopen TheGamma.Babel.BabelOperators\nopen TheGamma.Common\nopen Fable.Import\nopen ProviderHelpers\n\n// ------------------------------------------------------------------------------------------------\n// Records that represent the JSON with metadata about the F# types\n// ------------------------------------------------------------------------------------------------\n\n/// AnyType has `kind` property accessible via `getKind`\ntype AnyType = obj\n\ntype GenericParameterType = \n  { kind : string \n    name : string }\n\ntype ArrayType = \n  { kind : string \n    element : AnyType }\n\ntype PrimitiveType = \n  { kind : string \n    name : string }\n\ntype FunctionType = \n  { kind : string \n    arguments : AnyType[]\n    returns : AnyType }\n\ntype NamedType = \n  { kind : string \n    name : string\n    typargs : AnyType[] }\n\n/// Member has `kind` property accessible via `getKind`\ntype Member = obj\n\ntype Argument = \n  { name : string\n    optional : bool\n    ``type`` : AnyType }\n\ntype MethodMember = \n  { kind : string\n    name : string \n    typepars : AnyType[]\n    arguments:Argument[]\n    returns : AnyType }\n\ntype PropertyMember = \n  { kind : string\n    name : string \n    returns : AnyType }\n\ntype ExportedType = \n  { name : string\n    typepars : AnyType[]\n    ``static`` : bool \n    instance : string[]\n    members : Member[] }\n\n// ------------------------------------------------------------------------------------------------\n// Special-case `ObjectTypes` for handling of generics \n// ------------------------------------------------------------------------------------------------\n\n/// Represents a fully applied generic type such as `Series<string, int>`\ntype GenericType =\n  inherit ObjectType\n  abstract TypeArguments : Type list\n  abstract TypeDefinition : GenericTypeDefinition\n\n/// Represents an applied generic type that may contain type parameters e.g. `Series<string, 'V>`\nand GenericTypeSchema = \n  inherit ObjectType\n  abstract TypeDefinition : GenericTypeDefinition\n  abstract TypeArguments : TypeSchema list\n  abstract Substitute : (string -> Type option) -> GenericType\n\n/// Represents a generic type definition such as `Series'2`\nand GenericTypeDefinition = \n  inherit ObjectType\n  abstract FullName : string\n  abstract TypeParameterCount : int\n  abstract Apply : TypeSchema list -> GenericTypeSchema\n\n/// Representation of types that may contain type parameters e.g. `Series<string, 'v>[]`\nand TypeSchema = \n  | Primitive of Type\n  | GenericType of GenericTypeSchema\n  | Parameter of string\n  | Function of TypeSchema list * TypeSchema\n  | List of TypeSchema\n\n// ------------------------------------------------------------------------------------------------\n// Operations on types and type schemas\n// ------------------------------------------------------------------------------------------------\n\nlet rec mapGenericType typ g =\n  match typ with \n  | Type.Delayed(f) -> \n      Type.Delayed(Async.CreateNamedFuture \"applyTypes\" <| async {\n        let! res = Async.AwaitFuture f\n        return mapGenericType res g })\n  | Type.Object(:? GenericTypeDefinition as gtd) -> \n      Type.Object(gtd.Apply([ for t in g gtd -> TypeSchema.Primitive t]).Substitute(fun _ -> None))\n  | t -> t\n\nlet rec applyTypes typ tyargs =\n  match typ with \n  | Type.Delayed(f) -> \n      Type.Delayed(Async.CreateNamedFuture \"applyTypes\" <| async {\n        let! res = Async.AwaitFuture f\n        return applyTypes res tyargs })\n  | Type.Object(:? GenericTypeDefinition as gtd) -> \n      Type.Object(gtd.Apply([ for t in tyargs -> TypeSchema.Primitive t]).Substitute(fun _ -> None))\n  | _ -> failwith \"applyTypes: Expected generic type definition\"\n      \nlet rec unifyTypes ctx schemas tys = \n  match schemas, tys with\n  | [], [] -> Some ctx\n  | TypeSchema.GenericType(gs)::ss, Type.Object(:? GenericType as gt)::ts \n      when gt.TypeDefinition.FullName = gs.TypeDefinition.FullName && \n        List.length gs.TypeArguments = List.length gt.TypeArguments ->\n      unifyTypes ctx (gs.TypeArguments @ ss) (gt.TypeArguments @ ts)\n  | TypeSchema.Primitive(t1)::ss, t2::ts when Types.typesEqual t1 t2 -> unifyTypes ctx ss ts\n  | TypeSchema.Parameter(n)::ss, t::ts -> unifyTypes ((n,t)::ctx) ss ts\n  | TypeSchema.List(s)::ss, Type.List(t)::ts -> unifyTypes ctx (s::ss) (t::ts)\n  | TypeSchema.Function(sa, sr)::ss, Type.Method(ta, tr)::ts when List.length sa = List.length ta -> \n      let ta = [ for ma in ta -> ma.Type, None ]\n      let tr = defaultArg (tr ta) Type.Any // TODO: This should probably never be None\n      unifyTypes ctx (sr::(sa @ ss)) (tr::((List.map fst ta) @ ts)) \n  | TypeSchema.GenericType(_)::_, _ \n  | TypeSchema.Primitive(_)::_, _ \n  | TypeSchema.List(_)::_, _ \n  | TypeSchema.Function(_)::_, _ \n  | [], _\n  | _, [] -> \n    match schemas, tys with\n    | s::_, t::_ -> Log.trace(\"providers\", \"Failed to unify types %O and %O\", s, t)\n    | _ -> Log.trace(\"providers\", \"Failed to unify types %O and %O\", schemas, tys)\n    None\n\nlet rec substituteTypeParams assigns schema = \n  match schema with\n  | TypeSchema.GenericType ts -> Type.Object(ts.Substitute assigns)\n  | TypeSchema.Primitive t -> t\n  | TypeSchema.List s -> Type.List (substituteTypeParams assigns s)\n  | TypeSchema.Parameter n -> match assigns n with Some t -> t | _ -> failwith \"substituteTypeParams: unresolved type parameter\"\n  | TypeSchema.Function(is, rs) -> \n      let args = is |> List.map (fun it -> { MethodArgument.Name = \"\"; Optional = false; Static = false; Type = substituteTypeParams assigns it })\n      Type.Method(args, fun _ -> Some(substituteTypeParams assigns rs)) // TODO: This should check input arguments\n\nlet rec partiallySubstituteTypeParams (assigns:string -> Type option) schema = \n  match schema with\n  | TypeSchema.Primitive t -> TypeSchema.Primitive t\n  | TypeSchema.List s -> TypeSchema.List (partiallySubstituteTypeParams assigns s)\n  | TypeSchema.Parameter n when (assigns n).IsSome -> TypeSchema.Primitive(assigns(n).Value) \n  | TypeSchema.Parameter n -> TypeSchema.Parameter n\n  | TypeSchema.Function(is, rs) -> \n      TypeSchema.Function\n        ( List.map (partiallySubstituteTypeParams assigns) is, \n          partiallySubstituteTypeParams assigns rs )\n  | TypeSchema.GenericType ts ->\n      { new GenericTypeSchema with\n          member x.Members = failwith \"Uninstantiated generic type schema\"\n          member x.TypeEquals _ = failwith \"Uninstantiated generic type schema\"\n          member x.TypeArguments = List.map (partiallySubstituteTypeParams assigns) ts.TypeArguments\n          member x.TypeDefinition = ts.TypeDefinition\n          member x.Substitute assigns2 =\n            ts.Substitute (fun n ->\n              match assigns2 n, assigns n with\n              | Some t, _ \n              | _, Some t -> Some t\n              | _ -> None) } |> TypeSchema.GenericType    \n   \n/// This way of accessing `kind` of `AnyType` or `Member` works both in .NET and in JS\n[<Emit(\"$0.kind\")>]\nlet getKind (o:obj) : string = \n  o.GetType().GetProperty(\"kind\").GetValue(o) :?> string\n\n\n// Needs to be delayed to avoid calling lookupNamed too early\nlet importProvidedType url lookupNamed exp = \n  let rec mapType (t:AnyType) = \n    match getKind t with\n    | \"primitive\" -> \n        ( match (unbox<PrimitiveType> t).name with\n          | \"object\" -> Type.Any\n          | \"int\" | \"float\" -> Type.Primitive PrimitiveType.Number\n          | \"string\" -> Type.Primitive PrimitiveType.String\n          | \"bool\" -> Type.Primitive PrimitiveType.Bool\n          | \"unit\" -> Type.Primitive PrimitiveType.Unit\n          | \"date\" -> Type.Primitive PrimitiveType.Date\n          | t -> failwith (\"provideFSharpType: Unsupported type: \" + t) )\n        |> TypeSchema.Primitive\n    | \"function\"->\n        let t = unbox<FunctionType> t\n        TypeSchema.Function(List.ofSeq (Array.map mapType t.arguments),mapType t.returns)\n    | \"named\" -> \n        let t = (unbox<NamedType> t)\n        let tyargs = List.ofArray (Array.map mapType t.typargs)\n        match lookupNamed t.name with\n        | Type.Object (:? GenericTypeDefinition as gtd) -> \n            if gtd.TypeParameterCount <> List.length tyargs then \n              failwith \"provideFSharpType: Named type has mismatching nuumber of arguments\"\n            gtd.Apply tyargs |> TypeSchema.GenericType \n        | t -> TypeSchema.Primitive t\n    | \"parameter\" -> TypeSchema.Parameter (unbox<GenericParameterType> t).name\n    | \"array\" -> TypeSchema.List(mapType (unbox<ArrayType> t).element)\n    | _ -> failwith \"provideFSharpType: Unexpected type\"\n\n  let getTypeParameters typars = \n    typars |> Array.map (fun t -> \n      match mapType t with\n      | TypeSchema.Parameter(n) -> n\n      | _ -> failwith \"importProvidedType: expected type parameter\") |> List.ofArray\n\n  let generateMembers assigns = \n    exp.members |> Array.choose (fun m ->\n      if getKind m = \"property\" then\n        let m = unbox<PropertyMember> m\n        let retTyp = substituteTypeParams assigns (mapType m.returns)\n        let emitter = { Emit = fun inst -> MemberExpression(inst, IdentifierExpression(m.name, None), false, None) }\n        Some { Member.Name = m.name; Type = retTyp; Metadata = []; Emitter = emitter }\n\n      elif getKind m = \"method\" then\n        let m = unbox<MethodMember> m\n        let typars = getTypeParameters m.typepars \n        // Do not substitute bound variables\n        let assigns n = if List.exists ((=) n) typars then None else assigns n\n\n        let args = [ for a in m.arguments -> a.name, a.optional, partiallySubstituteTypeParams assigns (mapType a.``type``) ]\n        let emitter = { Emit = fun inst -> MemberExpression(inst, IdentifierExpression(m.name, None), false, None) }\n            \n        let retTyp = partiallySubstituteTypeParams assigns (mapType m.returns)\n        let retFunc tys =\n          let tys = List.map fst tys\n          Log.trace(\"providers\", \"F# provider unifying: %O, %O\", [| for _, _, t in args -> t |], Array.ofList tys)\n          match unifyTypes [] [ for _, _, t in args -> t ] tys with \n          | None -> None\n          | Some assigns ->\n              let assigns =\n                assigns \n                |> Seq.groupBy fst\n                |> Seq.map (fun (p, tys) ->\n                    p, tys |> Seq.fold (fun st (_, ty2) ->\n                      match st with\n                      | Some ty1 -> if Types.typesEqual ty1 ty2 then Some ty2 else None\n                      | None -> None) (Some Type.Any) )\n                |> Seq.fold (fun assigns assign ->\n                  match assigns, assign with\n                  | Some assigns, (p, Some assign) -> Some ((p,assign)::assigns)\n                  | _ -> None) (Some [])\n              match assigns with\n              | Some assigns when List.length assigns = List.length typars ->\n                  let assigns = dict assigns\n                  let subst n = if assigns.ContainsKey n then Some assigns.[n] else None\n                  Some (substituteTypeParams subst retTyp)\n              | _ -> None\n\n        // How to show type parameters before they are eliminated?\n        let args = [ for n, o, t in args -> { MethodArgument.Name = n; Optional = o; Static = false; Type = substituteTypeParams (fun _ -> Some Type.Any) t } ] \n        Some { Member.Name = m.name; Type = Type.Method(args, retFunc); Metadata = []; Emitter = emitter }\n      else None)\n\n  let objectType = \n    match getTypeParameters exp.typepars with\n    | [] -> \n        { new ObjectType with\n            member x.Members = generateMembers (fun _ -> None) \n            member x.TypeEquals _ = false }\n    | typars ->\n        { new GenericTypeDefinition with\n            member td.TypeParameterCount = List.length typars\n            member td.FullName = TypeProvidersRuntime.concatUrl url exp.name\n            member td.Members = failwithf \"Uninstantiated generic type definition (%s)\" td.FullName\n            member td.TypeEquals _ = failwithf \"Uninstantiated generic type definition (%s)\" td.FullName\n            member td.Apply tyargs = \n              { new GenericTypeSchema with\n                  member x.Members = failwith \"Uninstantiated generic type schema\"\n                  member x.TypeDefinition = td\n                  member x.TypeEquals _ = failwith \"Uninstantiated generic type schema\"\n                  member x.Substitute assigns = \n                    // Lazy so that lookupNamed does not get called too early\n                    let tyArgLookup = dict (List.zip typars tyargs)\n                    let members = lazy generateMembers (fun n ->\n                      match tyArgLookup.TryGetValue n with\n                      | true, tysch -> Some(substituteTypeParams assigns tysch)\n                      | _ -> None)\n\n                    { new GenericType with\n                        member x.TypeArguments = List.map (substituteTypeParams assigns ) tyargs\n                        member x.TypeDefinition = td\n                        member x.Members = members.Value\n                        member x.TypeEquals t2 = \n                          match t2 with\n                          | :? GenericType as gt ->\n                              gt.TypeDefinition.FullName = x.TypeDefinition.FullName &&\n                                Types.listsEqual x.TypeArguments gt.TypeArguments Types.typesEqual\n                          | _ -> false }\n                  member x.TypeArguments = tyargs } } :> _\n    \n  objectType |> Type.Object\n\nlet provideFSharpTypes lookupNamed url =   \n  async {\n    let! json = Http.Request(\"GET\", url)\n    let expTys = jsonParse<ExportedType[]> json\n    return\n      [ for exp in expTys ->\n          let ty = importProvidedType url lookupNamed exp\n          if exp.``static`` then           \n            let e = exp.instance |> Seq.fold (fun chain s -> \n              match chain with\n              | None -> Some(IdentifierExpression(s, None))\n              | Some e -> Some(MemberExpression(e, IdentifierExpression(s, None), false, None)) ) None |> Option.get\n            let ty = mapGenericType ty (fun gtd -> [ for i in 1 .. gtd.TypeParameterCount -> Type.Any ])\n            ProvidedType.GlobalValue(exp.name, [], e, ty)\n          else\n            ProvidedType.NamedType(exp.name, ty) ] }\n","﻿// ------------------------------------------------------------------------------------------------\n// REST type provider\n// ------------------------------------------------------------------------------------------------\nmodule TheGamma.TypeProviders.RestProvider\n\nopen TheGamma\nopen TheGamma.Babel\nopen TheGamma.Babel.BabelOperators\nopen TheGamma.Common\nopen TheGamma.TypeProviders.ProviderHelpers\nopen Fable.Import\n\n// ------------------------------------------------------------------------------------------------\n// Types to represent JSON data returned by REST service\n// ------------------------------------------------------------------------------------------------\n\ntype AnyType = { kind:string }\ntype TypeNested = { kind:string (* = nested *); endpoint:string }\ntype TypeProvider = { kind:string (* = provider *); provider:string; endpoint:string }\ntype TypePrimitive = { kind:string (* = primitive *); ``type``:obj; endpoint:string }\n\n[<Fable.Core.Emit(\"typeof($0)\")>]\nlet jstypeof (o:obj) : string = failwith \"!\"\n\ntype Documentation = \n  { title : string option\n    details : string option }\n\ntype Parameter =\n  { name : string\n    optional : bool\n    kind : string\n    cookie : string option\n    trace : string option\n    ``type`` : obj }\n\ntype Member =\n  { name : string\n    returns : AnyType\n    parameters : Parameter[] option\n    documentation : obj option\n    schema : obj[]\n    trace : string[] }\n\ntype ResultType = \n  | Primitive of string\n  | Generic of string * ResultType[]\n  | Record of (string * ResultType)[]\n\ntype RawField = \n  { name : string\n    ``type`` : obj }\n\ntype RawResultType = \n  { name : string \n    fields : RawField[]\n    ``params`` : obj[] }\n\nlet parseDoc (json:obj option) =\n  if json.IsNone then Documentation.None\n  elif jstypeof json.Value = \"string\" then Documentation.Text(unbox json)\n  else \n    let doc = unbox<Documentation> json.Value\n    match doc.title, doc.details with \n    | Some title, Some dets -> Documentation.Details(title, dets)\n    | _ -> Documentation.None\n\nlet rec fromRawType (json:obj) =\n  if jstypeof json = \"string\" then Primitive(unbox json)\n  else\n    let res = unbox<RawResultType> json\n    if res.name = \"record\" then res.fields |> Array.map (fun f -> f.name, fromRawType f.``type``) |> Record\n    else Generic(res.name, res.``params`` |> Array.map fromRawType)\n\n// ------------------------------------------------------------------------------------------------\n// Code generation for provided members\n// ------------------------------------------------------------------------------------------------\n \nlet trimLeft c (s:string) = s.ToCharArray() |> Array.skipWhile ((=) c) |> System.String\nlet trimRight c (s:string) = s.ToCharArray() |> Array.rev |> Array.skipWhile ((=) c) |> Array.rev |> System.String\n\nlet concatUrl (a:string) (b:string) =\n  if b.StartsWith(\"http://\") || b.StartsWith(\"https://\") then b\n  else (trimRight '/' a) + \"/\" + (trimLeft '/' b)\n\nlet load url cookies = async {\n  let! json = Http.Request(\"GET\", url, cookies=cookies)\n  let members = jsonParse<Member[]> json\n  return members }\n\nlet addTraceCall inst trace =\n  if Seq.isEmpty trace then inst \n  else inst?addTrace /@/ [str (String.concat \"&\" trace)]\n\nlet propAccess trace = \n  { Emit = fun inst -> addTraceCall inst trace }\n\nlet methCall traceNames trace =\n  { Emit = fun inst -> funcN (Seq.length traceNames) (fun args ->\n      let withTrace = addTraceCall inst trace\n      Seq.zip traceNames args |> Seq.fold (fun inst (name, value) ->\n        let trace = BinaryExpression(BinaryPlus, str(name + \"=\"), value, None)\n        inst?addTrace /@/ [trace] ) withTrace) }\n\nlet dataCall parser trace endp = \n  { Emit = fun inst ->\n      let tr = (propAccess trace).Emit(inst) \n      let mem = MemberExpression(tr, IdentifierExpression(\"getValue\", None), false, None)\n      CallExpression(mem, [StringLiteral(endp, None)], None) |> parser }\n \n\n// Turn \"Async<string>\" into the required type\n// I guess we should keep a flag whether the input is still async (or something)\nlet rec getTypeAndEmitter (lookupNamed:string -> Type) ty = \n  match ty with\n  | Primitive(\"string\") -> Type.Primitive(PrimitiveType.String), id\n  | Primitive(\"obj\") -> Type.Primitive(PrimitiveType.String), id\n  | Primitive(\"int\") \n  | Primitive(\"float\") -> Type.Primitive(PrimitiveType.Number), fun e -> ident(\"Number\") /@/ [e]\n  | Primitive(\"date\") -> Type.Primitive(PrimitiveType.Date), fun e -> NewExpression(ident(\"Date\"), [ident(\"Date\")?parse /@/ [e]], None)\n  | Generic(\"seq\", [|Generic(\"tuple\", [|t1; t2|])|]) -> \n      let t1, e1 = getTypeAndEmitter lookupNamed t1\n      let t2, e2 = getTypeAndEmitter lookupNamed t2\n      let typ = FSharpProvider.applyTypes (lookupNamed \"series\") [t1; t2]\n      typ, \n      fun d -> \n        ident(\"series\")?create /@/ \n          [ ident(\"convertTupleSequence\") /@/ [func \"v\" e1; func \"v\" e2; d] \n            str \"key\"; str \"value\"; str \"\" ] // TODO: We don't have any info - that sucks\n  | Generic(\"seq\", [|ty|]) ->\n      let elTy, emitter = getTypeAndEmitter lookupNamed ty\n      let serTy = FSharpProvider.applyTypes (lookupNamed \"series\") [Type.Primitive PrimitiveType.Number; elTy]\n      serTy, \n      // This is over async, but the child `emitter` is not over async\n      fun d -> \n        ident(\"series\")?ordinal /@/ \n          [ ident(\"convertSequence\") /@/ [func \"v\" emitter; d] \n            str \"key\"; str \"value\"; str \"\" ]\n  | Record(membs) ->\n      let membs = \n        membs |> Array.map (fun (name, ty) ->\n          let memTy, memConv = getTypeAndEmitter lookupNamed ty\n          let emitter = { Emit = fun inst -> memConv <| inst?(name) }\n          { Member.Name = name; Type = memTy; Metadata = [docMeta(Documentation.Text \"\")]; Emitter = emitter })\n      let obj = \n        { new ObjectType with\n            member x.Members = membs\n            member x.TypeEquals _ = false }\n        |> TheGamma.Type.Object \n      obj, id\n  | _ -> \n      Browser.console.log(\"getTypeAndEmitter: Cannot handle %O\", ty)\n      failwith \"getTypeAndEmitter: Cannot handle type\"\n\n// ------------------------------------------------------------------------------------------------\n// Type provider\n// ------------------------------------------------------------------------------------------------\n\nlet restTypeCache = System.Collections.Generic.Dictionary<_, _>()\n\nlet rec createRestType lookupNamed resolveProvider root cookies url = \n\n  let provideMember m = \n    let schema = \n      if m.schema = null then []\n      elif isArray m.schema then m.schema |> Array.map (fun s ->\n        { Type = getProperty s \"@type\"; Context = getProperty s \"@context\"; Data = s }) |> List.ofSeq\n      else \n        [ { Type = getProperty m.schema \"@type\"; Context = getProperty m.schema \"@context\"; Data = m.schema } ]\n\n    match m.returns.kind with\n    | \"provider\" ->\n        let returns = unbox<TypeProvider> m.returns \n        let typ, emitter = resolveProvider returns.provider returns.endpoint\n        { Member.Name = m.name; Type = typ; Metadata = (docMeta (parseDoc m.documentation))::schema; Emitter = emitter }\n    | \"nested\" ->\n        let returns = unbox<TypeNested> m.returns \n        let createReturnType cookies = \n          try Some(createRestType lookupNamed resolveProvider root cookies returns.endpoint)\n          with _ -> None\n\n        match m.parameters with \n        | Some parameters ->\n            let args = \n              [ for p in parameters -> \n                  let ty = fromRawType p.``type``\n                  let ty, _ = getTypeAndEmitter lookupNamed ty\n                  { MethodArgument.Name = p.name; Optional = p.optional; Type = ty; Static = p.kind = \"static\" } ] \n            \n            let retFunc tys = \n              if not (Types.listsEqual (List.map fst tys) [ for ma in args -> ma.Type ] Types.typesEqual) then None else\n              let matched = Seq.zip parameters tys\n              let newCookies = \n                matched |> Seq.choose (function\n                  | pa, (_, Some value) when pa.kind = \"static\" -> Some(pa.cookie.Value + \"=\" + Fable.Import.JS.encodeURIComponent(string value))\n                  | _ -> None) \n              let cookies = Seq.append [cookies] newCookies |> String.concat \"&\"\n              createReturnType cookies\n\n            let traceNames = parameters |> Seq.choose (fun p -> p.trace)\n            { Member.Name = m.name; Metadata = [docMeta (parseDoc m.documentation)]\n              Type = Type.Method(args, retFunc); Emitter = methCall traceNames m.trace }\n        | None -> \n            let retTyp = defaultArg (createReturnType cookies) Type.Any\n            { Member.Name = m.name; Type = retTyp; Metadata = (docMeta (parseDoc m.documentation))::schema; Emitter = propAccess m.trace }\n    | \"primitive\" ->  \n        let returns = unbox<TypePrimitive> m.returns                      \n        let ty = fromRawType returns.``type``\n        let typ, parser = getTypeAndEmitter lookupNamed ty\n        { Member.Name = m.name; Type = typ; Metadata = (docMeta (parseDoc m.documentation))::schema; \n          Emitter = dataCall parser m.trace returns.endpoint }\n    | _ -> failwith \"?\" \n\n  let guid = (concatUrl root url) + cookies\n  match restTypeCache.TryGetValue guid with\n  | true, res -> res\n  | _ ->\n    let future = async {\n      try\n        let! members = load (concatUrl root url) cookies \n        let members = members |> Array.map provideMember\n        return \n          { new ObjectType with \n              member x.Members = members\n              member x.TypeEquals _ = false } |> Type.Object \n      with e -> \n        Log.error(\"providers\", \"Cannot provide object type: %O\", e)\n        return Type.Any }\n    let ty = Type.Delayed(Async.CreateNamedFuture guid future)\n    restTypeCache.[guid] <- ty\n    ty\n\nlet rec provideRestType lookupNamed resolveProvider name root cookies = \n  let ctx = ident(\"RuntimeContext\")\n  ProvidedType.GlobalValue\n    ( name, [],\n      NewExpression(ctx, [str root; str cookies; str \"\"], None),\n      createRestType lookupNamed resolveProvider root cookies \"/\")","﻿// ------------------------------------------------------------------------------------------------\n// Pivot type provider - for expressing data aggregation queries over a table\n// ------------------------------------------------------------------------------------------------\nmodule TheGamma.TypeProviders.Pivot\n\nopen Fable.Core\nopen Fable.Import\n\nopen TheGamma\nopen TheGamma.Babel\nopen TheGamma.Babel.BabelOperators\nopen TheGamma.Common\nopen TheGamma.TypeProviders\n\n// ------------------------------------------------------------------------------------------------\n// Operations that we can do on the table\n// ------------------------------------------------------------------------------------------------\n\n[<RequireQualifiedAccess>]\ntype GroupAggregation = \n  | GroupKey\n  | CountAll\n  | CountDistinct of string\n  | ConcatValues of string\n  | Sum of string\n  | Mean of string\n\n[<RequireQualifiedAccess>]\ntype WindowAggregation = \n  | Min of string\n  | Sum of string\n  | Max of string\n  | Mean of string\n  | FirstKey\n  | LastKey\n  | MiddleKey\n\ntype SortDirection =\n  | Ascending\n  | Descending \n\ntype Paging =\n  | Take of string\n  | Skip of string\n  \ntype FilterOperator = \n  | And | Or\n\ntype RelationalOperator = \n  | Equals \n  | NotEquals \n  | LessThan\n  | GreaterThan \n  | InRange\n  | Like\n\ntype FilterCondition = RelationalOperator * string * string\n\ntype Transformation = \n  | DropColumns of string list\n  | SortBy of (string * SortDirection) list\n  | GroupBy of string list * GroupAggregation list\n  | WindowBy of string * string * WindowAggregation list\n  | ExpandBy of string * WindowAggregation list\n  | FilterBy of FilterOperator * FilterCondition list\n  | Paging of Paging list\n  | Empty\n  // One of these may be the last one\n  | Metadata\n  | GetSeries of string * string\n  | GetTheData\n  | GetRange of string\n\ntype Field = \n  { Name : string \n    Type : PrimitiveType }\n\nmodule Transform = \n\n  let private formatGroupAgg = function\n    | GroupAggregation.GroupKey -> \"key\"\n    | GroupAggregation.CountAll -> \"count-all\"\n    | GroupAggregation.CountDistinct(f) -> \"count-dist \" + Ast.escapeIdent f\n    | GroupAggregation.ConcatValues(f) -> \"concat-vals \" + Ast.escapeIdent f\n    | GroupAggregation.Sum(f) -> \"sum \" + Ast.escapeIdent f\n    | GroupAggregation.Mean(f) -> \"mean \" + Ast.escapeIdent f\n\n  let private formatWinAgg = function\n    | WindowAggregation.FirstKey -> \"first-key\"\n    | WindowAggregation.MiddleKey -> \"mid-key\"\n    | WindowAggregation.LastKey -> \"last-key\"\n    | WindowAggregation.Mean(f) -> \"mean \" + Ast.escapeIdent f\n    | WindowAggregation.Min(f) -> \"min \" + Ast.escapeIdent f\n    | WindowAggregation.Max(f) -> \"max \" + Ast.escapeIdent f\n    | WindowAggregation.Sum(f) -> \"sum \" + Ast.escapeIdent f\n\n  let formatCondition (op, f, v) =\n    let op = \n      match op with Equals -> \"eq\" | NotEquals -> \"neq\" | LessThan -> \"lte\" | GreaterThan -> \"gte\" | InRange -> \"in\" | Like -> \"like\"\n    Ast.escapeIdent f + \" \" + op + \" \" + Ast.escapeIdent v\n\n  let toUrl transforms = \n    [ for t in transforms ->\n        match t with\n        | GetTheData -> []\n        | Metadata -> [\"metadata\", []]\n        | GetRange fld -> [\"range\", [fld]]\n        | FilterBy(op, conds) -> [\"filter\", (match op with And -> \"and\" | Or -> \"or\")::(List.map formatCondition conds)]\n        | DropColumns(columns) -> [\"drop\", columns]\n        | SortBy(columns) -> [\"sort\", (List.map (fun (c, o) -> c + (if o = Ascending then \" asc\" else \" desc\")) columns)]\n        | GroupBy(flds, aggs) -> [\"groupby\", (List.map (fun fld -> \"by \" + Ast.escapeIdent fld) flds) @ (List.map formatGroupAgg aggs)]\n        | WindowBy(fld, size, aggs) -> [\"windowby\", (\"by \" + Ast.escapeIdent fld) :: size :: (List.map formatWinAgg aggs)]\n        | ExpandBy(fld, aggs) -> [\"expandby\", (\"by \" + Ast.escapeIdent fld) :: (List.map formatWinAgg aggs)]\n        | Paging(ops) -> ops |> List.map (function Take k -> \"take\", [k] | Skip k -> \"skip\", [k]) \n        | GetSeries(k, v) -> [\"series\", [k; v]]\n        | Empty -> [] ]\n    |> List.concat\n    |> List.map (fun (op, args) -> \n        if List.isEmpty args then op \n        else op + \"(\" + String.concat \",\" args + \")\")\n    |> String.concat \"$\"\n\n  (*\n  let sample = \n    [ GroupBy([\"Athlete\"], [GroupKey; Sum(\"Gold Medals\"); ConcatValues(\"Team\")])\n      SortBy([\"Gold\", Descending])\n      Paging([Take \"10\"])\n      GetSeries(\"Athlete\", \"Gold\") ]\n  \n  toUrl  sample\n  // groupby([Athlete],key,sum 'Gold Medals',concat-vals Team)$sort(Gold desc)$take(10)$series(Athlete,Gold)\n  *)\n   \n  let singleTransformFields fields = function\n    | Empty -> fields\n    | Metadata -> failwith \"Metadata should not appear in normal queries\"\n    | GetRange _ -> failwith \"GetRange should not appear in normal queries\"\n    | GetTheData -> fields\n    | SortBy _ -> fields\n    | Paging _ -> fields\n    | FilterBy _ -> fields\n    | GetSeries(k, v) -> \n        [ fields |> List.find (fun f -> f.Name = k)\n          fields |> List.find (fun f -> f.Name = v) ]\n    | DropColumns(drop) ->\n        let dropped = set drop\n        fields |> List.filter (fun f -> not(dropped.Contains f.Name))\n    | ExpandBy(key, aggs) \n    | WindowBy(key, _, aggs) ->\n        let oldFields = dict [ for f in fields -> f.Name, f ]\n        aggs \n        |> List.collect (function\n           | WindowAggregation.FirstKey -> [ { Name = \"first \" + key; Type = oldFields.[key].Type } ]\n           | WindowAggregation.MiddleKey -> [ { Name = \"middle \" + key; Type = oldFields.[key].Type } ]\n           | WindowAggregation.LastKey -> [ { Name = \"last \" + key; Type = oldFields.[key].Type } ]\n           | WindowAggregation.Mean fld \n           | WindowAggregation.Min fld \n           | WindowAggregation.Sum fld \n           | WindowAggregation.Max fld -> [ oldFields.[fld] ])\n    | GroupBy(flds, aggs) ->\n        let oldFields = dict [ for f in fields -> f.Name, f ]\n        aggs \n        |> List.collect (function\n           | GroupAggregation.GroupKey -> List.map (fun f -> oldFields.[f]) flds\n           | GroupAggregation.ConcatValues fld\n           | GroupAggregation.Sum fld -> [ oldFields.[fld] ]\n           | GroupAggregation.Mean fld -> [ oldFields.[fld] ]\n           | GroupAggregation.CountAll -> [ { Name = \"count\"; Type = PrimitiveType.Number } ]\n           | GroupAggregation.CountDistinct fld -> [ { Name = oldFields.[fld].Name; Type = PrimitiveType.Number } ])\n      \n  let transformFields fields tfs = \n    tfs |> List.fold singleTransformFields (List.ofSeq fields) |> List.ofSeq\n\n// ------------------------------------------------------------------------------------------------\n// Pivot provider\n// ------------------------------------------------------------------------------------------------\n\nopen TheGamma.TypeProviders.ProviderHelpers\n\nlet trimLeft c (s:string) = s.ToCharArray() |> Array.skipWhile ((=) c) |> System.String\nlet trimRight c (s:string) = s.ToCharArray() |> Array.rev |> Array.skipWhile ((=) c) |> Array.rev |> System.String\n\nlet concatUrl (a:string) (b:string) =\n  (trimRight '/' a) + \"/\" + (trimLeft '/' b)\n\ntype PivotObject(members:seq<Member>) =\n  member x.MemberNames = [ for m in members -> m.Name ]\n  interface ObjectType with \n    member x.Members = Array.ofSeq members \n    member x.TypeEquals y = \n      match y with\n      | :? PivotObject as y -> y.MemberNames = x.MemberNames \n      | _ -> false\n\nlet makeObjectType members = Type.Object(PivotObject(members))\n\nlet isNumeric fld = fld = PrimitiveType.Number\nlet isBool fld = fld = PrimitiveType.Bool\nlet isDate fld = fld = PrimitiveType.Date\nlet isConcatenable fld = fld = PrimitiveType.String\n\nlet getTypeAndEmitter = function \n  | PrimitiveType.String -> Type.Primitive(PrimitiveType.String), id\n  | PrimitiveType.Date -> Type.Primitive(PrimitiveType.String), fun e -> NewExpression(ident(\"Date\"), [ident(\"Date\")?parse /@/ [e]], None)\n  | PrimitiveType.Number -> Type.Primitive(PrimitiveType.Number), fun e -> ident \"Number\" /@/ [e]\n  | PrimitiveType.Bool -> Type.Primitive(PrimitiveType.Number), fun e -> ident \"Boolean\" /@/ [e]\n  | PrimitiveType.Unit -> Type.Primitive(PrimitiveType.Unit), fun e -> NullLiteral(None)\n\nlet propertyEmitter = \n  { Emit = fun this -> this }\n\nlet makeMethodEmitter callid pars =\n  { Emit = fun this -> funcN (Seq.length pars) (fun args ->\n      let args = arr [ for v in args -> v ]\n      this?addCall /@/ [str callid; args]) }\n\nlet makeDataEmitter isPreview isSeries convValues tfs = \n  { Emit = fun this -> \n      if isSeries then\n        ident(\"series\")?create /@/ \n          [ this?getData /@/ [convValues; str (Transform.toUrl (List.rev tfs)); bool isPreview]\n            str \"key\"; str \"value\"; str \"\" ]\n      else\n        ident(\"series\")?ordinal /@/ \n          [ this?getData /@/ [convValues; str (Transform.toUrl (List.rev tfs)); bool isPreview]\n            str \"key\"; str \"value\"; str \"\" ] }\n\n\n// ------------------------------------------------------------------------------------------------\n// Transformations\n// ------------------------------------------------------------------------------------------------\n\ntype Context = \n  { Root : string\n    IgnoreFiltersInRange : bool\n    LookupNamed : string -> Type\n    InputFields : Field list\n    Fields : Field list }\n\nlet rec makeProperty ctx name tfs = \n  let meta1 = { Context = \"http://schema.thegamma.net/pivot\"; Type = \"Transformations\"; Data = box tfs  }\n  let meta2 = { Context = \"http://schema.thegamma.net/pivot\"; Type = \"Fields\"; Data = box ctx.Fields  }\n  { Member.Name = name; Type = makePivotType ctx tfs; Metadata = [meta1; meta2]; Emitter = propertyEmitter }\n  \nand makeMethod ctx name tfs callid args = \n  let meta1 = { Context = \"http://schema.thegamma.net/pivot\"; Type = \"Transformations\"; Data = box tfs  }\n  let meta2 = { Context = \"http://schema.thegamma.net/pivot\"; Type = \"Fields\"; Data = box ctx.Fields  }\n  { Member.Name = name; Metadata = [meta1; meta2]\n    Type = \n      Type.Method\n        ( [ for n, t in args -> { MethodArgument.Name = n; Optional = false; Static = false; Type = Type.Primitive t } ],\n          (fun ts -> \n              let ts = List.map fst ts\n              if Types.listsEqual ts args (fun t1 (_, t2) -> Types.typesEqual t1 (Type.Primitive t2)) \n                then Some(makePivotType ctx tfs) else None) )\n    Emitter = makeMethodEmitter callid args }\n\nand makeDataMember ctx name isPreview tfs =\n  let fields = Transform.transformFields ctx.InputFields (List.rev tfs)\n  Log.trace(\"providers\", \"Make data member using transform %O. Got fields: %O\", [| box tfs; box fields |])\n  let isSeries, dataTyp, convValues = \n    match tfs with \n    | (GetSeries _)::_ -> \n        match fields with\n        | [kf; vf] ->  \n            true,\n            FSharpProvider.applyTypes (ctx.LookupNamed \"series\") [Type.Primitive kf.Type; Type.Primitive vf.Type], \n            func \"o\" (fun arg -> \n              arr [ snd (getTypeAndEmitter kf.Type) (arg /?/ num 0.)\n                    snd (getTypeAndEmitter vf.Type) (arg /?/ num 1.) ])\n        | _ -> failwith \"makeDataMember: Series should have key and value\"\n    | _ -> \n        let convs, membs = \n          fields \n            |> Array.ofSeq \n            |> Array.map (fun fld ->\n              let memTy, memConv = getTypeAndEmitter fld.Type\n              let emitter = { Emit = fun inst -> inst /?/ str fld.Name }\n              (fld.Name, memConv),\n              { Member.Name = fld.Name; Type = memTy; Emitter = emitter;\n                Metadata = [docMeta (Documentation.Text \"\")] })\n            |> Array.unzip\n        let recTyp = makeObjectType membs\n        false,\n        FSharpProvider.applyTypes (ctx.LookupNamed \"series\") [Type.Primitive PrimitiveType.Number; recTyp ],\n        func \"o\" (fun arg ->\n          let mems = \n            [ for fld, conv in convs ->\n                ObjectProperty(str fld, conv (arg /?/ str fld), true, None) ]\n          ObjectExpression(mems, None) )\n\n  let tfs = if isSeries then tfs else GetTheData::tfs\n  let meta = \n    [ yield { Context = \"http://schema.thegamma.net/pivot\"; Type = \"Transformations\"; Data = box tfs }\n      yield { Context = \"http://schema.thegamma.net/pivot\"; Type = \"Fields\"; Data = box ctx.Fields  }\n      if isPreview then\n        yield { Context = \"http://schema.thegamma.net\"; Type = \"CompletionItem\"; Data = JsInterop.createObj [\"hidden\", box true] }]\n  { Member.Name = name; Type = dataTyp; Metadata = meta; Emitter = makeDataEmitter isPreview isSeries convValues tfs }\n\nand handleGetSeriesRequest ctx rest k v = \n  match k, v with\n  | \"!\", \"!\" ->\n    [ for field in ctx.Fields ->\n        makeProperty ctx (\"with key \" + field.Name) (GetSeries(field.Name, \"!\")::rest) ]\n    |> makeObjectType\n  | k, \"!\" ->\n    [ for field in ctx.Fields ->\n        makeDataMember ctx (\"and value \" + field.Name) false (GetSeries(k, field.Name)::rest) ]\n    |> makeObjectType\n  | _ -> \n    failwith \"handleGetSeriesRequest: Should not happen\"\n  \nand handlePagingRequest ctx rest pgid ops =\n  let takeMemb = \n    makeMethod ctx \"take\" (Empty::Paging(List.rev (Take(pgid + \"-take\")::ops))::rest) (pgid + \"-take\") [\"count\", PrimitiveType.Number] \n  let skipMemb = \n    makeMethod ctx \"skip\" (Paging(Skip(pgid + \"-skip\")::ops)::rest) (pgid + \"-skip\") [\"count\", PrimitiveType.Number] \n  let thenMemb = \n    makeProperty ctx \"then\" (Empty::Paging(List.rev ops)::rest)\n  ( match ops with\n    | [] -> [skipMemb; takeMemb; thenMemb]\n    | [Skip _] -> [takeMemb; thenMemb]\n    | _ -> failwith \"handlePagingRequest: Shold not happen\" ) |> makeObjectType\n\nand handleDropRequest ctx rest dropped = \n  let droppedFields = set dropped\n  [ yield makeProperty ctx \"then\" (Empty::DropColumns(dropped)::rest)\n    for field in ctx.Fields do\n      if not (droppedFields.Contains field.Name) then\n        yield \n          makeProperty ctx (\"drop \" + field.Name) (DropColumns(field.Name::dropped)::rest) ]\n  |> makeObjectType    \n\nand handleSortRequest ctx rest keys = \n  let usedKeys = set (List.map fst keys)\n  [ yield makeProperty ctx \"then\" (Empty::SortBy(keys)::rest)\n    for field in ctx.Fields do\n      if not (usedKeys.Contains field.Name) then\n        let doc = sprintf \"Use the field '%s' as the next sorting keys\" field.Name\n        let prefix = if keys = [] then \"by \" else \"and by \"\n        yield makeProperty ctx (prefix + field.Name) (SortBy((field.Name, Ascending)::keys)::rest) \n        yield makeProperty ctx (prefix + field.Name + \" descending\") (SortBy((field.Name, Descending)::keys)::rest) ]\n  |> makeObjectType    \n\nand handleWindowRequest ctx rest wndid = \n  [ for field in ctx.Fields do \n      if isDate field.Type || isNumeric field.Type then\n        yield makeMethod ctx (\"window by \" + field.Name) (WindowBy(field.Name, wndid, [])::rest) wndid [\"size\", PrimitiveType.Number] \n        yield makeProperty ctx (\"expanding by \" + field.Name) (ExpandBy(field.Name, [WindowAggregation.LastKey])::rest) ]\n  |> makeObjectType  \n\nand handleWindowExpandAggRequest ctx rest fld make aggs = \n  let containsKey = aggs |> Seq.exists(function\n    | WindowAggregation.FirstKey | WindowAggregation.LastKey | WindowAggregation.MiddleKey -> true\n    | _ -> false)\n  let containsField fld = aggs |> Seq.exists (function \n    | WindowAggregation.Sum f | WindowAggregation.Max f | WindowAggregation.Min f | WindowAggregation.Mean f -> f = fld \n    | WindowAggregation.FirstKey | WindowAggregation.LastKey | WindowAggregation.MiddleKey -> false)\n\n  let makeAggMember name agg = \n    makeProperty ctx name (make(aggs @ [agg])::rest) \n\n  [ if not (List.isEmpty aggs) then\n      yield makeProperty ctx \"then\" (Empty::make(aggs)::rest) \n    if not containsKey then\n      yield makeAggMember (\"first \" + fld) WindowAggregation.FirstKey\n      yield makeAggMember (\"last \" + fld) WindowAggregation.LastKey\n      yield makeAggMember (\"middle \" + fld) WindowAggregation.MiddleKey\n    for fld in ctx.Fields do\n      if not (containsField fld.Name) then\n        if isNumeric fld.Type || isBool fld.Type then\n          yield makeAggMember (\"min \" + fld.Name) (WindowAggregation.Min fld.Name)\n          yield makeAggMember (\"sum \" + fld.Name) (WindowAggregation.Sum fld.Name)\n          yield makeAggMember (\"max \" + fld.Name) (WindowAggregation.Max fld.Name)\n          yield makeAggMember (\"mean \" + fld.Name) (WindowAggregation.Mean fld.Name) ]\n  |> makeObjectType  \n\nand aggregationMembers ctx rest keys aggs = \n  let containsCountAll = aggs |> Seq.exists ((=) GroupAggregation.CountAll)\n  let containsField fld = aggs |> Seq.exists (function \n    | GroupAggregation.CountDistinct f | GroupAggregation.ConcatValues f \n    | GroupAggregation.Sum f | GroupAggregation.Mean f -> f = fld \n    | GroupAggregation.CountAll | GroupAggregation.GroupKey -> false)\n\n  let makeAggMember name agg = \n    makeProperty ctx name (GroupBy(keys,aggs @ [agg])::rest) \n\n  [ yield makeProperty ctx \"then\" (Empty::GroupBy(keys, aggs)::rest) \n    if not containsCountAll then \n      yield makeAggMember \"count all\" GroupAggregation.CountAll\n    for fld in ctx.Fields do\n      if not (containsField fld.Name) then\n        yield makeAggMember (\"count distinct \" + fld.Name) (GroupAggregation.CountDistinct fld.Name) \n        if isConcatenable fld.Type then\n          yield makeAggMember (\"concatenate values of \" + fld.Name) (GroupAggregation.ConcatValues fld.Name)\n        if isNumeric fld.Type || isBool fld.Type then\n          yield makeAggMember (\"average \" + fld.Name) (GroupAggregation.Mean fld.Name)\n          yield makeAggMember (\"sum \" + fld.Name) (GroupAggregation.Sum fld.Name) ]\n\nand handleGroupAggRequest ctx rest keys aggs =\n  aggregationMembers ctx rest keys aggs  \n  |> makeObjectType  \n  \nand handleGroupRequest ctx rest keys = \n  let prefix = if List.isEmpty keys then \"by \" else \"and \"\n  [ for field in ctx.Fields ->\n      makeProperty ctx (prefix + field.Name) (GroupBy(field.Name::keys, [])::rest) \n    if not (List.isEmpty keys) then\n      yield! aggregationMembers ctx rest keys [GroupAggregation.GroupKey] ]\n  |> makeObjectType  \n\nand handleFilterEqNeqRequest ctx rest (fld, eq) op conds = async {\n  let tfs = \n    if op = Or then rest \n    elif List.isEmpty conds then rest \n    else FilterBy(op, conds)::rest\n  let tfs = \n    tfs |> List.filter (function \n      | FilterBy _ when ctx.IgnoreFiltersInRange -> false \n      | FilterBy(_, conds) when conds |> List.exists (function ((Equals | NotEquals), _, _) -> false | _ -> true) -> false\n      | _ -> true)\n  let url = ctx.Root + \"?\" + (GetRange(fld)::tfs |> List.rev |> Transform.toUrl |> Fable.Import.JS.encodeURIComponent)\n  let! options = Http.Request(\"GET\", url)\n  let options = jsonParse<string[]> options\n  return\n    [ for opt in options do\n        yield makeProperty ctx opt (FilterBy(op, (eq, fld, opt)::conds)::rest) ] \n    |> makeObjectType }\n\nand handleFilterRequest ctx rest flid op conds = \n  let prefixes = \n    match conds, op with\n    | [], _ -> [\"\", And] \n    | _::[], _ -> [\"and \", And; \"or \", Or]\n    | _, And -> [\"and \", And] \n    | _, Or -> [\"or \", Or]\n  [ for prefix, op in prefixes do\n      for field in ctx.Fields do\n        if field.Type = PrimitiveType.String then\n          yield makeProperty ctx (prefix + field.Name + \" is\") (FilterBy(op, (Equals, field.Name, \"!\")::conds)::rest) \n          yield makeProperty ctx (prefix + field.Name + \" is not\") (FilterBy(op, (NotEquals, field.Name, \"!\")::conds)::rest) \n          yield makeMethod ctx (prefix + field.Name + \" contains\") (FilterBy(op, (Like, field.Name, flid)::conds)::rest) flid [\"text\", PrimitiveType.String]\n        if field.Type = PrimitiveType.Number then\n          yield makeMethod ctx (prefix + field.Name + \" is less than\") (FilterBy(op, (LessThan, field.Name, flid)::conds)::rest) flid [\"value\", PrimitiveType.Number]\n          yield makeMethod ctx (prefix + field.Name + \" is greater than\") (FilterBy(op, (GreaterThan, field.Name, flid)::conds)::rest) flid [\"value\", PrimitiveType.Number]\n          yield makeMethod ctx (prefix + field.Name + \" is in range\") (FilterBy(op, (InRange, field.Name, flid)::conds)::rest) flid [\"minimum\", PrimitiveType.Number; \"maximum\", PrimitiveType.Number]\n        if field.Type = PrimitiveType.Date then\n          yield makeMethod ctx (prefix + field.Name + \" is less than\") (FilterBy(op, (LessThan, field.Name, flid)::conds)::rest) flid [\"value\", PrimitiveType.Date]\n          yield makeMethod ctx (prefix + field.Name + \" is greater than\") (FilterBy(op, (GreaterThan, field.Name, flid)::conds)::rest) flid [\"value\", PrimitiveType.Date]\n          yield makeMethod ctx (prefix + field.Name + \" is in range\") (FilterBy(op, (InRange, field.Name, flid)::conds)::rest) flid [\"minimum\", PrimitiveType.Date; \"maximum\", PrimitiveType.Date]\n    if not (List.isEmpty conds) then\n      yield makeProperty ctx \"then\" (Empty::FilterBy(op, conds)::rest) ]\n  |> makeObjectType  \n\nand makePivotTypeImmediate ctx tfs = async {\n  let last, rest = match tfs with last::rest -> last, rest | _ -> Empty, []\n  let ctx = { ctx with Fields = Transform.transformFields ctx.InputFields (List.rev rest) }\n  match last with\n  // Starting a new pivoting operation\n  | Empty ->\n    return\n      [ yield makeProperty ctx \"group data\" (GroupBy([], [])::rest) \n        yield makeProperty ctx \"filter data\" (FilterBy(And, [])::rest) \n        yield makeProperty ctx \"sort data\" (SortBy([])::rest) \n        yield makeProperty ctx \"drop columns\" (DropColumns([])::rest) \n        yield makeProperty ctx \"paging\" (Paging([])::rest) \n        yield makeProperty ctx \"get series\" (GetSeries(\"!\",\"!\")::rest) \n        yield makeDataMember ctx \"get the data\" false rest \n        if ctx.Fields |> List.exists (fun fld -> fld.Type = PrimitiveType.Date || fld.Type = PrimitiveType.Number) then\n          yield makeProperty ctx \"windowing\" (WindowBy(\"!\", \"!\", [])::rest) ]\n      |> makeObjectType    \n  // \n  | GetSeries(k, v) ->\n      return handleGetSeriesRequest ctx rest k v\n  | Paging(ops) ->\n      let pgid = rest |> Seq.sumBy (function Paging _ -> 1 | _ -> 0) |> sprintf \"pgid-%d\"  \n      return handlePagingRequest ctx rest pgid ops\n  | SortBy(keys) ->\n      return handleSortRequest ctx rest keys\n  | DropColumns(dropped) ->\n      return handleDropRequest ctx rest dropped\n  | FilterBy(fop, (rop & (Equals | NotEquals), fld, \"!\")::conds) ->\n      return! handleFilterEqNeqRequest ctx rest (fld, rop) fop conds\n  | FilterBy(op, conds) ->\n      let flid = conds.Length + (Seq.sumBy (function FilterBy(_, cds) -> cds.Length | _ -> 0) rest)\n      return handleFilterRequest ctx rest (sprintf \"flid-%d\" flid) op conds\n  | WindowBy(\"!\", \"!\", []) ->\n      let wnid = rest |> Seq.sumBy (function WindowBy _ -> 1 | _ -> 0) |> sprintf \"wnid-%d\"\n      return handleWindowRequest ctx rest wnid\n  | WindowBy(fld, size, aggs) ->\n      return handleWindowExpandAggRequest ctx rest fld (fun aggs -> WindowBy(fld, size, aggs)) aggs\n  | ExpandBy(fld, aggs) ->\n      return handleWindowExpandAggRequest ctx rest fld (fun aggs -> ExpandBy(fld, aggs)) aggs\n  | GroupBy(flds, []) ->\n      return handleGroupRequest ctx rest flds\n  | GroupBy(flds, aggs) ->\n      return handleGroupAggRequest ctx rest flds aggs \n  | GetTheData | GetRange _ | Metadata ->\n      return failwith \"makePivotTypeImmediate: GetTheData, GetRange and Metadata shouldn't be of pivot type\" }\n\nand adjustForPreview tfs = \n  match tfs with\n  | WindowBy(_,\"!\",_)::tfs -> tfs // We do not yet know the size \n  | GroupBy([], _)::tfs -> tfs // We do not yet know the grouping key, so return original data\n  | GroupBy(k, [])::tfs -> GroupBy(k, [GroupAggregation.GroupKey])::tfs // We do not have any aggregations yet\n  | GetSeries _::tfs -> tfs // We do not yet know the key/value of the series, so return original data\n  | _ -> tfs\n\nand withPreview ctx tfs typ = \n  match typ with\n  | Type.Object(o) -> \n      let preview = makeDataMember ctx \"preview\" true (adjustForPreview tfs)\n      makeObjectType (Array.append [| preview |] o.Members) \n  | typ -> failwith \"withPreview: Expected object type\"\n\nand makePivotType ctx tfs = \n  let guid = Transform.toUrl tfs\n  let typ = async {\n    try\n      let! typ = makePivotTypeImmediate ctx tfs\n      return withPreview ctx tfs typ \n    with e ->\n      Log.exn(\"providers\", \"Failed when generating type for %O with exception %O\", tfs, e)      \n      return raise e }\n  Type.Delayed(Async.CreateNamedFuture guid typ)\n  \nlet makePivotExpression root = \n  NewExpression(ident(\"PivotContext\"), [str root; ArrayExpression([], None)], None)\n\nlet makePivotGlobalValue root name lookupNamed ignoreFilter fields =\n  let fields = [ for f, t in fields -> { Name = f; Type = t }]\n  let typ = makePivotType { Fields = fields; InputFields = fields; LookupNamed = lookupNamed; Root = root; IgnoreFiltersInRange = ignoreFilter } []\n  let meta1 = { Context = \"http://schema.thegamma.net/pivot\"; Type = \"Transformations\"; Data = box []  }\n  let meta2 = { Context = \"http://schema.thegamma.net/pivot\"; Type = \"Fields\"; Data = box fields  }\n  ProvidedType.GlobalValue( name, [meta1; meta2], makePivotExpression root, typ)\n\nlet providePivotType root ignoreFilter name lookupNamed = async {\n  let! membersJson = Http.Request(\"GET\", root + \"?metadata\")\n  let fields = JsHelpers.properties(jsonParse<obj> membersJson) |> Array.map (fun kv -> \n    let typ = \n      match unbox kv.value with\n      | \"string\" -> PrimitiveType.String\n      | \"bool\" -> PrimitiveType.Bool\n      | \"number\" -> PrimitiveType.Number\n      | \"date\" -> PrimitiveType.Date\n      | s -> failwith (sprintf \"The property '%s' has invalid type '%s'. Only 'string', 'number' and 'bool' are supported.\" kv.key s)\n    kv.key, typ)\n  return makePivotGlobalValue root name lookupNamed ignoreFilter fields }","﻿// ------------------------------------------------------------------------------------------------\n// Binder attaches `Entity` objects to `Node` objects produced by the parser\n// Entities are reused when possible and contain inferred types etc.\n// ------------------------------------------------------------------------------------------------\nmodule TheGamma.Binder\n\nopen TheGamma.Ast\nopen TheGamma.Common\n\n/// Represents case of the EntityKind union\ntype EntityCode = int\n\n/// As we bind, we keep root entity, current scope & variables in scope\ntype BindingContext = \n  { Variables : Map<Name, Entity>  \n    GlobalValues : Map<Name, Entity>\n    Root : Entity\n\n    /// When we are in `foo(fun x -> ...)` the `x` is linked to the call site \n    CallSite : Entity option\n    /// When we are in `foo.[name:x].bar` the Chain represents `foo` so that `x` can be a member\n    Chain : Entity option\n\n    /// Table with previously created entities. This is a mutable mapping from \n    /// list of symbols (antecedent entities) together with entity kind & name\n    /// to the actual entity. Antecedents capture dependencies (if dependency \n    /// changed, we need to recreate the entity that depends on them)\n    Table : ListDictionary<Symbol, Map<EntityCode * string, Entity>> \n    /// Collects all bound entities and their ranges\n    Bound : ResizeArray<Range * Entity> }\n\n/// Represents result of binding syntax tree to entities \n/// (provides access to all bound entities & children lookup function)\ntype BindingResult(ents:(Range * Entity)[]) = \n  let childrenLookup = \n    let res = System.Collections.Generic.Dictionary<Symbol, ResizeArray<Entity>>()\n    let add a e = \n      if not (res.ContainsKey(a)) then res.Add(a, ResizeArray())\n      res.[a].Add(e)\n    for _, e in ents do\n      for a in e.Antecedents do\n        add a.Symbol e\n    res \n  member x.Entities = ents\n  member x.GetChildren(ent) = \n    match childrenLookup.TryGetValue(ent.Symbol) with true, res -> res.ToArray() | _ -> [||]\n\n/// Lookup entity (if it can be reused) or create & cache a new one\nlet bindEntity ctx kind =\n  let code, antecedents, name = entityCodeNameAndAntecedents kind\n  let symbols = ctx.Root::antecedents |> List.map (fun a -> a.Symbol)\n  let nestedDict = \n    match ListDictionary.tryFind symbols ctx.Table with\n    | None -> Map.empty\n    | Some res -> res\n  if nestedDict.ContainsKey (code, name) then \n    Log.trace(\"binder\", \"Cached: binding %s %s\", formatEntityKind kind, name)\n    nestedDict.[code, name]\n  else\n    Log.trace(\"binder\", \"New: binding %s %s\", formatEntityKind kind, name)\n    let symbol = createSymbol ()\n    let entity = { Kind = kind; Symbol = symbol; Type = None; Errors = []; Meta = []; Value = None }\n    ListDictionary.set symbols (Map.add (code, name) entity nestedDict) ctx.Table\n    entity    \n\n/// Assign entity to a node in parse tree\nlet setEntity ctx node entity = \n  ctx.Bound.Add(node.Range, entity)\n  node.Entity <- Some entity\n  entity\n\n/// Bind entities to expressions in the parse tree\n/// (See `EntityKind` for explanation of how the entity tree looks like)\nlet rec bindExpression ctx node = \n  let bindCallArgExpression site ctx = bindExpression { ctx with CallSite = Some site; Chain = None }\n  let bindMemberExpression chain ctx = bindExpression { ctx with CallSite = None; Chain = Some chain }\n  let bindPlaceExpression ctx = bindExpression { ctx with CallSite = None }\n  let bindExpression ctx = bindExpression { ctx with CallSite = None; Chain = None }\n\n  match node.Node with\n  | Expr.Placeholder(name, body) ->\n      // Keep `ctx.Chain` in case the plceholder contains member access\n      let bodyEnt = bindPlaceExpression ctx body\n      bindEntity ctx (EntityKind.Placeholder(name.Node, bodyEnt)) |> setEntity ctx node |> ignore\n      bodyEnt\n\n  | Expr.Variable(name) ->\n      // Variable is actually member access inside chain or placeholder inside chain\n      match ctx.Chain with\n      | Some chain -> \n          let memberName = bindEntity ctx (EntityKind.MemberName(name.Node)) |> setEntity ctx name\n          bindEntity ctx (EntityKind.Member(chain, memberName)) |> setEntity ctx node \n      | _ -> \n      // Variable is a local variable defined somewhere in context\n      match ctx.Variables.TryFind name.Node with \n      | Some decl -> bindEntity ctx (EntityKind.Variable(name.Node, decl)) |> setEntity ctx node\n      | _ ->\n      // Variable is a global, known or unknown variable\n      match ctx.GlobalValues.TryFind name.Node with \n      | Some glob -> glob |> setEntity ctx node\n      | _ -> bindEntity ctx (EntityKind.GlobalValue(name.Node, None)) |> setEntity ctx node\n\n  | Expr.Call(instExpr, argsNode) ->\n      // Bind instance & create call site that depends on it\n      let inst = bindExpression ctx instExpr\n      let site arg = bindEntity ctx (EntityKind.CallSite(inst, arg))\n      // Bind arguments - which depend on the call site\n      let args = argsNode.Node |> List.mapi (fun idx arg -> \n          let site = site (match arg.Name with Some n -> Choice1Of2 n.Node.Name | _ -> Choice2Of2 idx)\n          let expr = bindCallArgExpression site ctx arg.Value\n          match arg.Name with \n          | Some n -> bindEntity ctx (EntityKind.NamedParam(n.Node, expr)) |> setEntity ctx n\n          | None -> expr)\n      let args = bindEntity ctx (EntityKind.ArgumentList(args)) |> setEntity ctx argsNode\n      bindEntity ctx (EntityKind.Call(inst, args)) |> setEntity ctx node \n\n  | Expr.Member(instExpr, memExpr) ->\n      let instEnt = bindExpression ctx instExpr\n      let memEnt = bindMemberExpression instEnt ctx memExpr \n      bindEntity ctx (EntityKind.MemberAccess(memEnt)) |> setEntity ctx node\n\n  | Expr.Binary(lExpr, op, rExpr) ->\n      let lEnt = bindExpression ctx lExpr\n      let rEnt = bindExpression ctx rExpr\n      bindEntity ctx (EntityKind.Operator(lEnt, op.Node, rEnt)) |> setEntity ctx node\n\n  | Expr.List(elExprs) ->\n      let elEnts = elExprs |> List.map (bindExpression ctx)\n      bindEntity ctx (EntityKind.List(elEnts)) |> setEntity ctx node\n\n  | Expr.Function(var, bodyExpr) ->\n      let callSite = match ctx.CallSite with Some s -> s | None -> failwith \"bindExpression: Function missing call site\"\n      let varEnt = bindEntity ctx (EntityKind.Binding(var.Node, callSite)) |> setEntity ctx var\n      let bodyEnt = bindExpression { ctx with Variables = Map.add var.Node varEnt ctx.Variables } bodyExpr\n      bindEntity ctx (EntityKind.Function(varEnt, bodyEnt)) |> setEntity ctx node\n\n  | Expr.Boolean b -> bindEntity ctx (EntityKind.Constant(Constant.Boolean b)) |> setEntity ctx node\n  | Expr.String s -> bindEntity ctx (EntityKind.Constant(Constant.String s)) |> setEntity ctx node\n  | Expr.Number n -> bindEntity ctx (EntityKind.Constant(Constant.Number n)) |> setEntity ctx node\n  | Expr.Empty -> bindEntity ctx (EntityKind.Constant Constant.Empty) |> setEntity ctx node\n\n/// Bind entities to a command in a parse tree. The handling of `let` is similar\n/// to the handling of lambda abstraction. This adds variables to context - we ignore\n/// bound entities, because nothing depends on it (except via variables)\nlet bindCommand ctx node =\n  match node.Node with\n  | Command.Let(v, e) ->\n      let body = bindExpression ctx e \n      let var = bindEntity ctx (EntityKind.Variable(v.Node, body)) |> setEntity ctx v\n      let node = bindEntity ctx (EntityKind.LetCommand(var, body)) |> setEntity ctx node\n      { ctx with Variables = Map.add v.Node var ctx.Variables }, node\n\n  | Command.Expr(e) ->\n      let body = bindExpression ctx e \n      let node = bindEntity ctx (EntityKind.RunCommand(body)) |> setEntity ctx node\n      ctx, node\n\n/// Bind entities to all nodes in the program\nlet bindProgram ctx (program:Program) =\n  ctx.Bound.Clear()\n  let _, ents = \n    program.Body.Node |> List.fold (fun (ctx, nodes) cmd -> \n      let ctx, node = bindCommand ctx cmd\n      ctx, node::nodes) (ctx, [])  \n  bindEntity ctx (EntityKind.Program(ents)) |> setEntity ctx program.Body,\n  BindingResult(ctx.Bound.ToArray())\n  \n/// Create a new binding context - this stores cached entities\nlet createContext (globals:list<Entity>) name =\n  let root = \n    { Kind = EntityKind.Root; Errors = []; Symbol = createSymbol(); Type = None; Meta = []; Value = None }\n  { Table = System.Collections.Generic.Dictionary<_, _>(); \n    Bound = ResizeArray<_>(); Variables = Map.empty; \n    GlobalValues = Map.ofList [ for e in globals -> { Name = e.Name }, e ]\n    Root = root; CallSite = None; Chain = None }","import { defaultCancellationToken } from \"./Async\";\r\nimport { fromContinuations } from \"./Async\";\r\nimport { startImmediate } from \"./Async\";\r\nvar QueueCell = (function () {\r\n    function QueueCell(message) {\r\n        this.value = message;\r\n    }\r\n    return QueueCell;\r\n}());\r\nvar MailboxQueue = (function () {\r\n    function MailboxQueue() {\r\n    }\r\n    MailboxQueue.prototype.add = function (message) {\r\n        var itCell = new QueueCell(message);\r\n        if (this.firstAndLast) {\r\n            this.firstAndLast[1].next = itCell;\r\n            this.firstAndLast = [this.firstAndLast[0], itCell];\r\n        }\r\n        else\r\n            this.firstAndLast = [itCell, itCell];\r\n    };\r\n    MailboxQueue.prototype.tryGet = function () {\r\n        if (this.firstAndLast) {\r\n            var value = this.firstAndLast[0].value;\r\n            if (this.firstAndLast[0].next)\r\n                this.firstAndLast = [this.firstAndLast[0].next, this.firstAndLast[1]];\r\n            else\r\n                delete this.firstAndLast;\r\n            return value;\r\n        }\r\n        return void 0;\r\n    };\r\n    return MailboxQueue;\r\n}());\r\nvar MailboxProcessor = (function () {\r\n    function MailboxProcessor(body, cancellationToken) {\r\n        this.body = body;\r\n        this.cancellationToken = cancellationToken || defaultCancellationToken;\r\n        this.messages = new MailboxQueue();\r\n    }\r\n    MailboxProcessor.prototype.__processEvents = function () {\r\n        if (this.continuation) {\r\n            var value = this.messages.tryGet();\r\n            if (value) {\r\n                var cont = this.continuation;\r\n                delete this.continuation;\r\n                cont(value);\r\n            }\r\n        }\r\n    };\r\n    MailboxProcessor.prototype.start = function () {\r\n        startImmediate(this.body(this), this.cancellationToken);\r\n    };\r\n    MailboxProcessor.prototype.receive = function () {\r\n        var _this = this;\r\n        return fromContinuations(function (conts) {\r\n            if (_this.continuation)\r\n                throw new Error(\"Receive can only be called once!\");\r\n            _this.continuation = conts[0];\r\n            _this.__processEvents();\r\n        });\r\n    };\r\n    MailboxProcessor.prototype.post = function (message) {\r\n        this.messages.add(message);\r\n        this.__processEvents();\r\n    };\r\n    MailboxProcessor.prototype.postAndAsyncReply = function (buildMessage) {\r\n        var result;\r\n        var continuation;\r\n        function checkCompletion() {\r\n            if (result && continuation)\r\n                continuation(result);\r\n        }\r\n        var reply = {\r\n            reply: function (res) {\r\n                result = res;\r\n                checkCompletion();\r\n            }\r\n        };\r\n        this.messages.add(buildMessage(reply));\r\n        this.__processEvents();\r\n        return fromContinuations(function (conts) {\r\n            continuation = conts[0];\r\n            checkCompletion();\r\n        });\r\n    };\r\n    return MailboxProcessor;\r\n}());\r\nexport default MailboxProcessor;\r\nexport function start(body, cancellationToken) {\r\n    var mbox = new MailboxProcessor(body, cancellationToken);\r\n    mbox.start();\r\n    return mbox;\r\n}\r\n","﻿// ------------------------------------------------------------------------------------------------\n// Tokenizer for TheGamma script language - turns string into Token[]\n// ------------------------------------------------------------------------------------------------\nmodule TheGamma.Tokenizer\nopen TheGamma\n\n/// Tokenization context for storing input, errors & parsed tokens\ntype Context = \n  { Tokens : ResizeArray<Token>\n    Errors : ResizeArray<Error<Range>>\n    Input : string }\n\n/// Test whether 's' has 'prefix' at offset 'i'. The\n/// parameter 'j' is index inside prefix where we're starting.\nlet rec startsWith (s:string) i j (prefix:string) = \n  if j = prefix.Length then true\n  elif i = s.Length then false\n  elif s.[i] <> prefix.[j] then false\n  else startsWith s (i+1) (j+1) prefix\n\n/// Is given character a string?\nlet letter c = (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n\n/// Is given character a number?\nlet number c = c >= '0' && c <= '9'\n\n\n/// Add newly parsed token to the context, increment \n/// offset correctly & continue tokenizing\nlet rec addAndTokenize ctx tok i l =\n  { Token = tok\n    Range = { Start = i; End = i + l - 1 } } |> ctx.Tokens.Add \n  tokenizeInput ctx (i + l)\n\n\n/// Tokenize identifier (continue consuming letters & characters)\nand tokenizeIdent ctx start l =\n  if start + l < ctx.Input.Length && \n      (letter ctx.Input.[start+l] || number ctx.Input.[start+l]) then\n    tokenizeIdent ctx start (l+1)\n  else\n    addAndTokenize ctx (TokenKind.Ident(ctx.Input.Substring(start, l))) start l\n\n\n/// Tokenize string (until end of input or closing double-quote)\nand tokenizeString ctx acc start l =\n  if start + l >= ctx.Input.Length then \n    tokenizeStringEnd true ctx acc start l\n  else\n    match ctx.Input.[start + l] with\n    | '\\\\' when start + l + 1 >= ctx.Input.Length ->\n        tokenizeStringEnd true ctx ('\\\\'::acc) start (l + 1)\n    | '\\\\' ->\n        match ctx.Input.[start + l + 1] with\n        | 'n' -> tokenizeString ctx ('\\n'::acc) start (l + 2)\n        | 't' -> tokenizeString ctx ('\\t'::acc) start (l + 2)\n        | '\\\\' -> tokenizeString ctx ('\\\\'::acc) start (l + 2)\n        | '\"' -> tokenizeString ctx ('\"'::acc) start (l + 2)\n        | c -> tokenizeString ctx (c::'\\\\'::acc) start (l + 2)\n    | '\"' -> tokenizeStringEnd false ctx acc start (l + 1)\n    | c -> tokenizeString ctx (c::acc) start (l+1)\n\nand tokenizeStringEnd error ctx acc start l =\n  let str = acc |> List.toArray |> Array.rev |> System.String\n  let rng = { Start = start; End = start + l }\n  if error then ctx.Errors.Add(Errors.Tokenizer.inputEndInsideString rng str) \n  addAndTokenize ctx (TokenKind.String(str)) start l\n\n\n/// Tokenize quoted ident (until end of input or closing single-quote)\nand tokenizeQuotedIdent ctx start l =\n  if start + l >= ctx.Input.Length then \n    tokenizeQuotedIdentEnd true ctx start l\n  else\n    match ctx.Input.[start + l] with\n    | '\\n' -> tokenizeQuotedIdentEnd true ctx start (l + 1)\n    | '\\'' -> tokenizeQuotedIdentEnd false ctx start (l + 1)\n    | c -> tokenizeQuotedIdent ctx start (l + 1)\n\nand tokenizeQuotedIdentEnd error ctx start l =\n  let rng = { Start = start; End = start + l }\n  let qid = ctx.Input.Substring(start + 1, l - if error then 1 else 2)\n  let qid = if qid.EndsWith(\"\\n\") then qid.Substring(0, qid.Length-1) else qid\n  if error then ctx.Errors.Add(Errors.Tokenizer.missingClosingQuote rng qid) \n  addAndTokenize ctx (TokenKind.QIdent(qid)) start l\n\n\n/// Tokenize whitespace - consume all spaces available\nand tokenizeWhite ctx start l =\n  if start + l < ctx.Input.Length && ctx.Input.[start+l] = ' ' then\n    tokenizeWhite ctx start (l+1)\n  else\n    addAndTokenize ctx (TokenKind.White(ctx.Input.Substring(start, l))) start l\n\n\n/// Tokenize number - consume all numbers, or '.' when 'decimal = false'\nand tokenizeNumber ctx decimal start l =\n  if start + l < ctx.Input.Length && number ctx.Input.[start+l] then\n    tokenizeNumber ctx decimal start (l+1)\n  elif start + l < ctx.Input.Length && not decimal && ctx.Input.[start+l] = '.' then\n    tokenizeNumber ctx true start (l+1)\n  else\n    let str = ctx.Input.Substring(start, l)\n    addAndTokenize ctx (TokenKind.Number(str, float str)) start l\n\n\nand tokenizeInput ctx i = \n  // Reached the end of the input\n  if i >= ctx.Input.Length then ctx else\n\n  // Keyword or multi-letter symbol\n  match ctx.Input.[i] with\n  | '-' when startsWith ctx.Input i 0 \"->\" -> \n      addAndTokenize ctx (TokenKind.Arrow) i 2\n  | 'f' when startsWith ctx.Input i 0 \"fun\" -> \n      addAndTokenize ctx (TokenKind.Fun) i 3\n  | 'l' when startsWith ctx.Input i 0 \"let\" -> \n      addAndTokenize ctx (TokenKind.Let) i 3\n  | 't' when startsWith ctx.Input i 0 \"true\" -> \n      addAndTokenize ctx (TokenKind.Boolean true) i 4\n  | 'f' when startsWith ctx.Input i 0 \"false\" -> \n      addAndTokenize ctx (TokenKind.Boolean false) i 5\n  | '<' when startsWith ctx.Input i 0 \"<=\" -> \n      addAndTokenize ctx (TokenKind.Operator Operator.LessThanOrEqual) i 2\n  | '>' when startsWith ctx.Input i 0 \">=\" -> \n      addAndTokenize ctx (TokenKind.Operator Operator.GreaterThanOrEqual) i 2\n\n  // Single-letter tokens\n  | '(' -> addAndTokenize ctx TokenKind.LParen i 1\n  | ')' -> addAndTokenize ctx TokenKind.RParen i 1\n  | '=' -> addAndTokenize ctx TokenKind.Equals i 1\n  | '.' -> addAndTokenize ctx TokenKind.Dot i 1\n  | ',' -> addAndTokenize ctx TokenKind.Comma i 1\n  | ':' -> addAndTokenize ctx TokenKind.Colon i 1\n  | '[' -> addAndTokenize ctx TokenKind.LSquare i 1\n  | ']' -> addAndTokenize ctx TokenKind.RSquare i 1\n  | '\\n' -> addAndTokenize ctx TokenKind.Newline i 1\n\n  // Single-letter operators\n  | '>' -> addAndTokenize ctx (TokenKind.Operator(Operator.GreaterThan)) i 1\n  | '<' -> addAndTokenize ctx (TokenKind.Operator(Operator.LessThan)) i 1\n  | '+' -> addAndTokenize ctx (TokenKind.Operator(Operator.Plus)) i 1\n  | '-' -> addAndTokenize ctx (TokenKind.Operator(Operator.Minus)) i 1\n  | '*' -> addAndTokenize ctx (TokenKind.Operator(Operator.Multiply)) i 1\n  | '%' -> addAndTokenize ctx (TokenKind.Operator(Operator.Modulo)) i 1\n  | '/' -> addAndTokenize ctx (TokenKind.Operator(Operator.Divide)) i 1\n  | '^' -> addAndTokenize ctx (TokenKind.Operator(Operator.Power)) i 1\n  \n  // Symbols that start something (string, whitespace, quoted ident)\n  | '\"' -> tokenizeString ctx [] i 1\n  | ' ' -> tokenizeWhite ctx i 1\n  | '\\'' -> tokenizeQuotedIdent ctx i 1\n  | c ->\n  \n  // Letter starts identifer, number starts number\n  if letter c then tokenizeIdent ctx i 1\n  elif number c then tokenizeNumber ctx false i 1\n  else \n\n  // Otherwise report an error & skip one character\n  ctx.Errors.Add(Errors.Tokenizer.unexpectedCharacter { Start = i; End = i } c)\n  addAndTokenize ctx (TokenKind.Error c) i 1\n\n\n/// Tokenize the given input. Consumes all input characters and returns\n/// list of parsed tokens together with an array of tokenization errors.\nlet tokenize input = \n  let ctx = \n    { Errors = new ResizeArray<_>()\n      Tokens = new ResizeArray<_>()\n      Input = input }\n  let ctx = tokenizeInput ctx 0\n  ctx.Tokens.Add { Token = TokenKind.EndOfFile; Range = { Start = input.Length; End = input.Length } }\n  ctx.Tokens.ToArray(), ctx.Errors.ToArray()\n","﻿// ------------------------------------------------------------------------------------------------\n// Parser for TheGamma script langauge - turns Token[] into Program\n// ------------------------------------------------------------------------------------------------\nmodule TheGamma.Parser\n\nopen TheGamma\nopen TheGamma.Ast\nopen TheGamma.Common\n\n// ------------------------------------------------------------------------------------------------\n// This is mostly a recursive-descent parser\n// ------------------------------------------------------------------------------------------------\n\n/// Parsing context is mutated, because we never backtrack (except for one case,\n/// in which case we clone the context explicitly using `clone`)\ntype ParsingContext = \n  { Tokens : Token[]\n    Whitespace : ResizeArray<Token>\n    Errors : ResizeArray<Error<Range>>\n    mutable SilentMode : bool\n    mutable Position : int }\n\nmodule Context =\n  /// Lets us implement lookahead withot making the whole context immutable\n  /// (this is only used in fairly limited scenarios - e.g. named arguments)\n  let clone ctx = \n    { Tokens = ctx.Tokens\n      Whitespace = ResizeArray(ctx.Whitespace)\n      Errors = ResizeArray(ctx.Errors)\n      Position = ctx.Position\n      SilentMode = ctx.SilentMode }\n\n  /// Advance the position\n  let next ctx = ctx.Position <- ctx.Position + 1\n\n  /// Add specified error to context\n  let error ctx e = if not ctx.SilentMode then ctx.Errors.Add(e)\n\n  /// Run the given function with silent mode on\n  let silent ctx f = \n    ctx.SilentMode <- true\n    let res = f ctx\n    ctx.SilentMode <- false    \n    res\n\n  /// Parses next token & accumulates whitespace. \n  /// Only retrns tokens if they are next or indented.\n  let rec tokenIndent ctx = \n    match ctx.Tokens.[ctx.Position] with\n    | { Token = TokenKind.Newline } as t1 ->\n        match ctx.Tokens.[ctx.Position + 1] with\n        | t2 & { Token = TokenKind.White s } ->\n            next ctx; next ctx\n            ctx.Whitespace.Add t1\n            ctx.Whitespace.Add t2\n            tokenIndent ctx\n        | _ -> None\n    | { Token = TokenKind.Error _ | TokenKind.White _ } as t ->\n        ctx.Whitespace.Add t\n        next ctx\n        tokenIndent ctx\n    | t -> \n        let white = ctx.Whitespace |> Seq.toList\n        ctx.Whitespace.Clear()\n        Some(white, t)\n\n  /// Parses next token & accumulates whitespace. \n  /// Only retrns tokens if they are first or non-indented after a newline.\n  let rec tokenNonIndent ctx = \n    match ctx.Tokens.[ctx.Position] with\n    | { Token = TokenKind.Newline } as t1 ->\n\n        // Find next Newline that is followed by non-whitespace (indented or not)\n        let mutable newNonEmptyLinePos = ctx.Position\n        let mutable i = ctx.Position\n        while i < ctx.Tokens.Length do\n          match ctx.Tokens.[i].Token with\n          | TokenKind.Newline -> newNonEmptyLinePos <- i; i <- i + 1\n          | TokenKind.White _ -> i <- i + 1\n          | _ -> i <- ctx.Tokens.Length          \n        ctx.Position <- newNonEmptyLinePos\n\n        // If it was indented, then bad luck...\n        match ctx.Tokens.[ctx.Position + 1] with\n        | { Token = TokenKind.White _ } -> None\n        | t -> \n            next ctx\n            ctx.Whitespace.Add(t1)\n            let white = ctx.Whitespace |> Seq.toList\n            ctx.Whitespace.Clear()\n            Some(white, t)\n\n    | { Token = TokenKind.White _ } when ctx.Position = 0 -> None\n    | t when ctx.Position = 0 || ctx.Position = ctx.Tokens.Length - 1 -> \n        Some([], t)\n    | _ -> None\n\n/// Creates a node with a range and no whitespace\nlet node rng n = \n  { Node = n; Range = rng; WhiteBefore = []; WhiteAfter = []; Entity = None }\n\n/// Appends whitespace after node\nlet whiteAfter w n = { n with WhiteAfter = n.WhiteAfter @ w  }\n\n/// Preppends whitespace beforenode\nlet whiteBefore w n = { n with WhiteBefore = w @ n.WhiteBefore }\n\n/// Parsed token is identifier or quoted identifier (with preceding whitespace)\nlet (|Identifier|_|) t = \n  match t with\n  | white, { Range = rng; Token = (TokenKind.Ident id | TokenKind.QIdent id) } ->\n      node rng { Name.Name = id } |> whiteBefore white |> Some\n  | _ -> None\n\n// ------------------------------------------------------------------------------------------------\n// Operator precedence handling\n// ------------------------------------------------------------------------------------------------\n\ntype Associativity = Left | Right\n\nlet precedence = function\n  | Operator.Equals -> 0, Left\n  | Operator.GreaterThan | Operator.GreaterThanOrEqual\n  | Operator.LessThan | Operator.LessThanOrEqual -> 1, Left\n  | Operator.Plus | Operator.Minus -> 2, Left\n  | Operator.Modulo | Operator.Multiply | Operator.Divide -> 3, Left\n  | Operator.Power -> 4, Right\n  \n/// Represnts a sequence of expressions separated by binary operators\n/// (e.g. 'f x + 1 * 2 / g y' has 4 expressions separated by 3 operators)\ntype OpExpr = OpExpr of Node<Expr> * option<Node<Operator> * OpExpr>\n\n/// Turn 'OpExpr' into a parsed 'Expr' using the \"Precedence climbing method\"\n/// (see https://en.wikipedia.org/wiki/Operator-precedence_parser)\nlet rec precClimb minPrec (OpExpr(app, next)) =   \n  let rec loop result (next:(Node<Operator>*OpExpr) option) = \n    match next with \n    | Some(op, next) when fst (precedence op.Node) >= minPrec ->\n        let prec, assoc = precedence op.Node\n        let nextMinPrec = \n          if assoc = Left then prec + 1 else prec\n        let rhs, next = precClimb nextMinPrec next\n        let result = node (unionRanges result.Range rhs.Range) (Expr.Binary(result, op, rhs))\n        loop result next\n    | _ -> result, next      \n  loop app next\n\n/// The terms are passed in reverse order as accumulated\nlet buildExpression terms term =\n  terms \n  |> List.fold (fun oe (t, op) -> OpExpr(t, Some(op, oe))) (OpExpr(term, None))\n  |> precClimb 0\n  |> fst\n\n// ------------------------------------------------------------------------------------------------\n// The parser - member access and calls\n// ------------------------------------------------------------------------------------------------\n\n/// Try parsing input as '<id> = <expr>', if that does not work, treat it as <expr>\nlet rec parseExpressionOrNamedParam ctx = \n  let lookAheadCtx = Context.clone ctx\n  match Context.tokenIndent lookAheadCtx with\n  | Some(Identifier id) ->\n      Context.next lookAheadCtx\n      match Context.tokenIndent lookAheadCtx with\n      | Some(white, ({ Token = TokenKind.Equals } as t)) ->\n          // Replay what we did on lookahead context on the original context\n          ignore (Context.tokenIndent ctx); Context.next ctx\n          ignore (Context.tokenIndent ctx); Context.next ctx\n          match parseExpression [] ctx with\n          | Some expr -> Choice1Of2(whiteAfter white id, expr)\n          | None -> \n              Errors.Parser.unexpectedTokenInArgList t.Range t.Token |> Context.error ctx\n              Choice1Of2(whiteAfter white id, node { Start = id.Range.End; End = id.Range.End } Expr.Empty)\n      | _ -> Choice2Of2(parseExpression [] ctx)\n  | _ -> \n      Choice2Of2(parseExpression [] ctx)\n    \n\n/// Parse a comma separated list of expressions or named parameter assignments -- after `(`\nand parseCallArgList afterComma lastRng acc ctx = \n  let parsed, acc = \n    match parseExpressionOrNamedParam ctx with\n    | Choice2Of2(None) -> false, acc\n    | Choice2Of2(Some e) -> true, { Name = None; Value = e }::acc\n    | Choice1Of2(id, e) -> true, { Name = Some id; Value = e }::acc\n  match Context.tokenIndent ctx with\n  | Some(white, ({ Token = TokenKind.RParen } as t)) ->\n      Context.next ctx\n      if afterComma && not parsed then        \n        Errors.Parser.unexpectedTokenInArgList lastRng TokenKind.RParen |> Context.error ctx\n      t.Range, white, List.rev acc\n\n  | Some(white, { Token = TokenKind.Comma; Range = lastRng }) when parsed ->\n      Context.next ctx\n      parseCallArgList true lastRng acc ctx\n\n  | Some(_, t) when t.Token <> TokenKind.EndOfFile ->\n      // Skip over unexpected, but correctly nested tokens\n      Context.next ctx\n      Errors.Parser.unexpectedTokenInArgList t.Range t.Token |> Context.error ctx\n      Context.silent ctx (fun ctx -> \n        parseCallArgList afterComma t.Range acc ctx)\n  | _ ->\n      // Unexpected end of nesting - end argument list now\n      Errors.Parser.unexpectedScopeEndInArgList lastRng |> Context.error ctx\n      lastRng, [], List.rev acc\n\n\n/// If something goes wrong inside placeholder, this skips over everything until `]`\nand parsePlaceholderRecovery silent lastTokRng lastTokOpt whiteAcc ctx =\n  match Context.tokenIndent ctx with\n  | Some(white, { Token = TokenKind.RSquare; Range = lastTokRng }) ->\n      Context.next ctx\n      if not silent then Errors.Parser.unexpectedEndOfPlaceholder lastTokRng |> Context.error ctx\n      lastTokRng, whiteAcc @ white\n\n  | Some(white, t) when t.Token <> TokenKind.EndOfFile ->\n      // Skip over unexpected, but correctly nested tokens\n      Context.next ctx\n      if not silent then Errors.Parser.unexpectedTokenInPlaceholder t.Range t.Token |> Context.error ctx\n      parsePlaceholderRecovery true t.Range (Some t.Token) (whiteAcc @ white @ [t]) ctx\n\n  | _ ->\n      // Unexpected end of placeholder - end placeholder now\n      if not silent then Errors.Parser.unexpectedScopeEndInPlaceholder lastTokRng lastTokOpt |> Context.error ctx\n      lastTokRng, whiteAcc\n\n\n/// Parse placeholder after parsing `[` -- the full syntax is `[ident: <expr>]`\nand parsePlaceholder rngLSQuare ctx = \n  match Context.tokenIndent ctx with\n  | Some(Identifier id & (_, tokId)) ->\n      Context.next ctx\n      match Context.tokenIndent ctx with\n      | Some(whiteBeforeColon, { Token = TokenKind.Colon; Range = rngColon }) ->\n          Context.next ctx\n          match parseExpression [] ctx with\n          | Some body ->\n              match Context.tokenIndent ctx with\n              | Some(whiteBeforeSquare, { Token = TokenKind.RSquare; Range = rngRSquare }) ->\n                  Context.next ctx\n                  rngRSquare, Expr.Placeholder(whiteAfter whiteBeforeColon id, whiteAfter whiteBeforeSquare body)\n              | _ ->\n                  // RECOVERY: Skip everything until `]` or end of indentation\n                  let rng, white = parsePlaceholderRecovery false body.Range None [] ctx\n                  rng, Expr.Placeholder(id, whiteAfter white body)\n          | _ ->\n              // RECOVERY: Skip everything until `]` or end of indentation\n              let rng, white = parsePlaceholderRecovery false rngColon (Some TokenKind.Colon) [] ctx\n              rng, Expr.Placeholder(id, whiteAfter white (node rng Expr.Empty))\n      | _ ->\n          // RECOVERY: Skip everything until `]` or end of indentation\n          let rng, white = parsePlaceholderRecovery false id.Range (Some tokId.Token) [] ctx\n          rng, Expr.Placeholder(id, whiteAfter white (node rng Expr.Empty))\n    | _ ->\n        // RECOVERY: Skip everything until `]` or end of indentation\n        let rng, white = parsePlaceholderRecovery false rngLSQuare (Some TokenKind.LSquare) [] ctx\n        rng, Expr.Placeholder(node rngLSQuare { Name = \"\" }, whiteAfter white (node rng Expr.Empty))\n\n      \n/// Parse `ident` after `.` in `.ident`; skips over non-idents after dot until it finds ident\nand parseIdentAfterDot body prevDotRng prevDotTok ctx =\n  match Context.tokenIndent ctx with\n  | Some(Identifier id) ->\n      Context.next ctx\n      let body = Expr.Member(body, node id.Range (Expr.Variable id)) |> node (unionRanges body.Range id.Range)\n      parseCallOrMember body ctx\n  | Some(white, { Token = TokenKind.LSquare; Range = rngLSQuare }) ->\n      Context.next ctx\n      let rngRSquare, place = parsePlaceholder rngLSQuare ctx\n      let body = \n        Expr.Member(body, node (unionRanges rngRSquare rngLSQuare) place) \n        |> node (unionRanges rngLSQuare rngRSquare) |> whiteBefore white \n      parseCallOrMember body ctx\n  | Some(_, { Token = TokenKind.EndOfFile })\n  | None ->\n      // RECOVERY: Nothing after dot - return body so far\n      Errors.Parser.unexpectedScopeEndAfterDot prevDotRng prevDotTok |> Context.error ctx \n      let emptyRng = { End = prevDotRng.End; Start = prevDotRng.End+1 }\n      Expr.Member(body, node emptyRng (Expr.Variable(node emptyRng {Name=\"\"})))\n      |> node (unionRanges body.Range emptyRng)\n\n  | Some(white, t) ->\n      // RECOVERY: Wrong token after dot - skip and try next\n      Context.next ctx\n      Errors.Parser.unexpectedTokenAfterDot t.Range t.Token |> Context.error ctx \n      let emptyRng = { End = prevDotRng.End; Start = prevDotRng.End+1 }\n      let body =\n        Expr.Member(body, node emptyRng (Expr.Variable(node emptyRng {Name=\"\"})))\n        |> node (unionRanges body.Range emptyRng)\n      Context.silent ctx (parseIdentAfterDot body prevDotRng prevDotTok)\n\n\n\n/// Parse `.ident` or `(args)` after we parsed an expression specified as body\nand parseCallOrMember body ctx = \n  match Context.tokenIndent ctx with\n  | Some(white, { Token = TokenKind.LParen; Range = firstRng }) ->\n      Context.next ctx\n      let lastRng, white, args = parseCallArgList false firstRng [] ctx\n      let body = \n        Expr.Call(body, whiteAfter white (node (unionRanges firstRng lastRng) args)) \n        |> node (unionRanges body.Range lastRng)\n      // Parse more chain elements after `(args).`\n      match Context.tokenIndent ctx with\n      | Some(white, t & { Token = TokenKind.Dot }) ->\n          Context.next ctx\n          parseIdentAfterDot (whiteAfter white body) t.Range t.Token ctx\n      | _ -> body\n            \n  | Some(white, t & { Token = TokenKind.Dot }) ->\n      Context.next ctx\n      parseIdentAfterDot (whiteAfter white body) t.Range t.Token ctx\n\n  | _ -> body      \n\n// ------------------------------------------------------------------------------------------------\n// The parser - functions, lists\n// ------------------------------------------------------------------------------------------------\n\n/// We already parsed `fun`, parse the rest of the function, i.e. `<id> -> <expr>`\nand parseFunction ctx funRng = \n  match Context.tokenIndent ctx with\n  | Some(Identifier id) ->\n      Context.next ctx\n      match Context.tokenIndent ctx with\n      | Some(whiteAfterId, { Token = TokenKind.Arrow; Range = rngArr }) ->\n          Context.next ctx\n          let body = \n            match parseExpression [] ctx with\n            | Some body -> body\n            | _ -> \n                Errors.Parser.missingBodyOfFunc (unionRanges funRng rngArr) |> Context.error ctx\n                node { Start = rngArr.End; End = rngArr.End } Expr.Empty\n          let rng = unionRanges funRng body.Range\n          node rng (Expr.Function(whiteAfter whiteAfterId id, body)) |> Some\n\n      | nt -> \n          // RECOVERY: Missing arrow - try parsing the body anyway\n          let errRng, whiteAfterId = \n            match nt with\n            | None -> unionRanges funRng id.Range, []\n            | Some(whiteAfterId, t) -> t.Range, whiteAfterId\n          Errors.Parser.missingArrowInFunc errRng |> Context.error ctx\n          let body = \n            match parseExpression [] ctx with \n            | Some e -> e \n            | _ -> node {Start=id.Range.End; End=id.Range.End} Expr.Empty\n          node (unionRanges funRng body.Range) \n            (Expr.Function(id, whiteBefore whiteAfterId body)) |> Some            \n          \n  // RECOVERY: Unexpected token or end of scope - return empty function\n  | Some(white, t) ->\n      Errors.Parser.unexpectedTokenAfterFun t.Range t.Token |> Context.error ctx\n      let rng = { Start = funRng.End; End = funRng.End }\n      node rng (Expr.Function(node rng {Name=\"\"}, node rng Expr.Empty)) \n      |> whiteBefore white |> Some\n  \n  | None ->\n      Errors.Parser.unexpectedScopeEndInFunc funRng |> Context.error ctx\n      let rng = { Start = funRng.End; End = funRng.End }\n      node rng (Expr.Function(node rng {Name=\"\"}, node rng Expr.Empty)) |> Some\n    \n\n/// Parse expression followed by a list of more elements or closing square bracket\nand parseListElements afterComma lastRng whiteStart startRng acc ctx =\n  let parsed, acc =  \n    match parseExpression [] ctx with\n    | Some expr -> true, fun white -> (whiteAfter white expr)::acc\n    | _ -> false, fun _ -> acc\n\n  match Context.tokenIndent ctx with\n  | Some(white, { Token = TokenKind.RSquare; Range = endRng }) ->\n      Context.next ctx\n      if not parsed && afterComma then\n        Errors.Parser.unexpectedTokenInList lastRng TokenKind.Comma |> Context.error ctx\n      node (unionRanges startRng endRng) (Expr.List(List.rev (acc []))) |> whiteBefore white |> Some\n\n  | Some(white, { Token = TokenKind.Comma; Range = lastRng }) ->\n      Context.next ctx\n      if not parsed && afterComma then\n        Errors.Parser.unexpectedTokenInList lastRng TokenKind.Comma |> Context.error ctx\n      parseListElements true lastRng whiteStart startRng (acc white) ctx\n\n  | Some(_, t) when t.Token <> TokenKind.EndOfFile ->\n      // Skip over unexpected, but correctly nested tokens\n      Context.next ctx\n      Errors.Parser.unexpectedTokenInList t.Range t.Token |> Context.error ctx\n      Context.silent ctx (fun ctx ->\n        parseListElements afterComma t.Range whiteStart startRng (acc []) ctx)\n  | _ ->\n      // Unexpected end of nesting - end argument list now\n      Errors.Parser.unexpectedScopeEndInList lastRng |> Context.error ctx\n      node (unionRanges startRng lastRng) (Expr.List(List.rev (acc []))) |> Some\n\n\n// ------------------------------------------------------------------------------------------------\n// The parser - terms and expressions\n// ------------------------------------------------------------------------------------------------\n\n/// A term is a single thing inside expression involving operators, i.e.\n///   <expression> := <term> <op> <term> <op> .. <op> <term>\nand parseTerm ctx = \n  match Context.tokenIndent ctx with\n  // Variable or call chain\n  | Some(Identifier id) ->\n      Context.next ctx\n      parseCallOrMember (node id.Range (Expr.Variable id)) ctx |> Some\n\n  // String, numeric and Boolean literals\n  | Some(white, { Token = TokenKind.Number(_, n); Range = r }) ->\n      Context.next ctx\n      node r (Expr.Number n) |> whiteAfter white |> Some\n  | Some(white, { Token = TokenKind.String(s); Range = r }) ->\n      Context.next ctx\n      node r (Expr.String s) |> whiteAfter white |> Some\n  | Some(white, { Token = TokenKind.Boolean(b); Range = r }) ->\n      Context.next ctx\n      node r (Expr.Boolean b) |> whiteAfter white |> Some\n\n  // Parse nested expressions starting with `(` or list starting with `[`\n  | Some(white, ({ Token = TokenKind.LParen } as t)) ->\n      Context.next ctx\n      parseParenTermEnd (t::List.rev white) [] (parseExpression [] ctx) ctx\n  | Some(white, ({ Token = TokenKind.LSquare } as t)) ->\n      Context.next ctx\n      parseListElements false t.Range white t.Range [] ctx\n\n  | Some(white, ({ Token = TokenKind.Fun } as t)) ->\n      Context.next ctx\n      parseFunction ctx t.Range\n\n  // Not a term, but that's fine\n  | _ -> None \n\n\n/// Parse what follows after `(<expr>` - either `)` or some errors \nand parseParenTermEnd wb wa bodyOpt ctx =  \n  // Create parenthesized expression body, or return empty expression if missing\n  let makeBody wa =\n    let body = \n      match bodyOpt with\n      | Some body -> body\n      | None -> \n          let rng = List.append [List.head wb] wa |> List.map (fun t -> t.Range) |> List.reduce unionRanges\n          Errors.Parser.missingParenthesizedExpr rng |> Context.error ctx\n          node rng Expr.Empty\n    Some(body |> whiteBefore (List.rev wb) |> whiteAfter (List.rev wa))\n\n  // Wait for ')', ignoring other nested tokens & ending on end of nesting\n  match Context.tokenIndent ctx with\n  | Some(white, ({ Token = TokenKind.RParen } as t)) -> \n      Context.next ctx\n      makeBody (t::(List.append (List.rev white) wa))\n  | Some(white, t) -> \n      Context.next ctx\n      Errors.Parser.unexpectedTokenInParenthesizedExpr t.Range t.Token |> Context.error ctx\n      Context.silent ctx (fun ctx ->\n        parseParenTermEnd wb (t::(List.append (List.rev white) wa)) bodyOpt ctx)\n  | None ->\n      let rng = match bodyOpt with Some b -> b.Range | _ -> (List.head wb).Range\n      Errors.Parser.unexpectedScopeEndInParenthesizedExpr rng |> Context.error ctx\n      makeBody wa\n            \n\n/// Parse expression consisting of multiple terms & operators\nand parseExpression terms ctx = \n  match terms, parseTerm ctx with\n  | terms, Some term -> \n      match Context.tokenIndent ctx with\n      // Followed by operator and more expressions\n      | Some(white, ({ Token = TokenKind.Equals } as t)) ->\n          Context.next ctx\n          parseExpression ((term, whiteBefore white (node t.Range Operator.Equals))::terms) ctx\n      | Some(white, ({ Token = TokenKind.Operator op } as t)) ->\n          Context.next ctx\n          parseExpression ((term, whiteBefore white (node t.Range op))::terms) ctx\n      | Some(white, _) -> buildExpression terms term |> whiteAfter white |> Some  \n      | None -> buildExpression terms term |> Some\n          \n  // Not an expression, return None\n  | [], None -> None  \n\n  // Nothing after operator - ignore operator, but parse preceding terms\n  | (term, op)::terms, None -> \n      Errors.Parser.unexpectedEndAfterOperator op.Range (TokenKind.Operator op.Node) |> Context.error ctx\n      Some(buildExpression terms term)\n\n\n// ------------------------------------------------------------------------------------------------\n// The parser - commands\n// ------------------------------------------------------------------------------------------------\n\n/// Parse expression, skipping all tokens that cannot be parsed\nlet rec parseLetBindingBody lastRng ctx = \n  match parseExpression [] ctx with\n  | Some body -> body\n  | None ->\n      match Context.tokenIndent ctx with\n      | None ->     \n          Errors.Parser.unexpectedScopeEndInLet lastRng |> Context.error ctx\n          node lastRng Expr.Empty\n      | Some(white, t) ->\n          Errors.Parser.unexpectedTokenInLetBinding t.Range t.Token |> Context.error ctx\n          Context.silent ctx (fun ctx -> parseLetBindingBody t.Range ctx)\n\n\n/// Skip all remaining nested tokens after a command\nlet rec skipNestedTokens firstTok white ctx = \n  match Context.tokenIndent ctx with \n  | None -> firstTok, white\n  | Some(whiteBefore, t & { Token = TokenKind.EndOfFile }) ->\n      (if firstTok = None then Some t else firstTok), white @ whiteBefore\n  | Some(whiteBefore, t) ->\n      Context.next ctx\n      let firstTok = if firstTok = None then Some t else firstTok\n      skipNestedTokens firstTok (white @ whiteBefore @ [t]) ctx\n      \n\n/// Parse the rest of the let binding after `let`, handling all sorts of errors\n/// This returns parsed command together with all nested expressions after the command\n/// (those should not be nested, but we accept them anyway & report error)\nlet parseLetBinding whiteBeforeLet rngLet ctx = \n  match Context.tokenIndent ctx with\n  | Some(Identifier id) ->\n      Context.next ctx\n      match Context.tokenIndent ctx with\n      | Some (whiteAfterId, { Token = TokenKind.Equals; Range = rngEq }) ->\n          Context.next ctx\n          let body = parseLetBindingBody rngEq ctx                \n          Command.Let(whiteAfter whiteAfterId id, body)\n          |> node (unionRanges rngLet body.Range) \n          |> whiteBefore whiteBeforeLet\n\n      | Some(whiteAfterId, t) -> \n          // RECOVERY: Unexpected token after ident - try to parse the body anyway\n          Errors.Parser.unexpectedTokenInLetBinding t.Range t.Token |> Context.error ctx\n          let body = parseLetBindingBody t.Range ctx\n          Command.Let(whiteAfter whiteAfterId id, body)\n          |> node (unionRanges rngLet id.Range) \n          |> whiteBefore whiteBeforeLet\n\n      | None ->\n          // RECOVERY: End of block after ident - return binding with empty expression\n          Errors.Parser.missingBodyInLetBinding id.Range |> Context.error ctx\n          let body = node { Start = id.Range.End; End = id.Range.End } Expr.Empty\n          Command.Let(id, body)\n          |> node (unionRanges rngLet id.Range) \n          |> whiteBefore whiteBeforeLet\n          \n  | Some(whiteAfterLet, t) ->\n      // RECOVERY: Unexpected token after let - try to parse body as expression & assume emtpy identifier\n      Errors.Parser.unexpectedTokenInLetBinding t.Range t.Token |> Context.error ctx\n      let letEndRng = { Start = rngLet.End; End = rngLet.End }\n      let body = \n        match parseExpression [] ctx with \n        | Some e -> e\n        | None -> \n            let firstSkipped, white = skipNestedTokens None [] ctx\n            let skipRng = t::white |> List.map (fun t -> t.Range) |> List.reduce unionRanges\n            node skipRng Expr.Empty |> whiteAfter (t::white)\n      Command.Let(whiteBefore whiteAfterLet (node letEndRng { Name = \"\" } ), body)\n      |> node (unionRanges rngLet body.Range) \n      |> whiteBefore whiteBeforeLet\n      \n  | None ->\n      // RECOVERY: Missing body - return let binding with empty expression and empty identifier\n      Errors.Parser.missingBodyInLetBinding rngLet |> Context.error ctx\n      let rng = { Start = rngLet.End; End = rngLet.End }\n      Command.Let(node rng { Name = \"\" }, node rng Expr.Empty)\n      |> node rng |> whiteBefore whiteBeforeLet\n\n\n/// A command is either top-level expression or let binding\nlet rec parseCommands acc ctx = \n  match Context.tokenNonIndent ctx with\n  | Some(white, { Token = TokenKind.EndOfFile }) ->\n      // Return commands & store the whitespace\n      match acc with \n      | x::xs -> List.rev ({ x with WhiteAfter = white }::xs)\n      | [] -> []\n    \n  | Some(whiteBeforeLet, tok & { Token = TokenKind.Let; Range = rngLet }) ->\n      Context.next ctx\n      let cmd = parseLetBinding whiteBeforeLet rngLet ctx \n      parseCommands (cmd::acc) ctx\n\n  | Some(white, t) -> \n      // Treat command as top-level expression\n      match parseExpression [] ctx with\n      | Some expr -> \n          let cmd = node expr.Range (Command.Expr(expr)) |> whiteBefore white\n          parseCommands (cmd::acc) ctx\n      | None -> \n          // RECOVERY: Not an expression, just skip over the whole thing\n          let _, white = skipNestedTokens None [] ctx\n          Errors.Parser.unexpectedNestedTokenInCommand t.Range t.Token |> Context.error ctx\n          let skipRng = t::white |> List.map (fun t -> t.Range) |> List.reduce unionRanges\n          let cmd = node skipRng (Command.Expr(node skipRng Expr.Empty)) |> whiteAfter (t::white)\n          parseCommands (cmd::acc) ctx\n\n  | None ->\n      // RECOVERY: Skip over all subsequent nested tokens\n      let firstSkipped, white = skipNestedTokens None [] ctx\n      let firstSkipped = firstSkipped.Value\n      Errors.Parser.unexpectedNestedTokenInCommand firstSkipped.Range firstSkipped.Token |> Context.error ctx\n      let skipRng = firstSkipped::white |> List.map (fun t -> t.Range) |> List.reduce unionRanges\n      let cmd = node skipRng (Command.Expr(node skipRng Expr.Empty)) |> whiteAfter white\n      parseCommands (cmd::acc) ctx\n\n\n// ------------------------------------------------------------------------------------------------\n// User friendly entry point\n// ------------------------------------------------------------------------------------------------\n\nlet parseProgram (input:string) = \n  try\n    let tokens, errors = Tokenizer.tokenize input\n    let ctx = \n      { Tokens = tokens; Position = 0; SilentMode = false\n        Errors = ResizeArray<_>(); Whitespace = ResizeArray<_>() }\n    let cmds = parseCommands [] ctx\n    let errors = Array.append errors (ctx.Errors.ToArray())\n    let rng = cmds |> List.fold (fun rng cmd -> unionRanges rng cmd.Range) { Start = 0; End = 0 }\n    { Body = node rng cmds }, errors\n  with e ->\n    Log.exn(\"parsing\", \"Exception while parsing program: %O\", e)\n    let rng = { Start=0; End=0 }\n    let error = Errors.Parser.exceptionWhileParsing rng (e.ToString())\n    { Body = node rng [] }, [| error |]\n","﻿// ------------------------------------------------------------------------------------------------\n// Type checker sets the Type properties of the Entities created by the Binder\n// ------------------------------------------------------------------------------------------------\nmodule TheGamma.TypeChecker\n\nopen TheGamma\nopen TheGamma.Ast\nopen TheGamma.Types\nopen TheGamma.Common\nopen System.Collections.Generic\n\n// ------------------------------------------------------------------------------------------------\n// Type checking \n// ------------------------------------------------------------------------------------------------\n\ntype CheckingContext = \n  { Errors : ResizeArray<Error<Range>> \n    Globals : IDictionary<string, Entity> \n    Ranges : IDictionary<Symbol, Range>\n    Evaluate : Entity -> EntityValue option }\n\nlet addError ctx ent err = \n  ctx.Errors.Add(err ctx.Ranges.[ent.Symbol])\n\n/// Given a list of types, find the most frequent type (using Type.Any as the last resort)\nlet inferListType typs = \n  typs \n  |> List.filter (function Type.Any -> false | _ -> true)\n  |> List.groupWith typesEqual\n  |> List.map (fun g -> List.head g, List.length g)\n  |> List.append [Type.Any, 0]\n  |> List.maxBy snd\n  |> fst\n\n/// Resolve type of parameter - parSpec can be Choice1Of2 with \n/// parameter name or Choice2Of2 with parameter index.\nlet resolveParameterType instTy parSpec = \n  match instTy with\n  | Type.Method(args, _) -> \n      let par = \n        match parSpec with\n        | Choice1Of2 name -> args |> Seq.tryFind (fun ma -> ma.Name = name)\n        | Choice2Of2 idx -> args |> Seq.tryItem idx  \n      match par with\n      | Some ma -> ma.Type\n      | _ -> failwith \"resolveParameterType: Parameter specification was incorrect\"\n  | _ -> failwith \"resolveParameterType: Instance is not an object\"\n\n/// Check method call - methodName is for logging only; parameterTypes and resultTypeFunc\n/// are the type information from `Type.Method` of the parent; `argList` and `args` are the\n/// actual type-checked arguments (argList is for storing errors only)\nlet rec checkMethodCallAsync (methodName:string) ctx (parameterTypes:MethodArgument list) \n    (resultTypeFunc:((Type * RuntimeValue option) list -> Type option)) argList args = async {\n\n  // Split arguments into position & name based and report \n  // error if there is non-named argument after named argument\n  let positionBased, nameBased = \n    let pb = args |> List.takeWhile (function { Kind = EntityKind.NamedParam _ } -> false | _ -> true)  \n    let nb = args |> List.skipWhile (function { Kind = EntityKind.NamedParam _ } -> false | _ -> true)  \n    pb |> Array.ofList,\n    nb |> List.choose (fun arg -> \n      match arg.Kind with\n      | EntityKind.NamedParam(name, value) -> Some(name.Name, value)\n      | _ ->\n          Errors.TypeChecker.nameBasedParamMustBeLast |> addError ctx arg\n          None ) |> Map.ofList\n\n  // Match actual arguments with the parameters and report\n  // error if non-optional parameter is missing an assignment\n  let matchedArguments = \n    parameterTypes |> List.mapi (fun index ma ->\n      let arg = \n        if index < positionBased.Length then Some(positionBased.[index]) \n        else Map.tryFind ma.Name nameBased \n      match arg with\n      | Some arg -> getType ctx arg, if ma.Static then Some arg else None\n      | None when ma.Optional -> ma.Type, None\n      | None ->\n          Errors.TypeChecker.parameterMissingValue ma.Name |> addError ctx argList\n          Type.Any, None)\n\n  // Evalaute arguments of static parameters\n  Log.trace(\"typechecker\", \"Evaluating arguments of type-level method '%s'\", methodName)\n  for e in matchedArguments |> Seq.choose snd do e.Value <- ctx.Evaluate e\n  Log.trace(\"typechecker\", \"Evaluated arguments of '%s': %O\", methodName, [| for e in Seq.choose snd matchedArguments -> e.Value |])\n  \n  let tcargs = matchedArguments |> List.map (function (t, Some e) -> t, Some(e.Value.Value.Value) | (t, _) -> t, None)\n  match resultTypeFunc tcargs with\n  | Some typ -> return typ\n  | None ->   \n      Log.trace(\"typechecker\", \"Invalid argument type when calling '%s'. Argument types: %O\", \n        methodName, (Array.ofList (List.map (fst >> Ast.formatType) matchedArguments)))\n      Errors.TypeChecker.parameterConflict |> addError ctx argList\n      return Type.Any }\n  \n\n/// Get type of an entity and record errors generated when type checking this entity\nand getType ctx (e:Entity) = \n  if e.Type.IsNone then \n    let errorCount = ctx.Errors.Count\n    e.Type <- Some (typeCheckEntity ctx e)\n    e.Errors <- [ for i in errorCount .. ctx.Errors.Count - 1 -> ctx.Errors.[i] ]\n  e.Type.Value\n\n/// Type check entity - assumes that all antecedents of the entity \n/// have been reduced to non-delayed type before\nand typeCheckEntity ctx (e:Entity) = \n  match e.Kind with\n\n  // Type check global value reference (from globals) and variable reference (from antecedent)\n  | EntityKind.GlobalValue(name, _) ->\n      if not (ctx.Globals.ContainsKey(name.Name)) then\n        Errors.TypeChecker.variableNotInScope name.Name |> addError ctx e\n        Type.Any\n      else\n        getType ctx ctx.Globals.[name.Name]\n\n  | EntityKind.Variable(_, inst) ->\n      getType ctx inst      \n\n  // Member access gets type of a given member, call assumes the called thing was a method\n  | EntityKind.Member(inst, nameEnt & { Kind = EntityKind.MemberName name }) ->\n      match getType ctx inst with \n      | Type.Any -> Type.Any\n      | Type.Object(FindMember name mem) -> \n          e.Meta <- mem.Metadata\n          mem.Type\n      | Type.Object obj ->\n          Errors.TypeChecker.memberMissing name.Name obj.Members |> addError ctx nameEnt\n          Type.Any\n      | typ ->\n          Errors.TypeChecker.notAnObject name.Name typ |> addError ctx inst\n          Type.Any\n\n  | EntityKind.MemberAccess(mem) ->\n      getType ctx mem     \n\n  | EntityKind.Member(inst, _) ->\n      Log.error(\"typechecker\", \"typeCheckEntity: Member access is missing member name!\")\n      failwith \"typeCheckEntity: Member access is missing member name!\"\n\n  | EntityKind.Call(inst, { Kind = EntityKind.ArgumentList(ents) }) ->\n      Log.error(\"typechecker\", \"typeCheckEntity: Call to %s has not been type-checked in typeCheckEntityAsync!\", (lastChainElement inst).Name)\n      failwithf \"typeCheckEntity: Call to %s has not been type-checked in typeCheckEntityAsync!\" (lastChainElement inst).Name\n\n  | EntityKind.Call(inst, _) ->\n      Log.error(\"typechecker\", \"typeCheckEntity: Call to %s is missing argument list!\", (lastChainElement inst).Name)\n      failwithf \"typeCheckEntity: Call to %s is missing argument list!\" (lastChainElement inst).Name\n\n  // Type of placeholder is the type of its body\n  | EntityKind.Placeholder(_, body) ->      \n      getType ctx body\n\n  // Operators and lists depend on the types of operands and elements...\n  | EntityKind.Operator(l, operator, r) ->      \n      let operandTypes = \n        ( match operator with\n          | Operator.Equals -> [PrimitiveType.Number; PrimitiveType.String; PrimitiveType.Date; PrimitiveType.Bool]\n          | Operator.Plus -> [PrimitiveType.Number; PrimitiveType.String]\n          | _ -> [PrimitiveType.Number] ) |> List.map Type.Primitive \n\n      [l; r] |> List.iteri (fun idx operand ->\n        let typ = getType ctx operand\n        if operandTypes |> List.forall (fun opt -> not (typesEqual typ opt)) then\n          Errors.TypeChecker.numericOperatorExpectsNumbers operator idx operandTypes typ |> addError ctx operand )\n      match operator with\n      | Operator.Equals | Operator.LessThan | Operator.GreaterThan \n      | Operator.LessThanOrEqual | Operator.GreaterThanOrEqual -> Type.Primitive PrimitiveType.Bool      \n      | _ -> getType ctx l\n\n  | EntityKind.List(elems) ->      \n      let typs = elems |> List.map (getType ctx)\n      let typ = inferListType typs \n      for a in elems do \n        let elty = getType ctx a\n        if not (typesEqual typ elty) then\n          Errors.TypeChecker.listElementTypeDoesNotMatch typ elty |> addError ctx a\n      Type.List(typ)\n\n  | EntityKind.Binding(name, { Kind = EntityKind.CallSite(inst, parSpec) }) ->\n      // Binding node is used to resolve type of a lambda function variable. \n      // Its antecedent is `EntityKind.CallSite` containing reference to the method around it - \n      // assuming lambda appears in something like: `foo(10, fun x -> ...)`\n      match resolveParameterType (getType ctx inst) parSpec with\n      | Type.Method([ma], _) -> ma.Type\n      | _ -> failwith \"typeCheckEntity: Expected parameter of function type\"\n\n  | EntityKind.Binding(name, _) ->\n      failwithf \"typeCheckEntity: Variable binding %s is missing call site!\" name.Name\n\n  | EntityKind.Function(var, body) ->\n      let resTyp = getType ctx body\n      Type.Method([ { MethodArgument.Name = \"\"; Optional = false; Static = false; Type = getType ctx var }], fun _ -> Some resTyp)\n\n  // Entities with primitive types\n  | EntityKind.Constant(Constant.Number _) -> Type.Primitive(PrimitiveType.Number)\n  | EntityKind.Constant(Constant.String _) -> Type.Primitive(PrimitiveType.String)\n  | EntityKind.Constant(Constant.Boolean _) -> Type.Primitive(PrimitiveType.Bool)\n  | EntityKind.Constant(Constant.Empty) -> Type.Any\n\n  // Entities that do not have a real type\n  | EntityKind.Root -> Type.Any\n  | EntityKind.LetCommand _ -> Type.Any\n  | EntityKind.RunCommand _ -> Type.Any\n  | EntityKind.ArgumentList _ -> Type.Any\n  | EntityKind.NamedParam _ -> Type.Any\n  | EntityKind.CallSite _ -> Type.Any\n  | EntityKind.Program _ -> Type.Any\n  | EntityKind.MemberName _ -> Type.Any\n\n\n/// Perform type applications & evaluate delayed types\nlet rec evaluateDelayedType topLevel (t:Type) = async {\n  match t with\n  | Type.Delayed(f) ->\n      let! t = Async.AwaitFuture f\n      return! evaluateDelayedType topLevel t\n  | t -> return t }\n\n\n/// Type check entity & return its type. This first recursively processes\n/// all antecedants to make sure that no antecedant is delayed  \n/// (this way, `getType` can be ordinary synchronouus function)\nlet typeCheckEntityAsync ctx (e:Entity) = async {\n  let visited = Dictionary<Symbol, bool>()\n\n  let rec loop e = async {\n    let isGlobal = match e.Kind with EntityKind.GlobalValue _ -> true | _ -> false\n    if not (visited.ContainsKey(e.Symbol)) && (isGlobal || e.Type.IsNone) then\n      visited.[e.Symbol] <- true\n      for a in e.Antecedents do\n        do! loop a  \n\n      match e.Kind with\n      | EntityKind.Call(inst, { Kind = EntityKind.ArgumentList(ents) } & arglist) ->\n          let errorCount = ctx.Errors.Count\n          let! typ = \n            match getType ctx inst with \n            | Type.Any -> async.Return Type.Any\n            | Type.Method(parameterTypes, resultTypeFunc) ->  \n                checkMethodCallAsync inst.Name ctx parameterTypes resultTypeFunc arglist ents\n            | typ ->\n                let lastName = lastChainElement inst\n                Errors.TypeChecker.notAnMethod lastName.Name typ |> addError ctx inst\n                async.Return Type.Any\n          e.Type <- Some typ\n          e.Errors <- [ for i in errorCount .. ctx.Errors.Count - 1 -> ctx.Errors.[i] ]\n      | _ -> ()\n\n      let! t = evaluateDelayedType true (getType ctx e)\n      Log.trace(\"typechecker\", \"Type of entity '%s' (%s) is: %s\", e.Name, formatEntityKind e.Kind, formatType t)\n      e.Type <- Some t }\n\n  do! loop e\n  return getType ctx e }\n\n\n// ------------------------------------------------------------------------------------------------\n// User friendly entry point\n// ------------------------------------------------------------------------------------------------\n\nlet collectTypeErrors (entity:Entity) = \n  let errors = ResizeArray<_>()\n  let visited = Dictionary<Symbol, bool>()\n  let rec loop e = \n    if not (visited.ContainsKey e.Symbol) then\n      visited.[e.Symbol] <- true\n      for e in e.Antecedents do loop e\n      errors.AddRange(e.Errors)\n  loop entity\n  errors.ToArray()\n\nlet typeCheckProgram (globals:Entity list) (bound:Binder.BindingResult) evaluate prog = async {\n  Log.trace(\"typechecker\", \"Type checking program\")\n  try\n    let rangeLookup = dict [ for r, e in bound.Entities -> e.Symbol, r ]\n    let vars = dict [ for e in globals -> e.Name, e ]\n    let ctx = { Globals = vars; Errors = ResizeArray<_>(); Ranges = rangeLookup; Evaluate = evaluate }\n    let! _ = typeCheckEntityAsync ctx prog \n    Log.trace(\"typechecker\", \"Completed type checking\")\n  with e ->\n    Log.exn(\"typechecker\", \"Type checking program failed: %O\", e) }","﻿// ------------------------------------------------------------------------------------------------\n// Shared components for creating live previews\n// ------------------------------------------------------------------------------------------------\nmodule TheGamma.Live.Common\n\nopen TheGamma\nopen Fable.Import\n\ntype CustomLiveState = interface end\ntype CustomLiveEvent = interface end\ntype LiveEditorZone = { Line:int; Preview:Html.DomNode }\n\ntype LivePreview<'TState, 'TEvent> =\n  { ID : string\n    Update : (LiveEvent<'TEvent> -> unit) -> LiveState<'TState> -> LiveEvent<'TEvent> -> LiveState<'TState> option\n    Render : (LiveEvent<'TEvent> -> unit) -> LiveState<'TState> -> LiveEditorZone option\n    InitialState : 'TState }\n\nand LiveState<'T> =\n  { // Initialized once - global values\n    Globals : seq<Entity>\n    // Updated when code changes - parsed program\n    Code : string\n    Program : Program\n    Mapper : LocationMapper\n    // Updated when cursor moves \n    Location : int\n    // Instructing the event loop to do things to the editor  \n    Selection : option<LineColumnRange>\n    \n    State : 'T\n    CurrentPreview : option<LivePreview<CustomLiveState, CustomLiveEvent>> }\n\nand LiveEvent<'T> =\n  | InitializeGlobals of seq<Entity>\n  | UpdateSource of string * int * Program * LocationMapper\n  | UpdateLocation of int\n  | CustomEvent of 'T\n\nlet updateLiveState state event = \n  match event with\n  | InitializeGlobals(globals) ->\n      { state with Globals = globals }\n  | UpdateLocation(loc) ->\n      { state with Location = loc }\n  | UpdateSource(code, loc, program, mapper) ->\n      { state with Location = loc; Program = program; Code = code; Mapper = mapper }\n  | CustomEvent _ -> state\n\n// ------------------------------------------------------------------------------------------------\n// Generally usefl functions for previews\n// ------------------------------------------------------------------------------------------------\n\nopen TheGamma.Ast\n\n/// Represents a chain such as `foo.bar(1).goo`, potentially \n/// inside a command (that may contain things like `let` etc.)\ntype NestedChain = \n  { // List containing Expr.Member, Expr.Call and Expr.Variable nodes \n    // from a call chain with their starting offset\n    Chain : (int * Node<Expr>) list }\n\nlet rec collectChain acc node =\n  match node.Node with\n  | Expr.Call(e, a) -> collectChain ((a.Range.Start, node)::acc) e\n  | Expr.Member(e, n) -> collectChain ((n.Range.Start, node)::acc) e\n  | Expr.Variable(n) -> Some((n.Range.Start, node)::acc)\n  | _ -> None\n\nlet rec collectFirstChain expr = \n  match collectChain [] expr with\n  | Some((_::_) as chain) -> Some { Chain = chain }\n  | _ ->\n  match expr with\n  | { Node = ExprNode(es, ns) } -> es |> Seq.tryPick collectFirstChain\n  | _ -> None\n","﻿module TheGamma.Services\n\nopen Fable.Import\nopen TheGamma.Html\nopen TheGamma.Common\nopen TheGamma.Ast\n\nmodule FsOption = Microsoft.FSharp.Core.Option\n\n// ------------------------------------------------------------------------------------------------\n// Type checker\n// ------------------------------------------------------------------------------------------------\n\ntype CheckingMessage = \n  | TypeCheck of code:string * AsyncReplyChannel<bool * Binder.BindingResult * Program>\n  | IsWellTyped of code:string * AsyncReplyChannel<bool>\n\ntype Position = { Line:int; Column:int }\ntype LineRange = { Start:Position; End:Position }\n\nlet rec offsetToLocation lines offs lengths =\n  match lengths with\n  | l::lengths when offs <= l -> { Line = lines; Column = offs }\n  | l::lengths -> offsetToLocation (lines+1) (offs-l-1) lengths\n  | [] -> { Line = lines; Column = offs  } // error? out of range\n\nlet rangeToLoc lengths (rng:Range) = \n  { Start = offsetToLocation 1 rng.Start lengths\n    End = offsetToLocation 1 rng.Start lengths }\n\ntype CheckingService(article, globals:Future<Entity list>) =\n  let errorsReported = Control.Event<_>()\n  let emptyProg = { Body = Ast.node { Start = 0; End = 0 } [] }\n  let bindingContext =  \n    async { \n      let! globals = globals |> Async.AwaitFuture\n      return Binder.createContext globals article } |> Async.StartAsFuture\n\n  let errorsToLineCol (code:string) errors = \n    let lengths = code.Split('\\n') |> Array.toList |> List.map (fun l -> l.Length)\n    errors |> Array.map (fun e -> \n      { Number = e.Number; Message = e.Message; Range = rangeToLoc lengths e.Range })\n\n  let typeCheck code = async {\n    let! globals = Async.AwaitFuture globals\n    Log.trace(\"service\", \"Evaluated globals\")\n    for g in globals do Log.trace(\"service\", \"Global value '%s' : %O = %O\", g.Name, Option.map formatType g.Type, g.Value)\n    try\n      let progSyntax, parseErrors = Parser.parseProgram code\n      let! bindingContext = bindingContext |> Async.AwaitFuture\n      let progEntity, boundEntities = Binder.bindProgram bindingContext progSyntax\n      do! TypeChecker.typeCheckProgram globals boundEntities (Interpreter.evaluate globals) progEntity\n      let typeErrors = TypeChecker.collectTypeErrors progEntity\n      Log.trace(\"service\", \"Type checking completed\")\n      let errors = errorsToLineCol code (Array.append parseErrors typeErrors)\n      return Some(progSyntax, boundEntities, errors)\n    with e ->\n      Log.exn(\"service\", \"Type checking failed: %O\", e)\n      return None }\n\n  let agent = MailboxProcessor.Start(fun inbox ->\n    let rec loop lastCode lastResult = async {\n      let! msg = inbox.Receive()\n      match msg with\n      | IsWellTyped(code, repl) ->\n          let! tc = typeCheck code\n          match tc with \n          | Some(_, _, errs) when errs.Length = 0 -> repl.Reply(true)\n          | _ -> repl.Reply(false)\n          return! loop lastCode lastResult\n\n      | TypeCheck(code, repl) when code = lastCode ->\n          Log.trace(\"service\", \"Returning previous result\")\n          repl.Reply(lastResult)\n          return! loop lastCode lastResult\n\n      | TypeCheck(code, repl) ->\n          Log.trace(\"service\", \"Type checking source code\")\n          let! tc = typeCheck code\n          match tc with \n          | Some(prog, ents, errors) ->\n              errorsReported.Trigger(code, errors)            \n              let result = (errors.Length = 0, ents, prog)\n              repl.Reply(result)\n              return! loop code result\n          | None -> \n              repl.Reply((false, Binder.BindingResult [||], emptyProg))\n              return! loop lastCode lastResult }\n    \n    loop \"\" (false, Binder.BindingResult [||], emptyProg))\n\n  member x.ErrorsReported = errorsReported.Publish\n  member x.TypeCheck(code) = agent.PostAndAsyncReply(fun ch -> TypeCheck(code, ch))\n  member x.IsWellTyped(code) = agent.PostAndAsyncReply(fun ch -> IsWellTyped(code, ch))\n\n\n// ------------------------------------------------------------------------------------------------\n// Live previews\n// ------------------------------------------------------------------------------------------------\n\nopen Fable.Core\nopen Fable.Helpers\nopen Fable.Import.Browser\nopen TheGamma.Live.Common\n\ntype PreviewService(checker:CheckingService, globals:Future<list<Entity>>, ed:monaco.editor.ICodeEditor, livePreviews) =\n\n  let zoneSizeChanged = new Event<unit>()\n  let mutable currentZone : option<float * monaco.editor.IViewZone> = None\n  let mutable zoneHeight = 0.0\n  let mutable tree = JsInterop.createObj []\n  let mutable container = document.createElement(\"div\") :> Node\n\n  let removeZone () =\n    match currentZone with \n    | Some(id, _) -> ed.changeViewZones(fun accessor -> accessor.removeZone(id))\n    | None -> ()\n    currentZone <- None\n    zoneSizeChanged.Trigger()\n  \n  let createAndAddZone endLine =\n    let mutable zoneId = -1.\n    let zone = JsInterop.createEmpty<monaco.editor.IViewZone>\n    \n    let node = document.createElement_div()\n    node.style.width <- \"1000px\"\n    node.style.height <- \"1000px\"\n    container <- document.createElement_div() :> Node    \n    tree <- JsInterop.createObj []    \n    node.appendChild(container) |> ignore\n    ed.changeViewZones(fun accessor ->  \n      match currentZone with Some(id, _) -> accessor.removeZone(id) | _ -> ()\n      zone.afterLineNumber <- endLine\n      zone.heightInPx <- Some 1.0\n      zone.domNode <- node\n      zoneHeight <- 1.0\n      zoneId <- accessor.addZone(zone) \n      currentZone <- Some (zoneId, zone) )\n\n  let updateZones trigger liveState =\n    let dom = \n      liveState.CurrentPreview |> FsOption.bind (fun p ->\n        p.Render trigger liveState )\n    match dom with \n    | None -> removeZone ()\n    | Some prev ->\n        if currentZone.IsNone then createAndAddZone (float prev.Line)\n        let id, zone = currentZone.Value\n        let newTree = prev.Preview |> renderVirtual \n        let patches = Virtualdom.diff tree newTree\n        container <- Virtualdom.patch container patches\n        tree <- newTree\n\n        let rec waitForActualHeight n = async {\n          let newHeight = (container :?> HTMLElement).clientHeight\n          if n = 10 || newHeight <> 0.0 then return newHeight\n          else \n            do! Async.Sleep (n*n)\n            return! waitForActualHeight (n+1) }\n\n        async {\n          let! newHeight = waitForActualHeight 1\n          Log.trace(\"live\", \"Old height: %s, New height: %s\", zoneHeight, newHeight)\n          if zoneHeight <> newHeight || zone.afterLineNumber <> float prev.Line then\n            zone.afterLineNumber <-   float prev.Line\n            zone.heightInPx <- Some newHeight\n            zoneHeight <- newHeight\n            ed.changeViewZones(fun accessor -> accessor.layoutZone(id))\n            zoneSizeChanged.Trigger() } |> Async.StartImmediate\n\n  let mutable lastCode = \"\"\n  let mutable lastMapper = LocationMapper(\"\")\n  let mutable changingEditor = false\n\n  let getUpdateEventAfterChange () = async {\n    let code = ed.getModel().getValue(monaco.editor.EndOfLinePreference.LF, false)\n    let position = ed.getPosition()\n    if code <> lastCode then\n      lastCode <- code\n      lastMapper <- LocationMapper(code)\n      let loc = lastMapper.LineColToAbsolute(int position.lineNumber, int position.column)\n      let! _, _, program = checker.TypeCheck(code)\n      return (UpdateSource(code, loc, program, lastMapper)) \n    else \n      let loc = lastMapper.LineColToAbsolute(int position.lineNumber, int position.column)\n      return (UpdateLocation(loc)) }\n\n  let createLivePreview (ed:monaco.editor.ICodeEditor) = \n    let liveEvent = new Event<LiveEvent<CustomLiveEvent>>()\n    let noState = { new CustomLiveState }\n    let mutable liveState = \n      { Mapper = LocationMapper(\"\")\n        Location = 0\n        Program = { Body = Ast.node { Start = 0; End = 0 } [] }\n        Globals = []\n        Code = \"\"\n        Selection = None\n        State = noState\n        CurrentPreview = None }\n\n    let applyEvent evt =\n      let liveState = updateLiveState liveState evt        \n      let newState =\n        match liveState.CurrentPreview with \n        | Some(prev) -> prev.Update liveEvent.Trigger liveState evt\n        | None -> None\n\n      let newPreview = \n        match evt with\n        | UpdateSource _ | UpdateLocation _ ->\n            Log.trace(\"live\", \"Searching for available previews\")\n            let state = livePreviews |> Seq.tryPick (fun lp ->\n              let state = { liveState with CurrentPreview = Some lp; State = lp.InitialState }\n              lp.Update liveEvent.Trigger state evt)\n            state\n        | _ -> None\n      \n      match newState, newPreview with\n      | Some (st & { CurrentPreview = Some p1 }), Some (pr & { CurrentPreview = Some p2 }) \n          when p1.ID <> p2.ID -> pr\n      | Some st, _ -> st\n      | _, Some pr -> pr\n      | _ -> { liveState with CurrentPreview = None; State = noState }\n\n    liveEvent.Publish.Add(fun evt ->\n      try\n        Log.trace(\"live\", \"Updating state %O with event %O\", liveState, evt)\n        let oldState = liveState \n        liveState <- applyEvent evt\n\n        if (match evt with UpdateSource _ -> false | _ -> true) && (oldState.Code <> liveState.Code) then\n          changingEditor <- true\n          ed.getModel().setValue(liveState.Code)\n        match liveState.Selection with\n        | Some rng ->\n            changingEditor <- true\n            let mrng = JsInterop.createEmpty<monaco.IRange>\n            mrng.startColumn <- float rng.StartColumn\n            mrng.startLineNumber <- float rng.StartLineNumber\n            mrng.endColumn <- float rng.EndColumn\n            mrng.endLineNumber <- float rng.EndLineNumber\n            ed.setSelection(mrng)\n            liveState <- { liveState with Selection = None }\n        | _ -> ()\n\n        if changingEditor = true then\n          changingEditor <- false\n          async { \n            Log.trace(\"live\", \"Editor changed. Getting after change event...\")\n            let! evt = getUpdateEventAfterChange ()\n            Log.trace(\"live\", \"Editor changed. Updating state %O with event %O\", liveState, evt)\n            liveState <- applyEvent evt\n            Log.trace(\"live\", \"Editor changed. New state %O\", liveState)\n            updateZones liveEvent.Trigger liveState } |> Async.StartImmediate\n        else\n          updateZones liveEvent.Trigger liveState\n      with e ->\n        Log.exn(\"live\", \"Error when updating state %O with event %O: %O\", liveState, evt, e) )\n\n    async { let! glob = globals |> Async.AwaitFuture \n            liveEvent.Trigger(InitializeGlobals glob) } |> Async.StartImmediate\n\n    liveEvent.Trigger\n\n  let trigger = createLivePreview ed    \n      \n  do\n    ed.onDidChangeCursorPosition(fun ce -> \n      if not changingEditor then\n        let code = ed.getModel().getValue(monaco.editor.EndOfLinePreference.LF, false)\n        Log.trace(\"live\", \"Cursor position changed: code <> lastCode = %s\", code <> lastCode)\n        async { let! evt = getUpdateEventAfterChange ()\n                trigger evt } |> Async.StartImmediate ) |> ignore\n\n  member x.ZoneSizeChanged = \n    zoneSizeChanged.Publish\n\n  member x.ZoneHeight = \n    if currentZone <> None then zoneHeight \n    else 0.0","﻿// ------------------------------------------------------------------------------------------------\n// Code generator is used to compile complete well-typed programs\n// ------------------------------------------------------------------------------------------------\nmodule TheGamma.CodeGenerator\n\nopen TheGamma\nopen TheGamma.Babel\nopen TheGamma.Babel.BabelOperators\nopen TheGamma.Common\n\n// ------------------------------------------------------------------------------------------------\n// Compiling code to Babel AST\n// ------------------------------------------------------------------------------------------------\n\ntype CompilationContext =\n  { LineLengths : int list\n    Globals : Map<string, Expression> }\n\nlet rec offsetToLocation lines offs lengths =\n  match lengths with\n  | l::lengths when offs <= l -> { line = lines; column = offs }\n  | l::lengths -> offsetToLocation (lines+1) (offs-l-1) lengths\n  | [] -> failwith \"offsetToLocation: Out of range\"\n\nlet rangeToLoc ctx rng = \n  { start = offsetToLocation 1 rng.Start ctx.LineLengths \n    ``end`` = offsetToLocation 1 rng.Start ctx.LineLengths } |> Some\n\nlet rec getMember name typ = \n  match typ with\n  | Type.Object(o) -> \n      match o.Members |> Seq.tryPick (fun m -> if m.Name = name then Some(m) else None) with\n      | Some res -> res\n      | _ ->\n        Log.exn(\"codegen\", \"getMember: Member %s not found in object %O\", name, o)\n        failwith \"getMember: Member not found\" \n  | t -> \n    Log.exn(\"codegen\", \"getMember: Not an object %O\", t)\n    failwith \"getMember: Not an object\" \n\nlet rec compileExpression ctx (expr:Node<Expr>) = \n  Log.trace(\"codegen\", \"Compiling expression: %O\", expr)\n  match expr.Node with \n  // Binary operators map to BinaryExpression, except for pow, which is a JS function\n  | Expr.Binary(l, { Node = Operator.Power }, r) ->\n      let l = compileExpression ctx l\n      let r = compileExpression ctx r\n      let rng = rangeToLoc ctx expr.Range\n      let pow = ident(\"Math\")?pow\n      CallExpression(pow, [l; r], rangeToLoc ctx expr.Range)\n\n  | Expr.Binary(l, op, r) ->\n      let l = compileExpression ctx l\n      let r = compileExpression ctx r\n      let op = \n        match op.Node with\n        | Operator.Modulo -> BinaryModulus\n        | Operator.Equals -> BinaryEqualStrict\n        | Operator.Plus -> BinaryPlus\n        | Operator.Minus -> BinaryMinus\n        | Operator.Multiply -> BinaryMultiply\n        | Operator.Divide -> BinaryDivide\n        | Operator.GreaterThan -> BinaryGreater\n        | Operator.LessThan -> BinaryLess\n        | Operator.GreaterThanOrEqual -> BinaryGreaterOrEqual\n        | Operator.LessThanOrEqual -> BinaryLessOrEqual\n        | Operator.Power -> failwith \"compileExpression: Power is not a binary operator\"\n      BinaryExpression(op, l, r, rangeToLoc ctx expr.Range)\n      \n  // Handle member access and calls - method call is a combination of the two\n  | Expr.Member(inst, { Node = Expr.Placeholder(_, { Node = Expr.Variable n }) })\n  | Expr.Member(inst, { Node = Expr.Variable n }) ->\n      let mem = getMember n.Node.Name inst.Entity.Value.Type.Value\n      let inst = compileExpression ctx inst\n      mem.Emitter.Emit(inst)\n\n  | Expr.Member(inst, _) ->\n      failwith \"compileExpression: Member in member access is not a variable\"\n\n  | Expr.Call(inst, args) ->\n      // Split arguments between position & name based\n      let compiledArgs = args.Node |> List.map (fun a -> a.Name, compileExpression ctx a.Value)\n      let positionArgs = compiledArgs |> Seq.takeWhile (fun (n, _) -> n.IsNone) |> Seq.map snd |> Array.ofSeq\n      let namedArgs = compiledArgs |> Seq.choose (function (Some n, a) -> Some(n.Node.Name, a) | _ -> None) |> dict\n\n      // Get expected arguments from the method type\n      let expectedArgs = \n        match inst.Entity.Value.Type.Value with\n        | Type.Method(args, resTy) -> args\n        | _ -> []\n\n      // Compile the instance, the arguments and call the emitter\n      let inst = compileExpression ctx inst\n      let pars = expectedArgs |> List.mapi (fun i ma ->\n        if i < positionArgs.Length then positionArgs.[i]\n        elif namedArgs.ContainsKey ma.Name then namedArgs.[ma.Name]\n        else NullLiteral(rangeToLoc ctx args.Range))\n      CallExpression(inst, pars, rangeToLoc ctx expr.Range)\n\n  // Variables and literals are easy       \n  | Expr.Variable(n) when ctx.Globals.ContainsKey(n.Node.Name) ->\n      ctx.Globals.[n.Node.Name]\n  | Expr.Variable(n) ->\n      IdentifierExpression(n.Node.Name, rangeToLoc ctx n.Range) \n\n  | Expr.Number(n) ->\n      NumericLiteral(n, rangeToLoc ctx expr.Range)\n  | Expr.String(s) ->\n      StringLiteral(s, rangeToLoc ctx expr.Range)\n  | Expr.Boolean(b) ->\n      BooleanLiteral(b, rangeToLoc ctx expr.Range)\n\n  // Other constructs that map fairly directly to JS \n  | Expr.Placeholder(_, body) ->\n      compileExpression ctx body\n\n  | Expr.List(es) ->\n      let es = List.map (compileExpression ctx) es\n      ArrayExpression(es, rangeToLoc ctx expr.Range)\n\n  | Expr.Function(n, e) ->\n      let var = IdentifierExpression(n.Node.Name, rangeToLoc ctx n.Range)\n      let ce = compileExpression { ctx with Globals = Map.add n.Node.Name var ctx.Globals } e\n      let body = BlockStatement([ReturnStatement(ce, rangeToLoc ctx e.Range)], rangeToLoc ctx e.Range)\n      FunctionExpression(None, [IdentifierPattern(n.Node.Name, rangeToLoc ctx n.Range)], body, false, false, rangeToLoc ctx expr.Range)\n\n  // Empty expressions should not happen...\n  | Expr.Empty ->      \n      Log.error(\"codegen\", \"getEmitterAndParams: Empty expression in the AST\")\n      NullLiteral(rangeToLoc ctx expr.Range)\n    \n\nlet compileCommand ctx idx (cmd:Node<Command>) = \n  let loc = rangeToLoc ctx cmd.Range\n  let statements, idx, assign = \n    match cmd.Node with\n    | Command.Let(n, e) ->\n        let e = compileExpression ctx e\n        let name = IdentifierPattern(n.Node.Name, rangeToLoc ctx n.Range)\n        let decl = VariableDeclarator(name, Some e, loc)\n        [ VariableDeclaration(Var, [decl], rangeToLoc ctx cmd.Range) ], \n        str(n.Node.Name), ident(n.Node.Name)\n\n    | Command.Expr(e) ->\n        [], num(float idx), compileExpression ctx e\n\n  let res = MemberExpression(ident(\"_results\"), idx, true, loc)\n  statements @ [ ExpressionStatement(AssignmentExpression(AssignEqual, res, assign, loc), loc) ] \n\nlet compileProgram ctx (prog:TheGamma.Program) = \n  let decl = VariableDeclarator(IdentifierPattern(\"_results\", None), Some (ArrayExpression([], None)), None)\n  let res = VariableDeclaration(Var, [decl], None)\n  let body = List.mapi (compileCommand ctx) prog.Body.Node |> List.concat\n\n  let ret = ReturnStatement(ident(\"_results\"), None)\n  let body = BlockStatement(res :: body @ [ ret ], None)\n  let body = CallExpression(FunctionExpression(None, [], body, false, false, None), [], None)\n  { location = rangeToLoc ctx prog.Body.Range; body = [ ExpressionStatement(body, None) ] }\n\n// ------------------------------------------------------------------------------------------------\n// Cmpile program and return JS source code\n// ------------------------------------------------------------------------------------------------\n\nopen Fable.Helpers.Babel\n\nlet compile globals (text:string) prog = async {\n  try\n    let! globals = Async.AwaitFuture globals\n    let globals = \n      globals |> List.choose (function\n        | { Kind = EntityKind.GlobalValue(n, Some e) } -> Some(n.Name, e)\n        | _ -> None ) |> Map.ofSeq    \n    let ctx = { LineLengths = [ for l in text.Split('\\n') -> l.Length ]; Globals = globals }  \n    let res = compileProgram ctx prog\n    let code = babel.transformFromAst(Serializer.serializeProgram res, text, { presets = [| \"es2015\" |] })\n    Log.trace(\"codegen\", \"Evaluating: %O\", code)\n    return code.code\n\n  with e ->\n    Log.exn(\"codegen\", \"Evaluating code failed: %O\", e)\n    return \"\" }\n","﻿// ------------------------------------------------------------------------------------------------\n// Live preview for pivot type provider\n// ------------------------------------------------------------------------------------------------\nmodule TheGamma.Live.Pivot\n\nopen Fable.Core\nopen Fable.Import\nopen Fable.Import.Browser\n\nopen TheGamma\nopen TheGamma.Ast\nopen TheGamma.Html\nopen TheGamma.Live.Common\nopen TheGamma.Common\nopen TheGamma.TypeChecker\nopen TheGamma.TypeProviders\n\nmodule FsOption = Microsoft.FSharp.Core.Option\n\n[<Emit(\"$0.setCustomValidity($1)\")>]\nlet setCustomValidity (el:obj) (msg:string) : unit = failwith \"JS\"\n\n// ------------------------------------------------------------------------------------------------\n// Pivot editor: Helpers for working with entities\n// ------------------------------------------------------------------------------------------------\n\nlet pickPivotFields expr =\n  match expr.Entity with\n  | Some { Kind = EntityKind.MemberAccess { Kind = EntityKind.Member _; Meta = m } }\n  | Some { Kind = EntityKind.GlobalValue _; Meta = m } \n  | Some { Kind = EntityKind.Variable(_, { Meta = m }) } -> \n      match pickMetaByType \"http://schema.thegamma.net/pivot\" \"Fields\" m with\n      | Some m -> Some(unbox<TypeProviders.Pivot.Field list> m)\n      | _ -> None\n  | _ -> None\n\nlet pickPivotTransformations expr =\n  let tryPivotType = \n    match expr with\n    | { Entity = Some { Type = Some (Type.Object (:? TypeProviders.Pivot.PivotObject)) } } -> \n        Some [TypeProviders.Pivot.Transformation.Empty]\n    | _ -> None     \n  let tryTransform =\n    match expr with\n    | { Node = Expr.Call({ Entity = Some { Kind = EntityKind.MemberAccess({ Kind = EntityKind.Member _; Meta = m }) } }, _) } \n    | { Entity = Some { Kind = EntityKind.MemberAccess { Kind = EntityKind.Member _; Meta = m } } } -> \n        match pickMetaByType \"http://schema.thegamma.net/pivot\" \"Transformations\" m with\n        | Some m -> Some(unbox<TypeProviders.Pivot.Transformation list> m)\n        | _ -> None\n    | _ -> None\n  match tryTransform, tryPivotType with Some r, _ | _, Some r -> Some r | _ -> None\n\nlet commandAtLocation loc (program:Program) =\n  program.Body.Node |> List.tryFind (fun cmd ->\n    cmd.Range.Start <= loc && cmd.Range.End + 1 >= loc)\n\n// ------------------------------------------------------------------------------------------------\n// Pivot editor: Splitting pivot transformations into sections\n// ------------------------------------------------------------------------------------------------\n\n/// Represents a tab of the pivot editor (with all nodes that represent the transform)\ntype PivotSection = \n  { Transformation : Pivot.Transformation\n    Nodes : Node<Expr> list }\n\nlet transformName = function\n  | Pivot.DropColumns _ -> \"drop columns\"\n  | Pivot.Empty _ -> \"empty\"\n  | Pivot.FilterBy _ -> \"filter by\"\n  | Pivot.GetSeries _ -> \"get series\"\n  | Pivot.GetTheData _ -> \"get the data\"\n  | Pivot.GroupBy _ -> \"group by\"\n  | Pivot.WindowBy _ -> \"window by\"\n  | Pivot.ExpandBy _ -> \"expand by\"\n  | Pivot.Paging _ -> \"paging\"\n  | Pivot.SortBy _ -> \"sort by\"\n  | Pivot.GetRange _ | Pivot.Metadata _ -> failwith \"Unexpected get range or metadata\"\n\nlet createPivotSections (ch:NestedChain) = \n  let rec loop acc (currentTfs, currentEnts, currentLength) = function\n    | (e, tfs)::tfss when \n          transformName (List.head tfs) = transformName currentTfs && \n          List.length tfs = currentLength ->\n        loop acc (currentTfs, e::currentEnts, currentLength) tfss\n    | (e, tfs)::tfss ->\n          let current = { Transformation = currentTfs; Nodes = List.rev currentEnts }\n          loop (current::acc) (List.head tfs, [e], List.length tfs) tfss\n    | [] -> \n          let current = { Transformation = currentTfs; Nodes = List.rev currentEnts }\n          List.rev (current::acc)\n    \n  let tfss = ch.Chain |> List.choose (fun (_, node) ->\n    match pickPivotTransformations node with\n    | Some(tfs) ->\n        let tfs = \n          if List.length tfs = 1 then tfs // Do not filter if Empty would be the only transform\n          else tfs |> List.filter (function Pivot.Empty -> false | _ -> true)\n        if List.isEmpty tfs then None else Some(node, tfs)\n    | None -> None )\n  Log.trace(\"live\", \"Transformations: %O\", [| for n, tfs in tfss -> n.Node, transformName (List.head tfs) + \" \" + string tfs.Length |])\n  match tfss with\n  | (e, tfs)::tfss -> loop [] (List.head tfs, [e], List.length tfs) tfss\n  | [] -> []\n\n\n// ------------------------------------------------------------------------------------------------\n// Pivot editor: State of the editor\n// ------------------------------------------------------------------------------------------------\n\ntype PivotEditorMenus =\n  | AddDropdownOpen\n  | ContextualDropdownOpen\n  | Hidden\n\ntype PivotEditorAction = \n  | UpdatePreview of DomNode\n  | SelectRange of Range\n  | SelectChainElement of int\n  | AddTransform of Pivot.Transformation\n  | RemoveSection of Symbol\n  | RemoveElement of Symbol\n  | ReplaceElement of Symbol * string * option<list<Expr>>\n  | ReplaceRange of Range * string\n  | AddElement of Symbol * string * option<list<Expr>>\n  | SwitchMenu of PivotEditorMenus\n  \ntype PivotEditorState = \n  { Body : Node<Expr>\n    FirstNode : Node<Expr>\n    Preview : DomNode\n    Sections : PivotSection list\n    SelectedEntity : Entity\n    Menus : PivotEditorMenus\n    Focus : option<string * int option> }\n\n\n// ------------------------------------------------------------------------------------------------\n// Pivot editor: Handling events triggered by the editor\n// ------------------------------------------------------------------------------------------------\n\nlet withPivotState (pivotState:PivotEditorState) state =\n  { state with State = pivotState }\n\nlet findPreview (ch:NestedChain) trigger globals (ent:Entity) = \n  let msg = \n    match ent.Kind with \n    | EntityKind.MemberAccess({Kind = EntityKind.Member(_, {Kind=EntityKind.MemberName n})}) -> n.Name\n    | EntityKind.Call _ -> \"call\"\n    | _ -> \"whatever\"\n\n  Log.trace(\"live\", \"Get preview for: %O\", msg)    \n  let nm = { Name.Name=\"preview\" }\n  let prevDom = \n    ch.Chain \n    |> Seq.skipWhile (fun (_, nd) -> nd.Entity.Value.Symbol <> ent.Symbol)\n    |> Seq.sortBy fst \n    |> Seq.tryPick (fun (loc, node) ->\n      match node.Entity.Value.Type with \n      | Some(Type.Object(FindMember nm m)) ->\n          match pickMetaByType \"http://schema.org\" \"WebPage\" m.Metadata with\n          | Some meta ->  \n              let url = getProperty meta \"url\"\n              Log.trace(\"live\", \"Found preview webpage at %s: %O\", loc, url)\n              h?iframe [ \"src\" => url ] [] |> Some\n          | _ ->\n              let res = Interpreter.evaluate globals ent  \n              let res = res |> FsOption.bind (fun p -> p.Preview.Value)\n              match res with\n              | Some p ->\n                  Log.trace(\"live\", \"Found preview value at %s: %O\", loc, p)\n                  let mutable node = h?div [\"class\" => \"placeholder\"] [text \"Loading preview...\"]\n                  let mutable returned = false\n                  async { let! nd = table<int, int>.create(unbox<Series.series<string, obj>> p).render()\n                          if returned then trigger (CustomEvent(UpdatePreview nd))\n                          else node <- nd\n                          Log.trace(\"live\", \"Evaluated to a node\") } |> Async.StartImmediate\n                  returned <- true\n                  Log.trace(\"live\", \"After evaluation started: %O\", node)\n                  node |> Some\n              | _ -> \n                h?div [ \"class\" => \"placeholder\" ] [ text \"Preview could not be evaluated\" ] |> Some\n      | _ -> None)\n  match prevDom with \n  | Some dom -> dom\n  | _ -> h?div [ \"class\" => \"placeholder\" ] [ text \"This block does not have a preview\" ]\n\n\n/// Recreate editor state based on the current source code and cursor location\n/// (this is called after the cursor moves or code changes)\nlet updateBody trigger state = \n  match commandAtLocation state.Location state.Program with\n  | Some(cmd) ->\n      let line, col = state.Mapper.AbsoluteToLineCol(cmd.Range.End + 1)\n      let (Command.Expr expr | Command.Let(_, expr)) = cmd.Node \n      match collectFirstChain expr with\n      | Some(ch) ->\n          let sections = createPivotSections ch\n          let _, first = ch.Chain |> List.head\n          match ch.Chain |> List.filter (fun (start, node) -> state.Location >= start) |> List.tryLast with\n          | Some(_, selNode) when not (List.isEmpty sections) ->\n              let preview = findPreview ch trigger state.Globals selNode.Entity.Value\n              let ps = \n                { Menus = Hidden; Focus = None; FirstNode = first; SelectedEntity = selNode.Entity.Value\n                  Sections = sections; Body = expr; Preview = preview }\n              state |> withPivotState ps |> Some\n          | _ -> None\n      | _ -> None\n  | _ -> None\n\nlet hideMenus state = \n  { state with State = { state.State with Menus = Hidden } }\n\nlet editorLocation (mapper:LocationMapper) startIndex endIndex = \n  let sl, sc = mapper.AbsoluteToLineCol(startIndex)\n  let el, ec = mapper.AbsoluteToLineCol(endIndex)\n  let rng = JsInterop.createEmpty<monaco.IRange>\n  { StartLineNumber = sl; StartColumn = sc \n    EndLineNumber = el; EndColumn = ec }\n\nlet selectName nd state = \n  let rng =\n    match nd with\n    | { Node = Expr.Member(_, n) } -> n.Range\n    | _ -> nd.Range\n  let loc = editorLocation state.Mapper rng.Start (rng.End+1)\n  { state with Selection = Some loc }\n\n/// Collect the chain and call specified fnction with parsed body, chain and sections\nlet tryTransformChain f state = \n  match collectFirstChain state.State.Body with\n  | Some(ch) ->\n      let sections = ch |> createPivotSections \n      f state.State.Body (List.map snd ch.Chain) sections |> hideMenus\n  | _ -> hideMenus state\n\nlet marker = \"InsertPropertyHere\"\n\nlet replaceAndSelectMarker newName state = \n  let startIndex = state.Code.IndexOf(marker)\n  let newCode = state.Code.Replace(marker, Ast.escapeIdent newName)\n  let mapper = LocationMapper(state.Code)\n  let rng = editorLocation mapper startIndex (startIndex + (Ast.escapeIdent newName).Length)\n  { state with Code = newCode; Selection = Some rng }\n\nlet reconstructChain state (body:Node<_>) newNodes = \n  let newBody =\n    List.tail newNodes \n    |> List.fold (fun prev part ->\n      match part.Node with \n      | Expr.Member(_, n) -> { part with Node = Expr.Member(prev, n) }\n      | Expr.Call(_, args) -> { part with Node = Expr.Call(prev, args) }\n      | _ -> failwith \"reconstructChain: Unexpected node in call chain\") (List.head newNodes)\n\n  let newCode = (Ast.formatSingleExpression newBody).Trim()\n  let newCode = state.Code.Substring(0, body.Range.Start) + newCode + state.Code.Substring(body.Range.End + 1)\n  { state with Code = newCode }\n\nlet createChainNodes args name = \n  let node nd = Ast.node {Start=0; End=0} nd\n  let mem = node (Expr.Member(node Expr.Empty, node (Expr.Variable(node {Name=name}))))\n  match args with\n  | None -> [ mem ]\n  | Some args -> \n      let args = args |> List.map (fun a -> { Name = None; Value = node a })\n      [ mem; node (Expr.Call(mem, node args)) ] \n\nlet getWhiteBeforeAndAfterSections firstNode sections =\n  let dominantWhite whites = \n    let whites = whites |> List.countBy id |> List.ofSeq\n    (\"\",0)::whites |> List.maxBy (fun (s, c) -> if s = \"\" then 0 else c) |> fst\n  let whiteBefore, whiteAfter =\n    sections |> List.map (fun sec -> List.head sec.Nodes) |> List.map Ast.formatWhiteBeforeExpr |> dominantWhite,\n    sections |> List.map (fun sec -> List.last sec.Nodes) |> List.append [firstNode] |> List.map Ast.formatWhiteAfterExpr |> dominantWhite\n  Log.trace(\"live\", \"Inserting whitespace before '%s' and after '%s' for sections: %O\", whiteBefore, whiteAfter, sections)\n  [ { Token = TokenKind.White whiteBefore; Range = {Start=0; End=0} } ],\n  [ { Token = TokenKind.White whiteAfter; Range = {Start=0; End=0} } ]\n\nlet insertWhiteAroundSection before after section = \n  let lastIdx = (List.length section.Nodes) - 1\n  { Transformation = section.Transformation\n    Nodes = \n      section.Nodes |> List.mapi (fun i node ->\n        let node = \n          match before, node with\n          | Some before, { Node = Expr.Member(inst, n) } when i = 0 -> \n              { node with Node = Expr.Member(inst, { n with WhiteBefore = before }) }\n          | _ -> node\n        let node = \n          match after, node with\n          | Some after, node when i = lastIdx -> { node with WhiteAfter = after }\n          | _ -> node\n        node ) }\n\nlet rec updatePivotState trigger state event = \n  match event with\n  | UpdateSource _ \n  | UpdateLocation _ -> state |> hideMenus |> updateBody trigger \n  | InitializeGlobals _ -> Some state\n  | CustomEvent event -> \n  match event with\n  | UpdatePreview prev -> \n      state |> withPivotState { state.State with Preview = prev } |> Some\n\n  | SwitchMenu menu ->\n      state |> withPivotState { state.State with Menus = menu } |> Some\n  \n  | SelectChainElement(dir) ->\n      state |> tryTransformChain (fun body chain sections ->\n        let rec loop before (chain:Node<_> list) = \n          match chain with\n          | c::chain when c.Range.End + 1 < state.Location -> loop c chain\n          | c::after::_ -> before, c, after\n          | [c] -> before, c, c\n          | [] -> before, before, before\n        let before, it, after = loop (List.head chain) (List.tail chain)\n        state |> selectName (if dir < 0 then before elif dir > 0 then after else it) ) |> Some\n          \n  | SelectRange(rng) ->    \n      { state with Selection = Some (editorLocation state.Mapper rng.Start (rng.End+1)) } |> Some\n\n  | ReplaceRange(rng, value) ->    \n      Log.trace(\"live\", \"Replace '%s' with '%s'\", state.Code.Substring(rng.Start, rng.End - rng.Start + 1), value)\n      let newCode = state.Code.Substring(0, rng.Start) + value + state.Code.Substring(rng.End + 1)\n      let location = editorLocation (LocationMapper(newCode)) rng.Start (rng.Start+value.Length)\n      { state with Code = newCode; Selection = Some location } |> Some\n\n  | AddElement(sym, name, args) ->\n      state |> tryTransformChain (fun body chain sections ->\n        let newNodes =\n          chain |> List.collect (fun nd -> \n            if nd.Entity.Value.Symbol <> sym then [nd]\n            else nd :: (createChainNodes args marker) )        \n        reconstructChain state body newNodes\n        |> replaceAndSelectMarker name) |> Some\n\n  | ReplaceElement(sym, name, args) ->\n      state |> tryTransformChain (fun body chain sections ->\n        let newNodes =\n          chain |> List.collect (fun nd -> \n            if nd.Entity.Value.Symbol <> sym then [nd]\n            else createChainNodes args marker )\n        reconstructChain state body newNodes\n        |> replaceAndSelectMarker name) |> Some\n\n  | RemoveElement sym ->\n      state |> tryTransformChain (fun body chain sections ->\n        let beforeDropped = chain |> List.takeWhile (fun nd -> nd.Entity.Value.Symbol <> sym) |> List.tryLast\n        let beforeDropped = defaultArg beforeDropped (List.head chain)\n        let newNodes = chain |> List.filter (fun nd -> nd.Entity.Value.Symbol <> sym)        \n        reconstructChain state body newNodes\n        |> selectName beforeDropped) |> Some\n\n  | RemoveSection sym ->\n      state |> tryTransformChain (fun body chain sections ->\n        let beforeDropped = \n          sections |> List.map (fun sec -> List.head sec.Nodes) \n          |> List.takeWhile (fun nd -> nd.Entity.Value.Symbol <> sym) |> List.tryLast\n        let beforeDropped = defaultArg beforeDropped (List.head chain)\n        let newSections = sections |> List.filter (fun sec -> (List.head sec.Nodes).Entity.Value.Symbol <> sym)\n        let newNodes = newSections |> List.collect (fun sec -> sec.Nodes)\n        reconstructChain state body newNodes\n        |> selectName beforeDropped ) |> Some\n\n  | AddTransform tfs ->\n      state |> tryTransformChain (fun body chain sections ->\n        Log.trace(\"live\", \"Adding transform to chain: %O\", Array.ofSeq chain)\n        Log.trace(\"live\", \"Existing sections are: %O\", Array.ofSeq sections)\n        let whiteBefore, whiteAfter = getWhiteBeforeAndAfterSections (List.head chain) sections\n        let node n = Ast.node { Start=0; End=0; } n\n\n        let fields =  \n          sections \n          |> List.collect (fun s -> s.Nodes) |> List.rev \n          |> List.tryPick pickPivotFields\n\n        let firstProperty, properties = \n          match tfs with\n          | Pivot.GetRange _ | Pivot.Metadata _ -> failwith \"Unexpected get range or metadata\"\n          | Pivot.DropColumns _ -> \"drop columns\", [marker; \"then\"]\n          | Pivot.SortBy _ -> \"sort data\", [marker; \"then\"]\n          | Pivot.FilterBy _ -> \"filter data\", [marker; \"then\"] // TODO\n          | Pivot.WindowBy _ -> \"windowing\", [marker; \"then\"] // TODO\n          | Pivot.ExpandBy _ -> \"expanding\", [marker; \"then\"] // TODO\n          | Pivot.Paging _ -> \"paging\", [marker; \"then\"]\n          | Pivot.GetSeries _ -> \"get series\", [marker]\n          | Pivot.GetTheData -> \"get the data\", [marker]\n          | Pivot.GroupBy(_, _) -> \n              \"group data\", \n              match fields with\n              | Some (f::_) -> [marker; \"by \" + f.Name; \"then\"]\n              | _ -> [marker; \"by Property\"; \"then\"]\n          | Pivot.GroupBy([], _) | Pivot.Empty -> \"\", []\n\n        let newSection =\n          { Transformation = tfs; Nodes = List.collect (createChainNodes None) properties }\n          |> insertWhiteAroundSection (Some whiteBefore) (Some whiteAfter)\n\n        let closeFirstSection = function\n          | section::sections -> \n              let section =\n                match section.Transformation, List.last section.Nodes with\n                | Pivot.Paging _, { Node = Expr.Call({ Node = Expr.Member(_, { Node = Expr.Variable(n) }) }, _) } \n                    when n.Node.Name = \"take\" -> section \n                | _, { Node = Expr.Member(_, { Node = Expr.Variable n }) } \n                    when n.Node.Name = \"then\" -> section \n                | Pivot.Empty, _ -> section\n                | _ -> { section with Nodes = section.Nodes @ (createChainNodes None \"then\") }\n              (insertWhiteAroundSection None (Some whiteAfter) section) :: sections\n          | [] -> []\n\n        let newSections = \n          match List.rev sections with\n          | ({ Transformation = Pivot.GetSeries _ | Pivot.GetTheData } as last)::sections ->\n              List.rev (last::newSection::closeFirstSection sections)\n          | sections -> List.rev (newSection::closeFirstSection sections)\n              \n        Log.trace(\"live\", \"Inserted section: %O\", Array.ofSeq newSections)\n        let newNodes = newSections |> List.collect (fun sec -> sec.Nodes)\n        reconstructChain state body newNodes\n        |> replaceAndSelectMarker firstProperty ) |> Some\n\n\n// ------------------------------------------------------------------------------------------------\n// Pivot editor: Rendering user interface from state\n// ------------------------------------------------------------------------------------------------\n\nlet renderNodeList trigger nodes =\n  [ for nd in nodes do\n      match nd.Node with\n      | Expr.Member(_, { Node = Expr.Variable n }) when n.Node.Name <> \"then\" ->\n          yield h?span [] [\n            h?a [\"click\" =!> trigger (SelectRange(n.Range)) ] [\n              text n.Node.Name \n            ]\n            h?a [\"click\" =!> trigger (RemoveElement(nd.Entity.Value.Symbol))] [\n              h?i [\"class\" => \"gfa gfa-times\"] [] \n            ]\n          ]\n      | _ -> () ]\n\nlet renderContextMenu trigger = \n  h?a [\"class\" => \"right\"; \"click\" =!> trigger (SwitchMenu ContextualDropdownOpen) ] [\n    h?i [\"class\" => \"gfa gfa-plus\"] [] \n  ]\n\nlet renderAddPropertyMenu trigger f nodes =\n  [ let lastNode = nodes |> List.rev |> List.find (function \n      | { Node = Expr.Member(_, { Node = Expr.Variable n }) } -> n.Node.Name <> \"then\" \n      | _ -> true) \n    match lastNode.Entity.Value.Type with\n    | Some(Type.Object obj) ->\n        let members = \n          obj.Members \n          |> Seq.choose (fun m -> if f m.Name then Some m.Name else None)\n          |> Seq.sort\n        yield h?ul [] [\n          for n in members ->\n            h?li [] [ \n              h?a [ \"click\" =!> trigger (AddElement(lastNode.Entity.Value.Symbol, n, None)) ] [ text n] \n            ]\n        ]\n    | _ -> () ]\n\nlet renderSection triggerEvent section = \n  let trigger action = fun _ (e:Event) -> e.cancelBubble <- true; triggerEvent (CustomEvent(action))\n  let triggerWith f = fun el (e:Event) -> e.cancelBubble <- true; triggerEvent (CustomEvent(f el))\n  let getNodeNameAndSymbol = function\n    | Some { Entity = Some e; Node = Expr.Member(_, { Node = Expr.Variable n }) } -> n.Node.Name, Some e.Symbol\n    | _ -> \"\", None\n  [ match section with\n    | Some { Nodes = nodes; Transformation = Pivot.GetSeries _ } ->\n        let getSeriesNode, keyNode, valNode = \n          match nodes with \n          | gs::gsk::gsv::_ -> gs, Some gsk, Some gsv\n          | gs::gsk::_ -> gs, Some gsk, None\n          | gs::_ -> gs, None, None\n          | _ -> failwith \"No get series node in get series transformation\"\n        let keyName, keySym = getNodeNameAndSymbol keyNode\n        let valName, valSym = getNodeNameAndSymbol valNode\n        match getSeriesNode.Entity.Value.Type with\n        | Some(Type.Object obj) ->\n            yield h?span [] [text \"with key\"]\n            yield h?select [\"change\" =!> triggerWith(fun el -> \n                match keySym with\n                | None -> AddElement(getSeriesNode.Entity.Value.Symbol, (unbox<HTMLSelectElement> el).value, None)\n                | Some selSym -> ReplaceElement(selSym, (unbox<HTMLSelectElement> el).value, None)) ] [\n              if keyName = \"\" then yield h?option [ \"value\" => \"\"; \"selected\" => \"selected\" ] [ text \"\" ]\n              for m in obj.Members do\n                let n = m.Name\n                if n.StartsWith(\"with key\") then\n                  yield h?option [  \n                    yield \"value\" => n\n                    if keyName = n then yield \"selected\" => \"selected\" ] [ text (n.Replace(\"with key \", \"\")) ] \n            ]\n        | _ -> ()\n        match keyNode with\n        | Some({ Entity = Some ({ Type = Some (Type.Object obj) } as keyEnt)}) ->\n            yield h?span [] [text \"and value\"]\n            yield h?select [\"change\" =!> triggerWith(fun el -> \n                match valSym with\n                | None -> AddElement(keyEnt.Symbol, (unbox<HTMLSelectElement> el).value, None)\n                | Some selSym -> ReplaceElement(selSym, (unbox<HTMLSelectElement> el).value, None)) ] [\n              if valName = \"\" then yield h?option [ \"value\" => \"\"; \"selected\" => \"selected\" ] [ text \"\" ]\n              for m in obj.Members do\n                let n = m.Name\n                if n.StartsWith(\"and value\") then\n                  yield h?option [  \n                    yield \"value\" => n\n                    if valName = n then yield \"selected\" => \"selected\" ] [ text (n.Replace(\"and value \", \"\")) ] \n            ]\n        | _ -> ()\n\n    | Some { Nodes = nodes; Transformation = Pivot.GroupBy _ } ->\n        let firstNode, selNode, aggNodes = \n          match nodes with \n          | gby::sel::aggs -> gby, Some sel, aggs\n          | gby::_ -> gby, None, []\n          | _ -> failwith \"No group by node in group by transformation\"\n        let selName, selSym = getNodeNameAndSymbol selNode\n        match firstNode.Entity.Value.Type with\n        | Some(Type.Object obj) ->\n            yield h?select [\"change\" =!> triggerWith(fun el -> \n                match selSym with\n                | None -> AddElement(firstNode.Entity.Value.Symbol, (unbox<HTMLSelectElement> el).value, None)\n                | Some selSym -> ReplaceElement(selSym, (unbox<HTMLSelectElement> el).value, None)) ] [\n              if selName = \"\" then yield h?option [ \"value\" => \"\"; \"selected\" => \"selected\" ] [ text \"\" ]\n              for m in obj.Members do\n                let n = m.Name\n                if n.StartsWith(\"by\") then\n                  yield h?option [  \n                    yield \"value\" => n\n                    if selName = n then yield \"selected\" => \"selected\" ] [ text n ] \n            ]\n        | _ -> ()\n        yield! renderNodeList trigger aggNodes  \n        yield renderContextMenu trigger\n        \n    | Some { Nodes = nodes; Transformation = Pivot.Paging _ } ->                    \n        let methods = nodes |> List.map (function { Node = Expr.Member(_, { Node = Expr.Variable n }) } -> n.Node.Name | _ -> \"\") |> set\n        for nd in nodes do\n          match nd.Node with\n          | Expr.Call({ Node = Expr.Member(_, { Node = Expr.Variable n }) }, { Node = [arg] }) ->\n              let removeOp =\n                if n.Node.Name = \"take\" then ReplaceElement(nd.Entity.Value.Symbol, \"then\", None)\n                else RemoveElement(nd.Entity.Value.Symbol)\n              yield h?span [] [\n                  h?a [\"click\" =!> trigger (SelectRange(n.Range)) ] [ text n.Node.Name ]\n                  h?input [ \n                    \"id\" => \"input-pg-\" + n.Node.Name\n                    \"input\" =!> fun el _ -> \n                      let input = unbox<HTMLInputElement> el\n                      let parsed, errors = Parser.parseProgram input.value\n                      if errors.Length = 0 && parsed.Body.Node.Length = 1 then\n                        setCustomValidity el \"\"\n                        ReplaceRange(arg.Value.Range, input.value) |> CustomEvent |> triggerEvent\n                      else setCustomValidity el \"Cannot parse expression\"\n                    \"value\" => Ast.formatSingleExpression arg.Value ] []\n                  h?a [\"click\" =!> trigger (removeOp)] [\n                    h?i [\"class\" => \"gfa gfa-times\"] [] \n                  ]\n                ]\n          | _ -> ()\n        if not (methods.Contains \"take\" && methods.Contains \"skip\") then\n          yield renderContextMenu trigger\n\n    | Some { Nodes = nodes; Transformation = Pivot.SortBy _ } ->\n        let props = nodes |> List.choose (function\n          | { Node = Expr.Member(_, { Node = Expr.Variable n }); Entity = Some { Symbol = sym} }\n              when n.Node.Name <> \"then\" && n.Node.Name <> \"sort data\" -> Some(sym, n) | _ -> None)\n        let last = List.tryLast props\n        for sym, n in props ->\n          h?span [] [\n            yield h?a [\"click\" =!> trigger (SelectRange(n.Range)) ] [\n              text n.Node.Name \n            ]\n            if n.Node.Name = (snd last.Value).Node.Name then\n              yield h?a [\"click\" =!> trigger (RemoveElement(sym))] [\n                h?i [\"class\" => \"gfa gfa-times\"] [] \n              ]\n          ]\n        yield renderContextMenu trigger\n\n    | Some { Nodes = nodes; Transformation = Pivot.DropColumns _ } ->\n        yield! renderNodeList trigger (List.tail nodes)\n        yield renderContextMenu trigger\n\n    | _ -> () ]\n\nlet renderPivot triggerEvent (state:LiveState<_>) = \n  let trigger action = fun _ (e:Event) -> e.cancelBubble <- true; triggerEvent (CustomEvent(action))\n  let triggerWith f = fun el (e:Event) -> e.cancelBubble <- true; triggerEvent (CustomEvent(f el))\n  let selSec = state.State.Sections |> List.tryFind (fun sec -> \n    sec.Nodes |> List.exists (fun secEnt -> state.State.SelectedEntity.Symbol = secEnt.Entity.Value.Symbol) )\n  let firstNode = state.State.FirstNode\n  let dom = \n    h?div [\n        yield \"class\" => \"pivot-preview\"\n        if state.State.Menus <> Hidden then yield \"click\" =!> trigger (SwitchMenu Hidden)\n      ] [\n      h?ul [\"class\" => \"tabs\"] [\n        for sec in state.State.Sections ->\n          let selected = sec.Nodes |> List.exists (fun secEnt -> state.State.SelectedEntity.Symbol = secEnt.Entity.Value.Symbol)\n          let secSymbol = (sec.Nodes |> List.head).Entity.Value.Symbol\n          let identRange = \n            match sec.Nodes with\n            | { Node \n                  = Expr.Variable n \n                  | Expr.Member(_, { Node = Expr.Variable n }) \n                  | Expr.Call({ Node = Expr.Variable n }, _) \n                  | Expr.Call({ Node = Expr.Member(_, { Node = Expr.Variable n })}, _) }::_ -> n.Range\n            | _ -> failwith \"Unexpected node in pivot call chain\" \n\n          h?li [\"class\" => if selected then \"selected\" else \"\"] [\n            match sec.Transformation with\n            | Pivot.Transformation.Empty ->\n                // Empty transform means the data source\n                yield h?a [\"click\" =!> trigger (SelectRange(identRange)) ] [\n                  match firstNode.Node with\n                  | Expr.Variable n -> yield text n.Node.Name\n                  | _ -> yield text \"data\"\n                ]\n            | _ ->\n                // All other normal transformations\n                yield h?a [\"click\" =!> trigger (SelectRange(identRange)) ] [\n                  text (transformName sec.Transformation) \n                ]\n                yield h?a [\"click\" =!> trigger (RemoveSection(secSymbol))] [\n                  h?i [\"class\" => \"gfa gfa-times\"] [] \n                ]\n          ]\n        yield h?li [\"class\" => if state.State.Menus = AddDropdownOpen then \"add selected\" else \"add\"] [ \n          h?a [\"click\" =!> trigger (SwitchMenu AddDropdownOpen) ] [\n            h?i [\"class\" => \"gfa gfa-plus\"] [] \n          ]\n        ]\n      ]\n      h?div [\"class\" => \"add-menu\"] [\n        let clickHandler tfs = \"click\" =!> trigger (AddTransform(tfs))\n        if state.State.Menus = AddDropdownOpen then \n          yield h?ul [] [\n            yield h?li [] [ h?a [ clickHandler(Pivot.DropColumns []) ] [ text \"drop columns\"] ]\n            //yield h?li [] [ h?a [ clickHandler(Pivot.FilterBy(Pivot.And, [])) ] [ text \"filter by\"] ]\n            yield h?li [] [ h?a [ clickHandler(Pivot.GroupBy([], [])) ] [ text \"group by\"] ]\n            yield h?li [] [ h?a [ clickHandler(Pivot.Paging []) ] [ text \"paging\"] ]\n            yield h?li [] [ h?a [ clickHandler(Pivot.SortBy []) ] [ text \"sort by\"] ]\n            let getDataCalled = \n              state.State.Sections |> List.exists (function \n                | { Transformation = Pivot.GetTheData | Pivot.GetSeries _ } -> true | _ -> false)\n            if not getDataCalled then\n              yield h?li [] [ h?a [ clickHandler(Pivot.GetTheData) ] [ text \"get the data\"] ]\n              yield h?li [] [ h?a [ clickHandler(Pivot.GetSeries(\"!\", \"!\")) ] [ text \"get series\"] ]\n          ]\n      ]\n      h?div [\"class\" => \"toolbar\"] [\n        yield h?span [\"class\"=>\"navig\"] [\n          h?a [] [ h?i [\"click\" =!> trigger (SelectChainElement -1); \"class\" => \"gfa gfa-chevron-left\"] [] ]\n          h?a [] [ h?i [\"click\" =!> trigger (SelectChainElement 0); \"class\" => \"gfa gfa-circle\"] [] ]\n          h?a [] [ h?i [\"click\" =!> trigger (SelectChainElement +1); \"class\" => \"gfa gfa-chevron-right\"] [] ]\n        ]\n        yield! renderSection triggerEvent selSec\n      ]\n\n      h?div [\"class\" => \"add-menu\"] [\n        match state.State.Menus, selSec with\n        | ContextualDropdownOpen, Some { Nodes = nodes; Transformation = Pivot.Paging _ } ->\n            let methods = nodes |> List.choose (function \n              | { Node = Expr.Member(_, { Node = Expr.Variable n }); Entity = e } -> \n                  Some(n.Node.Name, e.Value.Symbol) | _ -> None) |> dict\n            let lastSym = (List.last nodes).Entity.Value.Symbol\n            let firstSym = (List.head nodes).Entity.Value.Symbol\n            yield h?ul [] [\n              if not (methods.ContainsKey \"take\") then\n                let op = \n                  if methods.ContainsKey \"then\" then ReplaceElement(methods.[\"then\"], \"take\", Some [Expr.Number 10.])\n                  else AddElement(lastSym, \"take\", Some [Expr.Number 10.])\n                yield h?li [] [ h?a [ \"click\" =!> trigger op ] [ text \"take\"] ]\n              if not (methods.ContainsKey \"skip\") then\n                let op = AddElement(firstSym, \"skip\", Some [Expr.Number 10.])\n                yield h?li [] [ h?a [ \"click\" =!> trigger op ] [ text \"skip\"] ]\n            ]\n\n        | ContextualDropdownOpen, Some { Nodes = nodes; Transformation = Pivot.GroupBy _ } ->\n            yield! nodes |> renderAddPropertyMenu trigger (fun n -> \n              n <> \"then\" && n <> \"preview\" && not (n.StartsWith(\"and\")) )\n        | ContextualDropdownOpen, Some { Nodes = nodes; Transformation = Pivot.SortBy _ } ->\n            yield! nodes |> renderAddPropertyMenu trigger (fun n -> n <> \"then\" && n <> \"preview\")\n        | ContextualDropdownOpen, Some { Nodes = nodes; Transformation = Pivot.DropColumns _ } ->\n            yield! nodes |> renderAddPropertyMenu trigger (fun n -> n <> \"then\" && n <> \"preview\")\n        | _ -> ()\n      ]\n      h?div [\"class\" => \"preview-body\"] [\n        yield state.State.Preview\n      ] \n    ]\n  let endLine, _ = state.Mapper.AbsoluteToLineCol(state.State.Body.Range.End)\n  Some { Line = endLine; Preview = dom }\n\n\n// ------------------------------------------------------------------------------------------------\n//\n// ------------------------------------------------------------------------------------------------\n\nlet preview = \n  { ID = \"Pivot\"\n    Update = updatePivotState\n    Render = renderPivot \n    InitialState = \n      { Body = Ast.node { Start = 0; End = 0 } Expr.Empty \n        FirstNode = Ast.node { Start = 0; End = 0 } Expr.Empty \n        SelectedEntity = Unchecked.defaultof<_>\n        Preview = text \"not created\"\n        Sections = []; Menus = Hidden; Focus = None } }","﻿// ------------------------------------------------------------------------------------------------\n// Live preview for anything with 'show' method\n// ------------------------------------------------------------------------------------------------\nmodule TheGamma.Live.Showable\n\nopen Fable.Core\nopen Fable.Import\nopen Fable.Import.Browser\n\nopen TheGamma\nopen TheGamma.Ast\nopen TheGamma.Html\nopen TheGamma.Live.Common\nopen TheGamma.Common\nopen TheGamma.TypeChecker\nopen TheGamma.TypeProviders\n\nmodule FsOption = Microsoft.FSharp.Core.Option\n\n// ------------------------------------------------------------------------------------------------\n//\n// ------------------------------------------------------------------------------------------------\n\nlet commandAtLocation loc (program:Program) =\n  program.Body.Node |> List.tryFind (fun cmd ->\n    cmd.Range.Start <= loc && cmd.Range.End + 1 >= loc)\n\ntype ShowableEditorState = \n  { EndLocation : int\n    Preview : DomNode \n    PreviewSymbol : Symbol\n    PreviewID : int\n    }\n\n[<Emit(\"$0.show($1)\")>]\nlet callShow (inst:obj) (id:string) : unit = failwith \"JS\"\n\nlet (|HasShow|_|) = function\n  | Type.Object obj ->\n      let hasShow = obj.Members |> Array.exists (function \n        | { Name=\"show\"; Type=Type.Method([{ Type = Type.Primitive PrimitiveType.String }], _) } -> true\n        | _ -> false)\n      if hasShow then Some() else None\n  | _ -> None\n\nlet updateBody trigger state = \n  Log.trace(\"live\", \"Showable - updating body\")\n  match commandAtLocation state.Location state.Program with\n  | Some({ Node = Command.Let(_, e); Entity = Some { Kind = EntityKind.LetCommand(_, ent) } } as cmd) \n  | Some({ Node = Command.Expr e; Entity = Some { Kind = EntityKind.RunCommand ent } } as cmd) ->\n      let chain = collectFirstChain e\n      match ent.Type.Value, chain with \n      | HasShow, _ ->\n          match Interpreter.evaluate state.Globals ent with \n          | Some res ->\n              let id = \n                if ent.Symbol <> state.State.PreviewSymbol then state.State.PreviewID + 1\n                else state.State.PreviewID\n              let placeholder = h?div [\"class\"=>\"placeholder\"] [text \"Loading preview...\"]\n              let dom = h?div [] [h.delayed (string id) placeholder (fun id ->            \n                Log.trace(\"live\", \"Show: %O\", res.Value)\n                callShow res.Value id\n              )]\n              Some { state with State = { PreviewSymbol = ent.Symbol; PreviewID = id; EndLocation = cmd.Range.End; Preview = dom } }\n          | _ -> None\n            \n      | _, Some chain -> \n          chain.Chain |> Seq.sortByDescending fst |> Seq.tryPick (fun (_, node) ->\n            let nm = { Name.Name=\"preview\" }\n            match node.Entity.Value.Type with\n            | Some(Type.Object(FindMember nm m)) ->\n                match pickMetaByType \"http://schema.org\" \"WebPage\" m.Metadata with\n                | Some meta ->  \n                    let url = getProperty meta \"url\"\n                    let dom = h?iframe [ \"src\" => url ] [] \n                    let id = state.State.PreviewID + 1\n                    Some { state with State = { PreviewSymbol = ent.Symbol; PreviewID = id; EndLocation = cmd.Range.End; Preview = dom } }\n                | _ -> None\n            | _ -> None)\n\n      | _ -> None\n  | _ -> None\n\n\nlet rec updateShowableState trigger state event = \n  match event with\n  | UpdateSource _ \n  | UpdateLocation _ -> state |> updateBody trigger \n  | InitializeGlobals _ \n  | CustomEvent () -> Some state \n\nlet renderShowable trigger (state:LiveState<_>) = \n  let endLine, _ = state.Mapper.AbsoluteToLineCol(state.State.EndLocation)\n  let dom = \n    h?div [ \"class\" => \"pivot-preview\" ] [\n      h?ul [\"class\" => \"tabs\"] [\n        h?li [\"class\" => \"selected\"] [ h?a [] [ text \"preview\" ] ]\n      ]\n      h?div [\"class\" => \"preview-body\"] [\n        yield state.State.Preview\n      ] \n    ]\n  Some { Line = endLine; Preview = dom }\n\n\n// ------------------------------------------------------------------------------------------------\n//\n// ------------------------------------------------------------------------------------------------\n\nlet preview = \n  { ID = \"Showable\"\n    Update = updateShowableState\n    Render = renderShowable\n    InitialState = { PreviewID = 0; PreviewSymbol = createSymbol(); EndLocation = 0; Preview = text \"not created\" } }","﻿module TheGamma.Blocks\n\nopen Fable.Import.Browser\nopen TheGamma.Common\nopen TheGamma.Html\nopen TheGamma.Ast\nopen TheGamma.TypeProviders.FSharpProvider\n\nopen System\n\nlet getEntity (svc:Services.CheckingService) code = async {\n  let! success, bound, prog = svc.TypeCheck(\"let it = \" + code)\n  let _, ent = bound.Entities |> Seq.find (function (_, { Kind = EntityKind.Variable({ Name = \"it\" }, _) }) -> true | _ -> false)\n  let _, prog = bound.Entities |> Seq.find (function (_, { Kind = EntityKind.Program _ }) -> true | _ -> false)\n  let errors = TypeChecker.collectTypeErrors prog\n  let errors = [ for e in errors -> code.Substring(e.Range.Start, e.Range.End - e.Range.Start + 1), e.Message ]\n  return errors, ent }\n\n\ntype Event = \n  | RemoveLast\n  | AddElement of string\n  | UpdateParameter of string * string\n\ntype State = \n  { CheckingService : Services.CheckingService\n    Globals : Entity list\n    Chain : list<string * (string * string) list option>\n    Completions : string[]\n    Entity : Entity option }\n  static member Create(svc, globals) = \n    { CheckingService = svc; Globals = globals\n      Entity = None; Chain = []; Completions = [||] }\n\nlet getTypeName state = \n  match state.Entity with\n  | Some { Type = Some(Type.Object(:? GenericType as s)) } -> s.TypeDefinition.FullName\n  | _ -> \"object\" \n\n\nlet formatChain chain = \n  chain \n  |> List.rev \n  |> List.map (fun (id, args) ->\n      Ast.escapeIdent id +\n      match args with \n      | Some args -> \"(\" + String.concat \", \" (List.map snd args) + \")\"\n      | None -> \"\")\n  |> String.concat \".\" \n\n\nlet updateCompletions state = async {\n  let! state = state\n  match state with \n  | { Chain = [] } -> \n      return { state with Completions = [| for g in state.Globals -> g.Name |] }\n  | { Chain = chain } -> \n      let code = formatChain chain\n      let! errs, ent = getEntity state.CheckingService code\n      match errs, ent with \n      | [], { Type = Some(Type.Object(obj)) } -> \n          let compls = [| for m in obj.Members do if m.Name <> \"preview\" then yield m.Name |]\n          return { state with Entity = Some ent; Completions = compls }\n      | _ -> \n          return { state with Entity = Some ent; Completions = [||] } }\n\n\nlet update state evt = updateCompletions <| async {\n  match evt, state with \n  | RemoveLast, { Chain = [] }\n  | RemoveLast, { Chain = [_] } -> \n      return { state with Chain = []; Entity = None }\n  | RemoveLast, { Chain = _::chain } -> \n      return { state with Chain = chain } \n\n  | AddElement(m), _ -> \n      let code = formatChain ((m, None)::state.Chain)\n      let! errs, ent = getEntity state.CheckingService code\n      match ent with \n      | { Type = Some(Type.Method(args, _)) } -> \n          return { state with Chain = (m, Some [ for a in args -> a.Name, \"\" ])::state.Chain } \n      | _ -> \n          return { state with Chain = (m, None)::state.Chain }\n\n  | UpdateParameter(p, v), { Chain = (m, Some pars)::rest } ->\n      let newPars = pars |> List.map (fun (po, vo) -> if p = po then p, v else po, vo)\n      return { state with Chain = (m, Some newPars)::rest } \n      \n  | _ -> return state }\n\n\nlet tryGetPreview state = \n  let (|Evaluate|) (l:Lazy<_>) = l.Value\n  match state.Entity with \n  | Some ent -> \n      Interpreter.evaluate state.Globals ent |> ignore\n      match ent.Value with \n      | Some { Preview = Evaluate (Some preview) } -> \n          let mutable node = h?div [\"id\" => \"blockspreview\"] [text \"Loading preview...\"]\n          let mutable returned = false\n          async { let! nd = table<int, int>.create(unbox<Series.series<string, obj>> preview).render()\n                  if returned then nd |> renderTo (document.getElementById \"blockspreview\")\n                  else node <- nd } |> Async.StartImmediate\n          returned <- true\n          node\n      | _ -> h?div [] [text \"Preview has no value\"]\n  | _ -> h?div [] [text \"No preview available\"]\n   \n\nlet render trigger state =\n  h?div [\"class\" => \"pilleditor\"] [\n    h?ul [\"class\" => \"pills\"] [\n      let renderCoreChain (chain:list<_ * _ option>) = \n        [ for id, pars in List.rev chain ->\n            h?li [] [ text (id + if pars.IsSome then \" (...)\" else \"\") ] ]\n\n      let renderChain removeLast chain = \n        match removeLast, chain with\n        | true, (last, _)::rest -> \n            renderCoreChain rest @ \n            [ h?li [] [ text last; h?a [\"click\" =!> fun _ _ -> trigger RemoveLast ] [ h?i [\"class\" => \"gfa gfa-times\"] [] ] ] ]\n        | _, rest -> \n            renderCoreChain rest\n\n      match state.Chain with\n      | (meth, Some pars)::rest -> yield! renderChain false rest \n      | chain -> yield! renderChain true chain\n\n      match state.Chain with\n      | (meth, Some pars)::rest ->\n          yield h?li [] [  \n            yield text (meth + \"(\")\n            for p, v in pars do \n              yield text (p + \" = \") \n              yield h?input [\"type\"=>\"text\"; \"value\"=>v; \"input\" =!> fun el _ -> \n                trigger (UpdateParameter(p, (unbox<HTMLInputElement> el).value)) ] []\n            yield text \")\"\n            yield h?a [\"click\" =!> fun _ _ -> trigger RemoveLast ] [ h?i [\"class\" => \"gfa gfa-times\"] [] ] \n          ]\n      | _ -> ()\n\n      if state.Completions.Length > 0 then\n          yield h?li [] [  \n            h?div [\"class\" => \"selectwrapper\"] [\n              h?select [ \"change\" =!> fun el _ -> trigger(AddElement((unbox<HTMLSelectElement> el).value)) ] [\n                yield h?option [] [text \"(choose an operation to add)\"] \n                for s in state.Completions -> h?option [ \"value\" => s ] [ text s ]\n              ]\n            ] \n          ]\n    ] \n\n    tryGetPreview state\n    \n    h?p [] [ text (getTypeName state) ]\n  ]\n\nlet createBlockEditor svc globals id = Async.StartImmediate <| async {\n  try\n    let! globals = globals |> Async.AwaitFuture\n    let state = State.Create(svc, globals)\n    let! state = \n      //[\"olympics\"; \"group data\"; \"by Games\"; \"average Year\"]\n      //[\"olympics\"; \"paging\"; \"take\"]\n      [\"enigma\"]\n      |> List.fold (fun st s -> async { let! st = st in return! update st (AddElement(s)) }) (async.Return state)\n    createVirtualDomAsyncApp id state render update\n  with e -> \n    Log.exn(\"system\", \"Something went wrong: %O\", e)\n  }\n\n\n    \n\n\n","﻿module TheGamma.Monaco\n\nopen Fable.Core\nopen Fable.Import.monaco\nopen Fable.Import.Browser\n\nopen TheGamma.Common\nopen TheGamma.Services\nopen TheGamma.TypeChecker\nopen Fable.Core.JsInterop\n\n[<Emit(\"var i = 1; eval('monaco$' + i + ' = monaco'); monaco = monaco;\")>]\nlet hack : unit = ()\nhack\n\nlet noState = \n  { new languages.IState with\n      member this.clone() = this\n      member this.equals(other) = true }\n\nlet getColorClass = function\n  | TokenKind.String _ -> \"string\" \n  | TokenKind.QIdent _ | TokenKind.Ident _ -> \"ident\" \n  | TokenKind.Dot _ -> \"operator\" \n  | TokenKind.Let | TokenKind.Boolean _ | TokenKind.Fun | TokenKind.Arrow -> \"keyword\" \n  | TokenKind.Number _ -> \"number\" \n  | _ -> \"\"\n\nlet tokensProvider = \n  { new languages.TokensProvider with\n      member this.tokenize(line, state) =\n        let tokens = JsInterop.createEmpty<languages.ILineTokens>\n        tokens.endState <- noState\n        tokens.tokens <- ResizeArray()\n\n        let tokenized, _ = Tokenizer.tokenize line\n        for t in tokenized do\n          let tok = JsInterop.createEmpty<languages.IToken>\n          tok.startIndex <- float t.Range.Start\n          tok.scopes <- Fable.Core.U2.Case1 (getColorClass t.Token)\n          tokens.tokens.Add(tok)\n\n        tokens\n      member this.getInitialState() = noState }\n\nlet createCompletionProvider (getService:string -> CheckingService) = \n  { new languages.CompletionItemProvider with \n      member this.triggerCharacters = Some(ResizeArray [| for i in 0 .. 255 -> string (char i) |])\n      member this.provideCompletionItems(model, position, token) =           \n        async {      \n          try    \n            let svc = getService (model.uri.toString())\n\n            let input = model.getValue(editor.EndOfLinePreference.LF, false)\n            Log.event(\"editor\", \"completions\", \"\", JsInterop.createObj [\"source\", box input; \"position\", box position])\n\n            let conv = LocationMapper(input)\n            let loc = conv.LineColToAbsolute(int position.lineNumber, int position.column)\n            \n            let! _, ents, _ = svc.TypeCheck(input)\n            let optMembers = \n              ents.Entities |> Seq.tryPick (fun (rng, ent) ->\n                match ent with \n                | { Kind = EntityKind.Member({ Type = Some t }, { Kind = EntityKind.MemberName(n) }) } \n                      when loc >= rng.Start && loc <= rng.End + 1 -> \n                    Log.trace(\"completions\", \"Antecedant at current location (member '%s'): %O\", n.Name, t)\n                    match t with\n                    | Type.Object obj -> Some(n.Name, rng, obj.Members)\n                    | _ -> None\n                | { Kind = EntityKind.Member({ Type = Some t }, { Kind = EntityKind.MemberName(n) }) } ->\n                    Log.trace(\"completions\", \"Ignoring '%s' at location %s-%s (current=%s)\", n.Name, rng.Start, rng.End, loc)\n                    None\n                | _ -> None)\n\n            let convertRange (rng:TheGamma.Range) = \n              let sl, sc = conv.AbsoluteToLineCol(rng.Start)\n              let el, ec = conv.AbsoluteToLineCol(rng.End)\n              let res = JsInterop.createEmpty<IRange>\n              res.startColumn <- float sc\n              res.startLineNumber <- float sl\n              res.endColumn <- float ec + 1.0\n              res.endLineNumber <- float el\n              res\n\n            match optMembers with \n            | None -> \n                Log.trace(\"completions\", \"no members at %s\", loc)\n                return ResizeArray []\n            | Some (currentName, nameRange, members) -> \n                let nameRange = convertRange nameRange\n                Log.trace(\"completions\", \"providing %s members at %O\", members.Length, nameRange)\n\n                let members = members |> Array.filter (fun m ->\n                  match Ast.pickMetaByType \"http://schema.thegamma.net\" \"CompletionItem\" m.Metadata with\n                  | Some item -> not (getProperty item \"hidden\")\n                  | _ -> true)\n\n                let completion =\n                  [ for m in members ->\n                      let ci = JsInterop.createEmpty<languages.CompletionItem>\n                      let n = m.Name\n                      let k = \n                        match m.Type with \n                        | Type.Method _ -> languages.CompletionItemKind.Method \n                        | _ -> languages.CompletionItemKind.Property\n                      ci.kind <- k\n                      ci.label <- n\n                      ci.insertText <- Some(Ast.escapeIdent n)\n                      // We set the current text in the range as 'filterText' so Monaco \n                      // does not filter things out when Ctrl+Space is typed (trick!)\n                      ci.filterText <- Some(Ast.escapeIdent currentName + n) \n                      match m.Type with\n                      | Type.Method(arguments=args) -> \n                          let acc, l = \n                            [ for ma in args -> (if ma.Optional then \"?\" else \"\") + ma.Name ] \n                            |> Seq.fold (fun (acc, l:string) s ->\n                                if l.Length > 100 then (l::acc, s)\n                                else (acc, if l = \"\" then s else l+\",\"+s)) ([], \"\")\n                          let args = l::acc |> List.rev |> String.concat \",\\n\"\n                          ci.documentation <- Some(\"(\" + args + \")\")\n                      | _ -> ()\n\n                      let eo = JsInterop.createEmpty<editor.ISingleEditOperation>\n                      eo.text <- Ast.escapeIdent n\n                      eo.range <- nameRange\n                      ci.textEdit <- Some eo\n                      ci ] \n                Log.trace(\"completions\", \"returning %O\", Array.ofSeq completion)\n                return ResizeArray(completion)\n            with e ->\n              Log.exn(\"completions\", \"completions failed %O\", e)\n              return ResizeArray() } |> Async.StartAsPromise |> Fable.Core.U4.Case2\n\n      member this.resolveCompletionItem(item, token) = Fable.Core.U2.Case1 item }\n\nlet createdEditors = System.Collections.Generic.Dictionary<string, CheckingService>()\nlet getService uri = createdEditors.[uri]\n\nlet setupMonacoServices () = \n  let lang = JsInterop.createEmpty<languages.ILanguageExtensionPoint>\n  lang.id <- \"thegamma\"\n  languages.Globals.register(lang)\n  languages.Globals.setTokensProvider(\"thegamma\", tokensProvider) |> ignore\n  languages.Globals.registerCompletionItemProvider(\"thegamma\", createCompletionProvider getService) |> ignore\n\nlet createMonacoEditor id code svc customize = \n  if createdEditors.Count = 0 then setupMonacoServices ()\n  let services = JsInterop.createEmpty<editor.IEditorOverrideServices>\n  let options = JsInterop.createEmpty<editor.IEditorConstructionOptions>\n  let scroll = JsInterop.createEmpty<editor.IEditorScrollbarOptions>\n  scroll.vertical <- Some \"none\"\n  scroll.horizontal <- Some \"auto\"\n  options.scrollbar <- Some scroll\n  options.value <- Some code\n  options.language <- Some \"thegamma\"\n  options.lineNumbersMinChars <- Some 3.0\n  options.contextmenu <- Some false\n  options.scrollBeyondLastLine <- Some false\n  options.overviewRulerLanes <- Some 0.0\n  customize options\n  let ed = editor.Globals.create(document.getElementById(id), options, services)\n  createdEditors.Add(ed.getModel().uri.toString(), svc)\n  ed","﻿module TheGamma.Main\n\nopen Fable.Core\nopen Fable.Core.Extensions\nopen Fable.Import\nopen Fable.Helpers\nopen Fable.Import.Browser\n\nopen TheGamma\nopen TheGamma.Ast\nopen TheGamma.Html\nopen TheGamma.Common\nopen TheGamma.TypeChecker\nopen TheGamma.Services\nopen TheGamma.TypeProviders \nopen TheGamma.Live.Common\n\nmodule FsOption = Microsoft.FSharp.Core.Option\n\n// ------------------------------------------------------------------------------------------------\n// Global provided types\n// ------------------------------------------------------------------------------------------------\n\nlet buildGlobalsTable provideTypes = Async.StartAsNamedFuture \"buildGlobalsTable\" <| async {\n  // We need to pass the lookup function to the code that provides types\n  // (because the providers may need to lookup named types), so we define\n  // the map as mutable and fill it later.\n  let mutable named = Map.empty\n  let lookupNamed n = \n    match named.TryFind(n) with\n    | Some(r) -> r\n    | None -> \n        Log.error(\"typechecker\", \"Could not find named type '%s'\", n)\n        failwith (sprintf \"Could not find named type '%s'\" n)\n\n  let! provided = provideTypes lookupNamed\n  let allTypes = \n    [ // Pretend we support these - the names appear in the F# provided types\n      // and if the functions are not actually used, providing Any type works \n      yield TypeProviders.NamedType(\"value\", Type.Any)\n      yield TypeProviders.NamedType(\"object\", Type.Any)\n      yield TypeProviders.NamedType(\"seq\", Type.Any) \n      yield TypeProviders.NamedType(\"async\", Type.Any) \n      yield! provided ]\n\n  // Build lookup table from named types and\n  // list of global entities (provided global values)\n  named <- \n    allTypes\n    |> Seq.choose (function TypeProviders.NamedType(s, t) -> Some(s, t) | _ -> None)\n    |> Map.ofSeq\n  let globalEntities = allTypes |> List.choose (function \n    | TypeProviders.GlobalValue(n, m, e, t) -> \n        Some(Interpreter.globalEntity n m t (Some e))\n    | _ -> None)\n    (*\n  let test = Interpreter.globalEntity \"magic\" [] (Type.Method(fun vs ->\n    { new ObjectType with\n        member x.Members = \n          [| for i in 1 .. unbox (List.item 1 vs) -> \n               { Name = unbox (List.head vs) + \" \" + string i; Type = Type.Primitive(PrimitiveType.String);\n                 Metadata = []; Emitter = { Emit = fun _ -> Babel.StringLiteral(unbox (List.head vs), None) } } |]\n        member x.TypeEquals _ = false } |> Type.Object |> Some )) (Some(Babel.StringLiteral(\"test\", None)))\n        *)\n  return globalEntities } \n\nlet rec resolveProvider lookup ignoreFilter kind endpoint = \n  match kind with\n  | \"rest\" ->\n      match TypeProviders.RestProvider.provideRestType lookup (resolveProvider lookup ignoreFilter) \"anonymous\" endpoint \"\" with\n      | ProvidedType.GlobalValue(_, _, e, t) -> t, { Emit = fun _ -> e }\n      | _ -> failwith \"resolveProvider: Expected global value\"\n  | \"pivot\" ->\n      let pivotType = async {\n        let! typ = TypeProviders.Pivot.providePivotType endpoint ignoreFilter \"anonymous\" lookup\n        match typ with \n        | ProvidedType.GlobalValue(_, _, _, t) -> return t \n        | _ -> return failwith \"resolveProvider: Expected global value\" }\n      Type.Delayed(Async.StartAsNamedFuture (\"pivotType:\" + endpoint) pivotType),\n      { Emit = fun _ -> TypeProviders.Pivot.makePivotExpression endpoint }\n  | _ ->\n    Log.error(\"providers\", \"Cannot resolve provider '%s' (%s)\", kind, endpoint) \n    failwith \"resolveProvider: Cannot resolve type provider\"\n\n// ------------------------------------------------------------------------------------------------\n// JavaScript API\n// ------------------------------------------------------------------------------------------------\n\ntype TheGammaProviders = \n  { globals : Future<Entity list> }\n\ntype TheGammaContext =\n  { checkingService : CheckingService \n    providers : TheGammaProviders }\n\nlet callShowMethod outputId (cmd:Node<_>) = \n  match cmd.Node with\n  | Command.Expr({ Entity = Some { Type = Some typ } } as inst) ->\n      match typ with\n      | Type.Object obj ->\n          let showTyp = obj.Members |> Array.tryPick (function \n            | { Name = \"show\"; Type = typ & Type.Method([{ Type = Type.Primitive PrimitiveType.String }], _) } -> Some typ\n            | _ -> None)\n          match showTyp with \n          | Some showTyp ->\n            let rng = { Range.Start = cmd.Range.End; End = cmd.Range.End }\n            let outExpr = Ast.node rng (Expr.String(outputId))\n            let args = [{ Argument.Name = None; Argument.Value = outExpr }]\n            let showMember = Expr.Member(inst, Ast.node rng (Expr.Variable(Ast.node rng { Name = \"show\" }))) |> Ast.node rng\n            let showEntity = \n              { Kind = EntityKind.Root; Symbol = createSymbol(); Value = None\n                Meta = []; Type = Some showTyp; Errors = [] }\n            showMember.Entity <- Some showEntity\n            let expr = Ast.node rng (Expr.Call(showMember, Ast.node rng args))\n            Ast.node cmd.Range (Command.Expr(expr))\n          | _ -> cmd\n      | _ -> cmd\n  | _ -> cmd\n\n[<Emit(\"eval($0)\")>]\nlet eval (s:string) : obj = failwith \"eval\"\n\nlet evaluate ctx code outputId = async {\n  // Type check & insert 'show' calls if 'outputId' is given\n  let! _, _, prog = ctx.checkingService.TypeCheck(code)\n  let newBody = \n    match outputId with\n    | Some outputId -> prog.Body.Node |> List.map (callShowMethod outputId)\n    | _ -> prog.Body.Node \n  let prog = { prog with Body = { prog.Body with Node = newBody } }\n  let! code = CodeGenerator.compile ctx.providers.globals code prog \n\n  // Get fable to reference everything\n  let s = TheGamma.Series.series<int, int>.create(async { return [||] }, \"\", \"\", \"\") \n  TheGamma.TypeProvidersRuntime.RuntimeContext(\"lol\", \"\", \"troll\") |> ignore\n  TypeProvidersRuntime.trimLeft |> ignore\n  TheGamma.GoogleCharts.chart.bar |> ignore\n  TheGamma.TypeProvidersRuntime.convertTupleSequence |> ignore\n  TheGamma.TypeProvidersRuntime.convertSequence |> ignore\n  TheGamma.table<int, int>.create(s) |> ignore\n  TheGamma.General.date.now() |> ignore\n  TheGamma.Series.series<int, int>.values([| 1 |]) |> ignore\n  TheGamma.placeholder.create(\"\") |> ignore\n  TheGamma.Interactive.youguess.line |> ignore\n  Log.trace(\"interpreter\", \"Main evaluating: %O\", code)\n  return eval code }\n\ntype provider = string -> (string -> Type) -> Async<list<ProvidedType>>\n\nlet previews = \n  [ Live.Pivot.preview |> unbox<LivePreview<CustomLiveState, CustomLiveEvent>> \n    Live.Showable.preview |> unbox<LivePreview<CustomLiveState, CustomLiveEvent>> ]\n\ntype editorOptions =\n  { width : float option\n    height : float option\n    maxHeight : float option\n    autoHeight : bool option\n    enablePreview : bool option\n    monacoOptions : (monaco.editor.IEditorConstructionOptions -> unit) option }\n\ntype error = \n  { number : int\n    message : string\n    startLine : int\n    startColumn : int\n    endLine : int\n    endColumn : int }\n\nlet defaultEditorOptions = \n  { width = None; height = None; maxHeight = None; autoHeight = None; monacoOptions = None; enablePreview = None }\n\ntype thenable<'R>(work:Async<'R>) = \n  let mutable resCell = Choice1Of3()\n  let mutable trigger = id\n  do async { \n    try \n      let! res = work\n      resCell <- Choice2Of3 res\n      trigger ()\n    with e ->\n      resCell <- Choice3Of3 e \n      trigger () } |> Async.StartImmediate\n  member x.``then``(onValue, ?onError) = \n    trigger <- fun () ->\n      match resCell with \n      | Choice1Of3 () -> ()\n      | Choice2Of3 res -> trigger <- id; onValue res\n      | Choice3Of3 err -> trigger <- id; if onError.IsSome then onError.Value err\n    trigger ()\n\nlet rec serializeType typ = \n  match typ with\n  | Type.Any -> box \"any\"\n  | Type.Delayed(_) -> box \"delayed\"\n  | Type.Primitive(PrimitiveType.Unit) -> box \"unit\"\n  | Type.Primitive(PrimitiveType.Bool) -> box \"bool\"\n  | Type.Primitive(PrimitiveType.Date) -> box \"date\"\n  | Type.Primitive(PrimitiveType.Number) -> box \"number\"\n  | Type.Primitive(PrimitiveType.String) -> box \"string\"\n  | Type.Method(args, res) -> \n      [ \"kind\", box \"function\"\n        \"arguments\", args |> List.map (fun ma -> [| box ma.Name; box ma.Optional; box ma.Static; serializeType ma.Type |]) |> Array.ofList |> box\n        \"result\", serializeType (res [for ma in args  -> ma.Type, None]).Value ] |> JsInterop.createObj \n  | Type.List(t) -> \n      [ \"kind\", box \"array\"\n        \"type\", serializeType t ] |> JsInterop.createObj\n  | Type.Object(obj) -> \n      [ yield \"kind\", box \"object\"\n        match obj with\n        | :? FSharpProvider.GenericType as gt -> \n            yield \"generics\", gt.TypeArguments |> Seq.map serializeType |> Array.ofSeq |> box\n        | _ -> ()\n        yield \"members\", obj.Members |> Array.map (fun m -> m.Name) |> box ] \n      |> JsInterop.createObj\n\nlet rec serializeEntity (rng:Range option) (ent:Entity) =\n  let kind, extras = \n    match ent.Kind with\n    | EntityKind.Root -> \"root\", []\n    | EntityKind.Program _ -> \"program\", []\n    | EntityKind.RunCommand _ -> \"do\", []\n    | EntityKind.LetCommand _ -> \"let\", []\n    | EntityKind.Operator _ -> \"operator\", []\n    | EntityKind.List _ -> \"list\", []\n    | EntityKind.Constant _ -> \"constant\", []\n    | EntityKind.Function _ -> \"function\", []\n    | EntityKind.GlobalValue _ -> \"global\", []\n    | EntityKind.Variable _ -> \"variable\", []\n    | EntityKind.Binding _ -> \"binding\", []\n    | EntityKind.ArgumentList _ -> \"args\", []\n    | EntityKind.CallSite _ -> \"callsite\", []\n    | EntityKind.Member _ -> \"member\", []\n    | EntityKind.MemberAccess _ -> \"access\", []\n    | EntityKind.MemberName(n) -> \"name\", [\"name\", box n.Name]\n    | EntityKind.NamedParam(n, _) -> \"param\", [\"name\", box n.Name]\n    | EntityKind.Placeholder(n, _) -> \"placeholder\", [\"name\", box n.Name]\n    | EntityKind.Call _ -> \"call\", []\n  [ yield \"kind\", box kind\n    if rng.IsSome then yield \"range\", JsInterop.createObj [ \"start\", box rng.Value.Start; \"end\", box rng.Value.End ]\n    yield \"getChildren\", box (fun () -> ent.Antecedents |> List.toArray |> Array.map (serializeEntity None))\n    yield \"type\", match ent.Type with Some t -> serializeType t | _ -> box \"unknown\" \n    yield! extras ]\n  |> JsInterop.createObj\n\ntype checkingResult(_wellTyped:bool, _bindingResult:Binder.BindingResult, _program:Program) = \n  member x.wellTyped = _wellTyped\n  member x.getEntities() = _bindingResult.Entities |> Array.map (fun (rng, ent) ->\n    serializeEntity (Some rng) ent)\n\ntype editor(ed:monaco.editor.ICodeEditor) = \n  member x.getMonacoEditor() = ed\n  member x.getValue() = \n    ed.getModel().getValue(monaco.editor.EndOfLinePreference.LF, false)\n  member x.setValue(text) = \n    ed.getModel().setValue(text)\n\ntype gamma(ctx:TheGammaContext) =\n  static member createContext(providers:TheGammaProviders) =\n    // Initialize and return services\n    let checkingSvc = CheckingService(\"\", providers.globals)\n    gamma({ checkingService = checkingSvc; providers = providers })\n\n  member x.check(code) = \n    async {\n      let! res = ctx.checkingService.TypeCheck(code)\n      return checkingResult(res) } |> thenable\n\n  member x.evaluate(code, ?outputId) = \n    async {\n      try return! evaluate ctx code outputId\n      with e ->\n        Log.exn(\"api\", \"Evaluating code '%O' failed with error '%O'.\", code, e)\n        return! raise e } |> thenable\n\n  member x.errorsReported(f) = \n    ctx.checkingService.ErrorsReported.Add(fun (source, errors) ->\n      errors \n      |> Array.sortBy (fun e -> e.Range.Start)\n      |> Array.map (fun e -> \n          { number = e.Number; message = e.Message; \n            startLine = e.Range.Start.Line; startColumn = e.Range.Start.Column;\n            endLine = e.Range.End.Line; endColumn = e.Range.End.Column }) \n      |> f )\n\n  member x.createBlocks(id) = \n    Blocks.createBlockEditor ctx.checkingService ctx.providers.globals id\n\n  member x.createEditor(id, source, options) =\n\n    // Create editor using the size of the #id element, or size given by the user.\n    // Store 'lineHeight', so that we can calculate size of editor when auto-sizing.\n    let mutable lineHeight = 20.0\n    let options = defaultArg options defaultEditorOptions \n    let el = document.getElementById(id)\n    let width = defaultArg options.width el.clientWidth\n    let height = defaultArg options.height el.clientHeight\n    let maxHeight = defaultArg options.maxHeight (float System.Int32.MaxValue)\n    let ed = Monaco.createMonacoEditor id source ctx.checkingService (fun opts ->\n      opts.fontSize <- Some 15.0\n      opts.lineHeight <- Some 20.0\n      (defaultArg options.monacoOptions ignore) opts\n      match opts.lineHeight with Some n -> lineHeight <- n | _ -> () )\n\n    let dim = JsInterop.createEmpty<monaco.editor.IDimension>\n    dim.width <- width\n    dim.height <- height\n    ed.layout(dim)\n\n    let previewService = \n      if defaultArg options.enablePreview true then\n        Some(PreviewService(ctx.checkingService, ctx.providers.globals, ed, previews))\n      else None\n\n    let mutable lastHeight = -1.0\n    let autosizeEditor () =\n      let text = ed.getModel().getValue(monaco.editor.EndOfLinePreference.LF, false)\n      let lines = 1.0 + float (text.Split('\\n').Length)\n      let zoneHeight = match previewService with Some ps -> ps.ZoneHeight | _ -> 0.0\n      let height = min maxHeight (max 200.0 (lines * 20.0 + zoneHeight))\n      if height <> lastHeight then\n        lastHeight <- height\n        let dim = JsInterop.createEmpty<monaco.editor.IDimension>\n        dim.width <- width\n        dim.height <- height\n        ed.layout(dim)\n        el.style.height <- string dim.height + \"px\" \n        el.style.width <- string dim.width + \"px\" \n\n    if options.autoHeight = Some true then\n      ed.getModel().onDidChangeContent(fun _ -> autosizeEditor ()) |> ignore     \n      match previewService with\n      | Some ps -> ps.ZoneSizeChanged.Add(fun _ -> autosizeEditor ())\n      | _ -> ()\n      autosizeEditor ()\n\n    editor(ed)\n  \ntype providers =\n  static member createProviders(providers) =\n    // Initialize type providers specified as key/values of the given object\n    let globals = buildGlobalsTable (fun lookup -> async {\n      let providers = JsHelpers.properties(providers) |> Array.map (fun kv ->\n        (unbox<provider> kv.value) kv.key lookup)\n      let! providers = Async.Parallel providers\n      return Seq.concat providers })\n    { globals = globals }    \n\n  static member rest(url, ?cookies, ?ignoreFilter) : provider = \n    (fun name lookup -> async {\n      let provider = \n        TypeProviders.RestProvider.provideRestType \n          lookup (resolveProvider lookup (defaultArg ignoreFilter false)) name url (defaultArg cookies \"\")\n      return [ provider ] })\n\n  static member library(url) : provider = \n    (fun _ lookup ->\n      TypeProviders.FSharpProvider.provideFSharpTypes lookup url)\n\n  static member pivot(url, ?ignoreFilter) : provider = \n    (fun name lookup -> async {\n      let! t = TypeProviders.Pivot.providePivotType url (defaultArg ignoreFilter false) name lookup \n      return [t] })","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n","var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject');\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n","// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer');\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n","var toInteger = require('./_to-integer');\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject');\nvar toLength = require('./_to-length');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n","var global = require('./_global');\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function (key) {\n  return store[key] || (store[key] = {});\n};\n","var id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n","var shared = require('./_shared')('keys');\nvar uid = require('./_uid');\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n","var has = require('./_has');\nvar toIObject = require('./_to-iobject');\nvar arrayIndexOf = require('./_array-includes')(false);\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n","// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = require('./_object-keys-internal');\nvar enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n","var core = module.exports = { version: '2.5.1' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n","module.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n","module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n","var isObject = require('./_is-object');\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n","module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n","var isObject = require('./_is-object');\nvar document = require('./_global').document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n","module.exports = !require('./_descriptors') && !require('./_fails')(function () {\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n","var anObject = require('./_an-object');\nvar IE8_DOM_DEFINE = require('./_ie8-dom-define');\nvar toPrimitive = require('./_to-primitive');\nvar dP = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n","module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n","var dP = require('./_object-dp');\nvar createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n","var global = require('./_global');\nvar core = require('./_core');\nvar ctx = require('./_ctx');\nvar hide = require('./_hide');\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var IS_WRAP = type & $export.W;\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE];\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];\n  var key, own, out;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if (own && key in exports) continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function (C) {\n      var F = function (a, b, c) {\n        if (this instanceof C) {\n          switch (arguments.length) {\n            case 0: return new C();\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if (IS_PROTO) {\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n","// most Object methods by ES6 should accept primitives\nvar $export = require('./_export');\nvar core = require('./_core');\nvar fails = require('./_fails');\nmodule.exports = function (KEY, exec) {\n  var fn = (core.Object || {})[KEY] || Object[KEY];\n  var exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);\n};\n","// 19.1.2.14 Object.keys(O)\nvar toObject = require('./_to-object');\nvar $keys = require('./_object-keys');\n\nrequire('./_object-sap')('keys', function () {\n  return function keys(it) {\n    return $keys(toObject(it));\n  };\n});\n","require('../../modules/es6.object.keys');\nmodule.exports = require('../../modules/_core').Object.keys;\n","module.exports = { \"default\": require(\"core-js/library/fn/object/keys\"), __esModule: true };","var toInteger = require('./_to-integer');\nvar defined = require('./_defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function (TO_STRING) {\n  return function (that, pos) {\n    var s = String(defined(that));\n    var i = toInteger(pos);\n    var l = s.length;\n    var a, b;\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n","module.exports = true;\n","module.exports = require('./_hide');\n","var dP = require('./_object-dp');\nvar anObject = require('./_an-object');\nvar getKeys = require('./_object-keys');\n\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n","var document = require('./_global').document;\nmodule.exports = document && document.documentElement;\n","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = require('./_an-object');\nvar dPs = require('./_object-dps');\nvar enumBugKeys = require('./_enum-bug-keys');\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = require('./_dom-create')('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  require('./_html').appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n","var store = require('./_shared')('wks');\nvar uid = require('./_uid');\nvar Symbol = require('./_global').Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n","var def = require('./_object-dp').f;\nvar has = require('./_has');\nvar TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n","'use strict';\nvar create = require('./_object-create');\nvar descriptor = require('./_property-desc');\nvar setToStringTag = require('./_set-to-string-tag');\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });\n\nmodule.exports = function (Constructor, NAME, next) {\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n","// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has = require('./_has');\nvar toObject = require('./_to-object');\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n","'use strict';\nvar LIBRARY = require('./_library');\nvar $export = require('./_export');\nvar redefine = require('./_redefine');\nvar hide = require('./_hide');\nvar has = require('./_has');\nvar Iterators = require('./_iterators');\nvar $iterCreate = require('./_iter-create');\nvar setToStringTag = require('./_set-to-string-tag');\nvar getPrototypeOf = require('./_object-gpo');\nvar ITERATOR = require('./_wks')('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = $native || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n","'use strict';\nvar $at = require('./_string-at')(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\nrequire('./_iter-define')(String, 'String', function (iterated) {\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var index = this._i;\n  var point;\n  if (index >= O.length) return { value: undefined, done: true };\n  point = $at(O, index);\n  this._i += point.length;\n  return { value: point, done: false };\n});\n","// call something on iterator step with safe closing on error\nvar anObject = require('./_an-object');\nmodule.exports = function (iterator, fn, value, entries) {\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch (e) {\n    var ret = iterator['return'];\n    if (ret !== undefined) anObject(ret.call(iterator));\n    throw e;\n  }\n};\n","// check on default Array iterator\nvar Iterators = require('./_iterators');\nvar ITERATOR = require('./_wks')('iterator');\nvar ArrayProto = Array.prototype;\n\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n","'use strict';\nvar $defineProperty = require('./_object-dp');\nvar createDesc = require('./_property-desc');\n\nmodule.exports = function (object, index, value) {\n  if (index in object) $defineProperty.f(object, index, createDesc(0, value));\n  else object[index] = value;\n};\n","// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = require('./_cof');\nvar TAG = require('./_wks')('toStringTag');\n// ES3 wrong here\nvar ARG = cof(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (e) { /* empty */ }\n};\n\nmodule.exports = function (it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n","var classof = require('./_classof');\nvar ITERATOR = require('./_wks')('iterator');\nvar Iterators = require('./_iterators');\nmodule.exports = require('./_core').getIteratorMethod = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n","var ITERATOR = require('./_wks')('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function () { SAFE_CLOSING = true; };\n  // eslint-disable-next-line no-throw-literal\n  Array.from(riter, function () { throw 2; });\n} catch (e) { /* empty */ }\n\nmodule.exports = function (exec, skipClosing) {\n  if (!skipClosing && !SAFE_CLOSING) return false;\n  var safe = false;\n  try {\n    var arr = [7];\n    var iter = arr[ITERATOR]();\n    iter.next = function () { return { done: safe = true }; };\n    arr[ITERATOR] = function () { return iter; };\n    exec(arr);\n  } catch (e) { /* empty */ }\n  return safe;\n};\n","'use strict';\nvar ctx = require('./_ctx');\nvar $export = require('./_export');\nvar toObject = require('./_to-object');\nvar call = require('./_iter-call');\nvar isArrayIter = require('./_is-array-iter');\nvar toLength = require('./_to-length');\nvar createProperty = require('./_create-property');\nvar getIterFn = require('./core.get-iterator-method');\n\n$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n    var O = toObject(arrayLike);\n    var C = typeof this == 'function' ? this : Array;\n    var aLen = arguments.length;\n    var mapfn = aLen > 1 ? arguments[1] : undefined;\n    var mapping = mapfn !== undefined;\n    var index = 0;\n    var iterFn = getIterFn(O);\n    var length, result, step, iterator;\n    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {\n      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {\n        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);\n      }\n    } else {\n      length = toLength(O.length);\n      for (result = new C(length); length > index; index++) {\n        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n","require('../../modules/es6.string.iterator');\nrequire('../../modules/es6.array.from');\nmodule.exports = require('../../modules/_core').Array.from;\n","module.exports = { \"default\": require(\"core-js/library/fn/array/from\"), __esModule: true };","var META = require('./_uid')('meta');\nvar isObject = require('./_is-object');\nvar has = require('./_has');\nvar setDesc = require('./_object-dp').f;\nvar id = 0;\nvar isExtensible = Object.isExtensible || function () {\n  return true;\n};\nvar FREEZE = !require('./_fails')(function () {\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function (it) {\n  setDesc(it, META, { value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  } });\n};\nvar fastKey = function (it, create) {\n  // return primitive with prefix\n  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return 'F';\n    // not necessary to add metadata\n    if (!create) return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function (it, create) {\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return true;\n    // not necessary to add metadata\n    if (!create) return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function (it) {\n  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY: META,\n  NEED: false,\n  fastKey: fastKey,\n  getWeak: getWeak,\n  onFreeze: onFreeze\n};\n","exports.f = require('./_wks');\n","var global = require('./_global');\nvar core = require('./_core');\nvar LIBRARY = require('./_library');\nvar wksExt = require('./_wks-ext');\nvar defineProperty = require('./_object-dp').f;\nmodule.exports = function (name) {\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });\n};\n","exports.f = Object.getOwnPropertySymbols;\n","exports.f = {}.propertyIsEnumerable;\n","// all enumerable object keys, includes symbols\nvar getKeys = require('./_object-keys');\nvar gOPS = require('./_object-gops');\nvar pIE = require('./_object-pie');\nmodule.exports = function (it) {\n  var result = getKeys(it);\n  var getSymbols = gOPS.f;\n  if (getSymbols) {\n    var symbols = getSymbols(it);\n    var isEnum = pIE.f;\n    var i = 0;\n    var key;\n    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);\n  } return result;\n};\n","// 7.2.2 IsArray(argument)\nvar cof = require('./_cof');\nmodule.exports = Array.isArray || function isArray(arg) {\n  return cof(arg) == 'Array';\n};\n","// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys = require('./_object-keys-internal');\nvar hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return $keys(O, hiddenKeys);\n};\n","// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = require('./_to-iobject');\nvar gOPN = require('./_object-gopn').f;\nvar toString = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function (it) {\n  try {\n    return gOPN(it);\n  } catch (e) {\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.f = function getOwnPropertyNames(it) {\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n};\n","var pIE = require('./_object-pie');\nvar createDesc = require('./_property-desc');\nvar toIObject = require('./_to-iobject');\nvar toPrimitive = require('./_to-primitive');\nvar has = require('./_has');\nvar IE8_DOM_DEFINE = require('./_ie8-dom-define');\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nexports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return gOPD(O, P);\n  } catch (e) { /* empty */ }\n  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\n};\n","'use strict';\n// ECMAScript 6 symbols shim\nvar global = require('./_global');\nvar has = require('./_has');\nvar DESCRIPTORS = require('./_descriptors');\nvar $export = require('./_export');\nvar redefine = require('./_redefine');\nvar META = require('./_meta').KEY;\nvar $fails = require('./_fails');\nvar shared = require('./_shared');\nvar setToStringTag = require('./_set-to-string-tag');\nvar uid = require('./_uid');\nvar wks = require('./_wks');\nvar wksExt = require('./_wks-ext');\nvar wksDefine = require('./_wks-define');\nvar enumKeys = require('./_enum-keys');\nvar isArray = require('./_is-array');\nvar anObject = require('./_an-object');\nvar toIObject = require('./_to-iobject');\nvar toPrimitive = require('./_to-primitive');\nvar createDesc = require('./_property-desc');\nvar _create = require('./_object-create');\nvar gOPNExt = require('./_object-gopn-ext');\nvar $GOPD = require('./_object-gopd');\nvar $DP = require('./_object-dp');\nvar $keys = require('./_object-keys');\nvar gOPD = $GOPD.f;\nvar dP = $DP.f;\nvar gOPN = gOPNExt.f;\nvar $Symbol = global.Symbol;\nvar $JSON = global.JSON;\nvar _stringify = $JSON && $JSON.stringify;\nvar PROTOTYPE = 'prototype';\nvar HIDDEN = wks('_hidden');\nvar TO_PRIMITIVE = wks('toPrimitive');\nvar isEnum = {}.propertyIsEnumerable;\nvar SymbolRegistry = shared('symbol-registry');\nvar AllSymbols = shared('symbols');\nvar OPSymbols = shared('op-symbols');\nvar ObjectProto = Object[PROTOTYPE];\nvar USE_NATIVE = typeof $Symbol == 'function';\nvar QObject = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function () {\n  return _create(dP({}, 'a', {\n    get: function () { return dP(this, 'a', { value: 7 }).a; }\n  })).a != 7;\n}) ? function (it, key, D) {\n  var protoDesc = gOPD(ObjectProto, key);\n  if (protoDesc) delete ObjectProto[key];\n  dP(it, key, D);\n  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);\n} : dP;\n\nvar wrap = function (tag) {\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D) {\n  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);\n  anObject(it);\n  key = toPrimitive(key, true);\n  anObject(D);\n  if (has(AllSymbols, key)) {\n    if (!D.enumerable) {\n      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;\n      D = _create(D, { enumerable: createDesc(0, false) });\n    } return setSymbolDesc(it, key, D);\n  } return dP(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P) {\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P));\n  var i = 0;\n  var l = keys.length;\n  var key;\n  while (l > i) $defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P) {\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key) {\n  var E = isEnum.call(this, key = toPrimitive(key, true));\n  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {\n  it = toIObject(it);\n  key = toPrimitive(key, true);\n  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;\n  var D = gOPD(it, key);\n  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it) {\n  var names = gOPN(toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it) {\n  var IS_OP = it === ObjectProto;\n  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif (!USE_NATIVE) {\n  $Symbol = function Symbol() {\n    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function (value) {\n      if (this === ObjectProto) $set.call(OPSymbols, value);\n      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    };\n    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });\n    return wrap(tag);\n  };\n  redefine($Symbol[PROTOTYPE], 'toString', function toString() {\n    return this._k;\n  });\n\n  $GOPD.f = $getOwnPropertyDescriptor;\n  $DP.f = $defineProperty;\n  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;\n  require('./_object-pie').f = $propertyIsEnumerable;\n  require('./_object-gops').f = $getOwnPropertySymbols;\n\n  if (DESCRIPTORS && !require('./_library')) {\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  wksExt.f = function (name) {\n    return wrap(wks(name));\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });\n\nfor (var es6Symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);\n\nfor (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);\n\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function (key) {\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(sym) {\n    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');\n    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;\n  },\n  useSetter: function () { setter = true; },\n  useSimple: function () { setter = false; }\n});\n\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it) {\n    if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n    var args = [it];\n    var i = 1;\n    var replacer, $replacer;\n    while (arguments.length > i) args.push(arguments[i++]);\n    replacer = args[1];\n    if (typeof replacer == 'function') $replacer = replacer;\n    if ($replacer || !isArray(replacer)) replacer = function (key, value) {\n      if ($replacer) value = $replacer.call(this, key, value);\n      if (!isSymbol(value)) return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);\n","require('./_wks-define')('asyncIterator');\n","require('./_wks-define')('observable');\n","require('../../modules/es6.symbol');\nrequire('../../modules/es6.object.to-string');\nrequire('../../modules/es7.symbol.async-iterator');\nrequire('../../modules/es7.symbol.observable');\nmodule.exports = require('../../modules/_core').Symbol;\n","module.exports = { \"default\": require(\"core-js/library/fn/symbol\"), __esModule: true };","\"use strict\";\n\nexports.__esModule = true;\n\nexports.default = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};","var $export = require('./_export');\n// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\n$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });\n","require('../../modules/es6.object.define-property');\nvar $Object = require('../../modules/_core').Object;\nmodule.exports = function defineProperty(it, key, desc) {\n  return $Object.defineProperty(it, key, desc);\n};\n","module.exports = { \"default\": require(\"core-js/library/fn/object/define-property\"), __esModule: true };","\"use strict\";\n\nexports.__esModule = true;\n\nvar _defineProperty = require(\"../core-js/object/define-property\");\n\nvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      (0, _defineProperty2.default)(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();","module.exports = function () { /* empty */ };\n","module.exports = function (done, value) {\n  return { value: value, done: !!done };\n};\n","'use strict';\nvar addToUnscopables = require('./_add-to-unscopables');\nvar step = require('./_iter-step');\nvar Iterators = require('./_iterators');\nvar toIObject = require('./_to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return step(1);\n  }\n  if (kind == 'keys') return step(0, index);\n  if (kind == 'values') return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n","require('./es6.array.iterator');\nvar global = require('./_global');\nvar hide = require('./_hide');\nvar Iterators = require('./_iterators');\nvar TO_STRING_TAG = require('./_wks')('toStringTag');\n\nvar DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +\n  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +\n  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +\n  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +\n  'TextTrackList,TouchList').split(',');\n\nfor (var i = 0; i < DOMIterables.length; i++) {\n  var NAME = DOMIterables[i];\n  var Collection = global[NAME];\n  var proto = Collection && Collection.prototype;\n  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n  Iterators[NAME] = Iterators.Array;\n}\n","require('../../modules/es6.string.iterator');\nrequire('../../modules/web.dom.iterable');\nmodule.exports = require('../../modules/_wks-ext').f('iterator');\n","module.exports = { \"default\": require(\"core-js/library/fn/symbol/iterator\"), __esModule: true };","\"use strict\";\n\nexports.__esModule = true;\n\nvar _iterator = require(\"../core-js/symbol/iterator\");\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _symbol = require(\"../core-js/symbol\");\n\nvar _symbol2 = _interopRequireDefault(_symbol);\n\nvar _typeof = typeof _symbol2.default === \"function\" && typeof _iterator2.default === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = typeof _symbol2.default === \"function\" && _typeof(_iterator2.default) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n} : function (obj) {\n  return obj && typeof _symbol2.default === \"function\" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj);\n};","var hide = require('./_hide');\nmodule.exports = function (target, src, safe) {\n  for (var key in src) {\n    if (safe && target[key]) target[key] = src[key];\n    else hide(target, key, src[key]);\n  } return target;\n};\n","module.exports = function (it, Constructor, name, forbiddenField) {\n  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n","var ctx = require('./_ctx');\nvar call = require('./_iter-call');\nvar isArrayIter = require('./_is-array-iter');\nvar anObject = require('./_an-object');\nvar toLength = require('./_to-length');\nvar getIterFn = require('./core.get-iterator-method');\nvar BREAK = {};\nvar RETURN = {};\nvar exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {\n  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);\n  var f = ctx(fn, that, entries ? 2 : 1);\n  var index = 0;\n  var length, step, iterator, result;\n  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {\n    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if (result === BREAK || result === RETURN) return result;\n  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {\n    result = call(iterator, f, step.value, entries);\n    if (result === BREAK || result === RETURN) return result;\n  }\n};\nexports.BREAK = BREAK;\nexports.RETURN = RETURN;\n","'use strict';\nvar global = require('./_global');\nvar core = require('./_core');\nvar dP = require('./_object-dp');\nvar DESCRIPTORS = require('./_descriptors');\nvar SPECIES = require('./_wks')('species');\n\nmodule.exports = function (KEY) {\n  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];\n  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {\n    configurable: true,\n    get: function () { return this; }\n  });\n};\n","var isObject = require('./_is-object');\nmodule.exports = function (it, TYPE) {\n  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');\n  return it;\n};\n","'use strict';\nvar dP = require('./_object-dp').f;\nvar create = require('./_object-create');\nvar redefineAll = require('./_redefine-all');\nvar ctx = require('./_ctx');\nvar anInstance = require('./_an-instance');\nvar forOf = require('./_for-of');\nvar $iterDefine = require('./_iter-define');\nvar step = require('./_iter-step');\nvar setSpecies = require('./_set-species');\nvar DESCRIPTORS = require('./_descriptors');\nvar fastKey = require('./_meta').fastKey;\nvar validate = require('./_validate-collection');\nvar SIZE = DESCRIPTORS ? '_s' : 'size';\n\nvar getEntry = function (that, key) {\n  // fast case\n  var index = fastKey(key);\n  var entry;\n  if (index !== 'F') return that._i[index];\n  // frozen object case\n  for (entry = that._f; entry; entry = entry.n) {\n    if (entry.k == key) return entry;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      anInstance(that, C, NAME, '_i');\n      that._t = NAME;         // collection type\n      that._i = create(null); // index\n      that._f = undefined;    // first entry\n      that._l = undefined;    // last entry\n      that[SIZE] = 0;         // size\n      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.1.3.1 Map.prototype.clear()\n      // 23.2.3.2 Set.prototype.clear()\n      clear: function clear() {\n        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {\n          entry.r = true;\n          if (entry.p) entry.p = entry.p.n = undefined;\n          delete data[entry.i];\n        }\n        that._f = that._l = undefined;\n        that[SIZE] = 0;\n      },\n      // 23.1.3.3 Map.prototype.delete(key)\n      // 23.2.3.4 Set.prototype.delete(value)\n      'delete': function (key) {\n        var that = validate(this, NAME);\n        var entry = getEntry(that, key);\n        if (entry) {\n          var next = entry.n;\n          var prev = entry.p;\n          delete that._i[entry.i];\n          entry.r = true;\n          if (prev) prev.n = next;\n          if (next) next.p = prev;\n          if (that._f == entry) that._f = next;\n          if (that._l == entry) that._l = prev;\n          that[SIZE]--;\n        } return !!entry;\n      },\n      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\n      forEach: function forEach(callbackfn /* , that = undefined */) {\n        validate(this, NAME);\n        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n        var entry;\n        while (entry = entry ? entry.n : this._f) {\n          f(entry.v, entry.k, this);\n          // revert to the last existing entry\n          while (entry && entry.r) entry = entry.p;\n        }\n      },\n      // 23.1.3.7 Map.prototype.has(key)\n      // 23.2.3.7 Set.prototype.has(value)\n      has: function has(key) {\n        return !!getEntry(validate(this, NAME), key);\n      }\n    });\n    if (DESCRIPTORS) dP(C.prototype, 'size', {\n      get: function () {\n        return validate(this, NAME)[SIZE];\n      }\n    });\n    return C;\n  },\n  def: function (that, key, value) {\n    var entry = getEntry(that, key);\n    var prev, index;\n    // change existing entry\n    if (entry) {\n      entry.v = value;\n    // create new entry\n    } else {\n      that._l = entry = {\n        i: index = fastKey(key, true), // <- index\n        k: key,                        // <- key\n        v: value,                      // <- value\n        p: prev = that._l,             // <- previous entry\n        n: undefined,                  // <- next entry\n        r: false                       // <- removed\n      };\n      if (!that._f) that._f = entry;\n      if (prev) prev.n = entry;\n      that[SIZE]++;\n      // add to index\n      if (index !== 'F') that._i[index] = entry;\n    } return that;\n  },\n  getEntry: getEntry,\n  setStrong: function (C, NAME, IS_MAP) {\n    // add .keys, .values, .entries, [@@iterator]\n    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n    $iterDefine(C, NAME, function (iterated, kind) {\n      this._t = validate(iterated, NAME); // target\n      this._k = kind;                     // kind\n      this._l = undefined;                // previous\n    }, function () {\n      var that = this;\n      var kind = that._k;\n      var entry = that._l;\n      // revert to the last existing entry\n      while (entry && entry.r) entry = entry.p;\n      // get next entry\n      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {\n        // or finish the iteration\n        that._t = undefined;\n        return step(1);\n      }\n      // return step by kind\n      if (kind == 'keys') return step(0, entry.k);\n      if (kind == 'values') return step(0, entry.v);\n      return step(0, [entry.k, entry.v]);\n    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);\n\n    // add [@@species], 23.1.2.2, 23.2.2.2\n    setSpecies(NAME);\n  }\n};\n","var isObject = require('./_is-object');\nvar isArray = require('./_is-array');\nvar SPECIES = require('./_wks')('species');\n\nmodule.exports = function (original) {\n  var C;\n  if (isArray(original)) {\n    C = original.constructor;\n    // cross-realm fallback\n    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;\n    if (isObject(C)) {\n      C = C[SPECIES];\n      if (C === null) C = undefined;\n    }\n  } return C === undefined ? Array : C;\n};\n","// 9.4.2.3 ArraySpeciesCreate(originalArray, length)\nvar speciesConstructor = require('./_array-species-constructor');\n\nmodule.exports = function (original, length) {\n  return new (speciesConstructor(original))(length);\n};\n","// 0 -> Array#forEach\n// 1 -> Array#map\n// 2 -> Array#filter\n// 3 -> Array#some\n// 4 -> Array#every\n// 5 -> Array#find\n// 6 -> Array#findIndex\nvar ctx = require('./_ctx');\nvar IObject = require('./_iobject');\nvar toObject = require('./_to-object');\nvar toLength = require('./_to-length');\nvar asc = require('./_array-species-create');\nmodule.exports = function (TYPE, $create) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  var create = $create || asc;\n  return function ($this, callbackfn, that) {\n    var O = toObject($this);\n    var self = IObject(O);\n    var f = ctx(callbackfn, that, 3);\n    var length = toLength(self.length);\n    var index = 0;\n    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;\n    var val, res;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      val = self[index];\n      res = f(val, index, O);\n      if (TYPE) {\n        if (IS_MAP) result[index] = res;   // map\n        else if (res) switch (TYPE) {\n          case 3: return true;             // some\n          case 5: return val;              // find\n          case 6: return index;            // findIndex\n          case 2: result.push(val);        // filter\n        } else if (IS_EVERY) return false; // every\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;\n  };\n};\n","'use strict';\nvar global = require('./_global');\nvar $export = require('./_export');\nvar meta = require('./_meta');\nvar fails = require('./_fails');\nvar hide = require('./_hide');\nvar redefineAll = require('./_redefine-all');\nvar forOf = require('./_for-of');\nvar anInstance = require('./_an-instance');\nvar isObject = require('./_is-object');\nvar setToStringTag = require('./_set-to-string-tag');\nvar dP = require('./_object-dp').f;\nvar each = require('./_array-methods')(0);\nvar DESCRIPTORS = require('./_descriptors');\n\nmodule.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {\n  var Base = global[NAME];\n  var C = Base;\n  var ADDER = IS_MAP ? 'set' : 'add';\n  var proto = C && C.prototype;\n  var O = {};\n  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {\n    new C().entries().next();\n  }))) {\n    // create collection constructor\n    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);\n    redefineAll(C.prototype, methods);\n    meta.NEED = true;\n  } else {\n    C = wrapper(function (target, iterable) {\n      anInstance(target, C, NAME, '_c');\n      target._c = new Base();\n      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);\n    });\n    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {\n      var IS_ADDER = KEY == 'add' || KEY == 'set';\n      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {\n        anInstance(this, C, KEY);\n        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;\n        var result = this._c[KEY](a === 0 ? 0 : a, b);\n        return IS_ADDER ? this : result;\n      });\n    });\n    IS_WEAK || dP(C.prototype, 'size', {\n      get: function () {\n        return this._c.size;\n      }\n    });\n  }\n\n  setToStringTag(C, NAME);\n\n  O[NAME] = C;\n  $export($export.G + $export.W + $export.F, O);\n\n  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);\n\n  return C;\n};\n","'use strict';\nvar strong = require('./_collection-strong');\nvar validate = require('./_validate-collection');\nvar MAP = 'Map';\n\n// 23.1 Map Objects\nmodule.exports = require('./_collection')(MAP, function (get) {\n  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.1.3.6 Map.prototype.get(key)\n  get: function get(key) {\n    var entry = strong.getEntry(validate(this, MAP), key);\n    return entry && entry.v;\n  },\n  // 23.1.3.9 Map.prototype.set(key, value)\n  set: function set(key, value) {\n    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);\n  }\n}, strong, true);\n","var forOf = require('./_for-of');\n\nmodule.exports = function (iter, ITERATOR) {\n  var result = [];\n  forOf(iter, false, result.push, result, ITERATOR);\n  return result;\n};\n","// https://github.com/DavidBruant/Map-Set.prototype.toJSON\nvar classof = require('./_classof');\nvar from = require('./_array-from-iterable');\nmodule.exports = function (NAME) {\n  return function toJSON() {\n    if (classof(this) != NAME) throw TypeError(NAME + \"#toJSON isn't generic\");\n    return from(this);\n  };\n};\n","// https://github.com/DavidBruant/Map-Set.prototype.toJSON\nvar $export = require('./_export');\n\n$export($export.P + $export.R, 'Map', { toJSON: require('./_collection-to-json')('Map') });\n","'use strict';\n// https://tc39.github.io/proposal-setmap-offrom/\nvar $export = require('./_export');\n\nmodule.exports = function (COLLECTION) {\n  $export($export.S, COLLECTION, { of: function of() {\n    var length = arguments.length;\n    var A = Array(length);\n    while (length--) A[length] = arguments[length];\n    return new this(A);\n  } });\n};\n","// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of\nrequire('./_set-collection-of')('Map');\n","'use strict';\n// https://tc39.github.io/proposal-setmap-offrom/\nvar $export = require('./_export');\nvar aFunction = require('./_a-function');\nvar ctx = require('./_ctx');\nvar forOf = require('./_for-of');\n\nmodule.exports = function (COLLECTION) {\n  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {\n    var mapFn = arguments[1];\n    var mapping, A, n, cb;\n    aFunction(this);\n    mapping = mapFn !== undefined;\n    if (mapping) aFunction(mapFn);\n    if (source == undefined) return new this();\n    A = [];\n    if (mapping) {\n      n = 0;\n      cb = ctx(mapFn, arguments[2], 2);\n      forOf(source, false, function (nextItem) {\n        A.push(cb(nextItem, n++));\n      });\n    } else {\n      forOf(source, false, A.push, A);\n    }\n    return new this(A);\n  } });\n};\n","// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from\nrequire('./_set-collection-from')('Map');\n","require('../modules/es6.object.to-string');\nrequire('../modules/es6.string.iterator');\nrequire('../modules/web.dom.iterable');\nrequire('../modules/es6.map');\nrequire('../modules/es7.map.to-json');\nrequire('../modules/es7.map.of');\nrequire('../modules/es7.map.from');\nmodule.exports = require('../modules/_core').Map;\n","module.exports = { \"default\": require(\"core-js/library/fn/map\"), __esModule: true };","\"use strict\";\n\nexports.__esModule = true;\n\nvar _defineProperty = require(\"../core-js/object/define-property\");\n\nvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (obj, key, value) {\n  if (key in obj) {\n    (0, _defineProperty2.default)(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};","var anObject = require('./_an-object');\nvar get = require('./core.get-iterator-method');\nmodule.exports = require('./_core').getIterator = function (it) {\n  var iterFn = get(it);\n  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');\n  return anObject(iterFn.call(it));\n};\n","require('../modules/web.dom.iterable');\nrequire('../modules/es6.string.iterator');\nmodule.exports = require('../modules/core.get-iterator');\n","module.exports = { \"default\": require(\"core-js/library/fn/get-iterator\"), __esModule: true };","import { compare } from \"./Util\";\r\nimport FSymbol from \"./Symbol\";\r\nvar GenericComparer = (function () {\r\n    function GenericComparer(f) {\r\n        this.Compare = f || compare;\r\n    }\r\n    GenericComparer.prototype[FSymbol.reflection] = function () {\r\n        return { interfaces: [\"System.IComparer\"] };\r\n    };\r\n    return GenericComparer;\r\n}());\r\nexport default GenericComparer;\r\n","import FSymbol from \"./Symbol\";\r\nimport { equalsUnions } from \"./Util\";\r\nimport { compareUnions } from \"./Util\";\r\nexport function choice1Of2(v) {\r\n    return new Choice(\"Choice1Of2\", [v]);\r\n}\r\nexport function choice2Of2(v) {\r\n    return new Choice(\"Choice2Of2\", [v]);\r\n}\r\nvar Choice = (function () {\r\n    function Choice(t, d) {\r\n        this.Case = t;\r\n        this.Fields = d;\r\n    }\r\n    Object.defineProperty(Choice.prototype, \"valueIfChoice1\", {\r\n        get: function () {\r\n            return this.Case === \"Choice1Of2\" ? this.Fields[0] : null;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Choice.prototype, \"valueIfChoice2\", {\r\n        get: function () {\r\n            return this.Case === \"Choice2Of2\" ? this.Fields[0] : null;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Choice.prototype.Equals = function (other) {\r\n        return equalsUnions(this, other);\r\n    };\r\n    Choice.prototype.CompareTo = function (other) {\r\n        return compareUnions(this, other);\r\n    };\r\n    Choice.prototype[FSymbol.reflection] = function () {\r\n        return {\r\n            type: \"Microsoft.FSharp.Core.FSharpChoice\",\r\n            interfaces: [\"FSharpUnion\", \"System.IEquatable\", \"System.IComparable\"]\r\n        };\r\n    };\r\n    return Choice;\r\n}());\r\nexport default Choice;\r\n","﻿namespace TheGamma.Babel\n\n// ------------------------------------------------------------------------------------------------\n// Babel AST and formatting it as JSON\n// ------------------------------------------------------------------------------------------------\n\nopen Fable\nopen Fable.Core\n\n/// Each Position object consists of a line number (1-indexed) and a column number (0-indexed):\ntype Position =\n  { line: int; column: int; }\n\ntype SourceLocation =\n  { start: Position; ``end``: Position; }\n\ntype AssignmentOperator =\n  | AssignEqual\n  | AssignMinus\n  | AssignPlus\n  | AssignMultiply\n  | AssignDivide\n  | AssignModulus\n  | AssignShiftLeft\n  | AssignShiftRightSignPropagating\n  | AssignShiftRightZeroFill\n  | AssignOrBitwise\n  | AssignXorBitwise\n  | AssignAndBitwise    \n\ntype BinaryOperator =\n  | BinaryEqual\n  | BinaryUnequal\n  | BinaryEqualStrict\n  | BinaryUnequalStrict\n  | BinaryLess\n  | BinaryLessOrEqual\n  | BinaryGreater\n  | BinaryGreaterOrEqual\n  | BinaryShiftLeft\n  | BinaryShiftRightSignPropagating\n  | BinaryShiftRightZeroFill\n  | BinaryMinus\n  | BinaryPlus\n  | BinaryMultiply\n  | BinaryDivide\n  | BinaryModulus\n  | BinaryExponent\n  | BinaryOrBitwise\n  | BinaryXorBitwise\n  | BinaryAndBitwise\n  | BinaryIn\n  | BinaryInstanceOf\n\ntype Pattern = \n  | IdentifierPattern of name:string * location:SourceLocation option\n\ntype VariableDeclarationKind = \n  | Var | Let | Const\n\ntype VariableDeclarator = \n  | VariableDeclarator of id:Pattern * init:Expression option * location:SourceLocation option\n\nand ObjectMember = \n  | ObjectProperty of key:Expression * value:Expression * computed:bool * location:SourceLocation option\n\nand Expression = \n  | IdentifierExpression of name:string * location:SourceLocation option\n  | FunctionExpression of id:string option * ``params``:Pattern list * body:Statement * generator:bool * async:bool * location:SourceLocation option\n  | NullLiteral of location:SourceLocation option\n  | StringLiteral of value:string * location:SourceLocation option\n  | BooleanLiteral of value:bool * location:SourceLocation option\n  | NumericLiteral of value:float * location:SourceLocation option\n  | AssignmentExpression of operator:AssignmentOperator * left:Expression * right:Expression * location:SourceLocation option\n  | CallExpression of callee:Expression * args:Expression list * location:SourceLocation option\n  | ArrayExpression of elements:Expression list * location:SourceLocation option\n  | MemberExpression of obj:Expression * property:Expression * computed:bool * location:SourceLocation option\n  | NewExpression of callee:Expression * arguments:Expression list * location:SourceLocation option\n  | BinaryExpression of operator:BinaryOperator * left:Expression * right:Expression * location:SourceLocation option\n  | ObjectExpression of properties:ObjectMember list * location:SourceLocation option\n\nand Statement =\n  | ExpressionStatement of expression:Expression * location:SourceLocation option\n  | BlockStatement of body:Statement list * location:SourceLocation option\n  | EmptyStatement of location:SourceLocation option\n  | ReturnStatement of argument:Expression * location:SourceLocation option\n  | VariableDeclaration of kind:VariableDeclarationKind * declarations:VariableDeclarator list * location:SourceLocation option\n\ntype Program = \n  { location : SourceLocation option\n    body: Statement list }\n\nmodule Serializer = \n  let createObj props = JsInterop.createObj (List.concat props)\n  let inline (=>) k v = [ k, box v ]\n  let inline (=?>) k v = match v with Some v -> [ k, box v] | _ -> []\n\n  let serializeBinaryOperator = function\n    | BinaryEqual -> \"==\"\n    | BinaryUnequal -> \"!=\"\n    | BinaryEqualStrict -> \"===\"\n    | BinaryUnequalStrict -> \"!==\"\n    | BinaryLess -> \"<\"\n    | BinaryLessOrEqual -> \"<=\"\n    | BinaryGreater -> \">\"\n    | BinaryGreaterOrEqual -> \">=\"\n    | BinaryShiftLeft -> \"<<\"\n    | BinaryShiftRightSignPropagating -> \">>\"\n    | BinaryShiftRightZeroFill -> \">>>\"\n    | BinaryMinus -> \"-\"\n    | BinaryPlus -> \"+\"\n    | BinaryMultiply -> \"*\"\n    | BinaryDivide -> \"/\"\n    | BinaryModulus -> \"%\"\n    | BinaryExponent -> \"**\"\n    | BinaryOrBitwise -> \"|\"\n    | BinaryXorBitwise -> \"^\"\n    | BinaryAndBitwise -> \"&\"\n    | BinaryIn -> \"in\"\n    | BinaryInstanceOf -> \"instanceof\"\n\n  let serializeAssignOperator = function\n    | AssignEqual -> \"=\"\n    | AssignMinus -> \"-=\"\n    | AssignPlus -> \"+=\"\n    | AssignMultiply -> \"*=\"\n    | AssignDivide -> \"/=\"\n    | AssignModulus -> \"%=\"\n    | AssignShiftLeft -> \"<<=\"\n    | AssignShiftRightSignPropagating -> \">>=\"\n    | AssignShiftRightZeroFill -> \">>>=\"\n    | AssignOrBitwise -> \"|=\"\n    | AssignXorBitwise -> \"^=\"\n    | AssignAndBitwise -> \"&=\"\n\n  let serializePattern pat = \n    match pat with\n    | IdentifierPattern(name, loc) ->\n        createObj [ \"type\" => \"Identifier\"; \"name\" => name; \"loc\" =?> loc ]\n\n  let rec serializeMember mem = \n    match mem with\n    | ObjectProperty(key, value, computed, loc) ->\n        createObj [ \n          \"type\" => \"ObjectProperty\"; \"key\" => serializeExpression key\n          \"value\" => serializeExpression value; \"computed\" => computed       \n          \"loc\" =?> loc ]\n\n  and serializeDeclarator (VariableDeclarator(id, init, loc)) = \n    createObj [ \n      \"type\" => \"VariableDeclarator\"; \"id\" => serializePattern id; \n      \"init\" =?> Option.map serializeExpression init; \"loc\" =?> loc ]\n    \n  and serializeExpression expr = \n    match expr with\n    | IdentifierExpression(name, loc) ->\n        createObj [ \"type\" => \"Identifier\"; \"name\" => name; \"loc\" =?> loc ]\n    | NewExpression(callee, args, loc) ->\n        createObj [ \n          \"type\" => \"NewExpression\"; \"callee\" => serializeExpression callee\n          \"arguments\" => Array.ofList (List.map serializeExpression args); \"loc\" =?> loc ]\n    | FunctionExpression(id, pars, body, generator, async, loc) ->\n        createObj [ \n          \"type\" => \"FunctionExpression\"; \"id\" =?> id; \"params\" => Array.ofList (List.map serializePattern pars)\n          \"body\" => serializeStatement body; \"generator\" => generator; \"async\" => async; \"loc\" =?> loc ]\n    | AssignmentExpression(op, l, r, loc) ->\n        createObj [ \n          \"type\" => \"AssignmentExpression\"; \"left\" => serializeExpression l; \"right\" => serializeExpression r;\n          \"operator\" => serializeAssignOperator op; \"loc\" =?> loc ]\n    | CallExpression(callee, args, loc) ->\n        createObj [ \n          \"type\" => \"CallExpression\"; \"callee\" => serializeExpression callee\n          \"arguments\" => Array.ofSeq (List.map serializeExpression args); \"loc\" =?> loc ]\n    | MemberExpression(obj, prop, computed, loc) ->\n        createObj [\n          \"type\" => \"MemberExpression\"; \"object\" => serializeExpression obj;\n          \"property\" => serializeExpression prop; \"computed\" => computed; \"loc\" =?> loc ]\n    | BinaryExpression(op, l, r, loc) ->\n        createObj [ \n          \"type\" => \"BinaryExpression\"; \"left\" => serializeExpression l; \"right\" => serializeExpression r;\n          \"operator\" => serializeBinaryOperator op; \"loc\" =?> loc ]\n    | ObjectExpression(props, loc) ->\n        createObj [ \"type\" => \"ObjectExpression\"; \"properties\" => Array.ofList (List.map serializeMember props); \"loc\" =?> loc ]\n    \n    | ArrayExpression(elements, loc) ->\n        createObj [ \"type\" => \"ArrayExpression\"; \"elements\" => Array.ofSeq (List.map serializeExpression elements); \"loc\" =?> loc ]\n\n    | NullLiteral(loc) ->\n        createObj [ \"type\" => \"NullLiteral\"; \"loc\" =?> loc ]\n    | StringLiteral(v, loc) ->\n        createObj [ \"type\" => \"StringLiteral\"; \"value\" => v; \"loc\" =?> loc ]\n    | BooleanLiteral(v, loc) ->\n        createObj [ \"type\" => \"BooleanLiteral\"; \"value\" => v; \"loc\" =?> loc ]\n    | NumericLiteral(v, loc) ->\n        createObj [ \"type\" => \"NumericLiteral\"; \"value\" => v; \"loc\" =?> loc ]\n\n  and serializeStatement stm = \n    match stm with\n    | ExpressionStatement(e, loc) ->  \n        createObj [ \"type\" => \"ExpressionStatement\"; \"loc\" =?> loc; \"expression\" => serializeExpression e ]\n    | BlockStatement(b, loc) ->\n        createObj [ \"type\" => \"BlockStatement\"; \"loc\" =?> loc; \"body\" => Array.ofList (List.map serializeStatement b) ]\n    | EmptyStatement(loc) ->\n        createObj [ \"type\" => \"EmptyStatement\"; \"loc\" =?> loc  ]\n    | ReturnStatement(arg, loc) ->\n        createObj [ \"type\" => \"ReturnStatement\"; \"loc\" =?> loc; \"argument\" => serializeExpression arg ]\n    | VariableDeclaration(kind, decls, loc) ->\n        let kind = match kind with Var -> \"var\" | Let -> \"let\" | Const -> \"const\"\n        createObj [ \n          \"type\" => \"VariableDeclaration\"; \"kind\" => kind; \n          \"declarations\" => Array.ofList (List.map serializeDeclarator decls); \"loc\" =?> loc  ]\n\n  let serializeProgram prog = \n    createObj [\n      \"type\" => \"Program\"\n      \"loc\" =?> prog.location \n      \"sourceType\" => \"module\"\n      \"body\" => Array.ofList (List.map serializeStatement prog.body)\n      \"directives\" => box [||]\n    ]\n\n// ------------------------------------------------------------------------------------------------\n// Operators that make constructing Babel ASTs easier\n// ------------------------------------------------------------------------------------------------\n\nmodule BabelOperators = \n  let ident s = IdentifierExpression(s, None)\n  let str v = StringLiteral(v, None)\n  let num v = NumericLiteral(v, None)\n  let bool v = BooleanLiteral(v, None)\n  let arr l = ArrayExpression(l, None)\n\n  let (?) (e:Expression) (s:string) = MemberExpression(e, IdentifierExpression(s, None), false, None)\n  let (/?/) (e:Expression) a = MemberExpression(e, a, true, None)\n\n  let (/@/) (e:Expression) (args) = CallExpression(e, args, None)\n\n  let func v f = \n    let body = BlockStatement([ReturnStatement(f (ident v), None)], None)\n    FunctionExpression(None, [IdentifierPattern(v, None)], body, false, false, None)\n  \n  let funcN n f = \n    let args = List.init n (fun i -> \"_arg\" + string i)\n    let body = BlockStatement([ReturnStatement(f (List.map ident args), None)], None)\n    FunctionExpression(None, List.map (fun s -> IdentifierPattern(s, None)) args, body, false, false, None)\n\n\n\n(*\ntype NumberKind =\n    | Int8 | UInt8 | Int16 | UInt16 | Int32 | UInt32 | Float32 | Float64\n\ntype RegexFlag =\n    | RegexGlobal | RegexIgnoreCase | RegexMultiline | RegexSticky\n\ntype UnaryOperator =\n    | UnaryMinus\n    | UnaryPlus\n    | UnaryNot\n    | UnaryNotBitwise\n    | UnaryTypeof\n    | UnaryVoid\n    | UnaryDelete\n    \ntype UpdateOperator =\n    | UpdateMinus\n    | UpdatePlus\n        \ntype LogicalOperator =\n    | LogicalOr\n    | LogicalAnd\n    \ntype AssignmentOperator =\n    | AssignEqual\n    | AssignMinus\n    | AssignPlus\n    | AssignMultiply\n    | AssignDivide\n    | AssignModulus\n    | AssignShiftLeft\n    | AssignShiftRightSignPropagating\n    | AssignShiftRightZeroFill\n    | AssignOrBitwise\n    | AssignXorBitwise\n    | AssignAndBitwise    \n*)\n(*\n/// The type field is a string representing the AST variant type. \n/// Each subtype of Node is documented below with the specific string of its type field. \n/// You can use this field to determine which interface a node implements.\n/// The loc field represents the source location information of the node. \n/// If the node contains no information about the source location, the field is null; \n/// otherwise it is an object consisting of a start position (the position of the first character of the parsed source region) \n/// and an end position (the position of the first character after the parsed source region):\n[<AbstractClass>]\ntype Node(typ, ?loc) =\n    member x.``type``: string = typ\n    member x.loc: SourceLocation option = loc\n\n/// Since the left-hand side of an assignment may be any expression in general, an expression can also be a pattern.\n[<AbstractClass>] type Expression(typ, ?loc) = inherit Node(typ, ?loc = loc)\n\n[<AbstractClass>] type Literal(typ, ?loc) = inherit Expression(typ, ?loc = loc)\n\n[<AbstractClass>] type Statement(typ, ?loc) = inherit Node(typ, ?loc = loc)\n\n/// Note that declarations are considered statements; this is because declarations can appear in any statement context.\n[<AbstractClass>] type Declaration(typ, ?loc) = inherit Statement(typ, ?loc = loc)\n\n/// A module import or export declaration.\n[<AbstractClass>] type ModuleDeclaration(typ, ?loc) = inherit Node(typ, ?loc = loc)\n\ntype Pattern = interface end\n\n/// Placeholder, doesn't belong to Babel specs\ntype EmptyExpression() =\n    inherit Expression(\"EmptyExpression\")\n\n/// Not in Babel specs, disguised as StringLiteral    \ntype MacroExpression(value, args, ?loc) =\n    inherit Literal(\"StringLiteral\", ?loc = loc)\n    member x.value: string = value\n    member x.args: Node[] = args\n    member x.macro = true\n\n(** ##Template Literals *)\ntype TemplateElement(value: string, tail, ?loc) =\n    inherit Node(\"TemplateElement\", ?loc = loc)\n    member x.tail: bool = tail\n    member x.value = dict [ (\"raw\", value); (\"cooked\", value) ]\n\ntype TemplateLiteral(quasis, expressions, ?loc) =\n    inherit Literal(\"TemplateLiteral\", ?loc = loc)\n    member x.quasis: TemplateElement[] = quasis\n    member x.expressions: Expression[] = expressions\n    \ntype TaggedTemplateExpression(tag, quasi, ?loc) =\n    inherit Expression(\"TaggedTemplateExpression\", ?loc = loc)\n    member x.tag: Expression = tag\n    member x.quasi: TemplateLiteral = quasi\n\n(** ##Identifier *)\n/// Note that an identifier may be an expression or a destructuring pattern.\ntype Identifier(name, ?loc) =\n    inherit Expression(\"Identifier\", ?loc = loc)\n    member x.name: string = name\n    interface Pattern\n    override x.ToString() = x.name\n\n(** ##Literals *)\ntype RegExpLiteral(pattern, flags, ?loc) =\n    inherit Literal(\"RegExpLiteral\", ?loc = loc)\n    member x.pattern: string = pattern\n    member x.flags =\n        flags |> Seq.map (function\n            | RegexGlobal -> \"g\"\n            | RegexIgnoreCase -> \"i\"\n            | RegexMultiline -> \"m\"\n            | RegexSticky -> \"y\") |> Seq.fold (+) \"\"\n\ntype NullLiteral(?loc) =\n    inherit Literal(\"NullLiteral\", ?loc = loc)\n\ntype StringLiteral(value, ?loc) =\n    inherit Literal(\"StringLiteral\", ?loc = loc)\n    member x.value: string = value\n\ntype BooleanLiteral(value, ?loc) =\n    inherit Literal(\"BooleanLiteral\", ?loc = loc)\n    member x.value: bool = value\n\ntype NumericLiteral(value, ?loc) =\n    inherit Literal(\"NumericLiteral\", ?loc = loc)\n    member x.value: U2<int, float> = value    \n\n(** ##Misc *)\ntype Decorator(value, ?loc) =\n    inherit Node(\"Decorator\", ?loc = loc)\n    member x.value = value\n    \ntype DirectiveLiteral(?loc) =\n    inherit StringLiteral(\"DirectiveLiteral\", ?loc = loc)\n\n/// e.g. \"use strict\";\ntype Directive(value, ?loc) =\n    inherit Node(\"Directive\", ?loc = loc)\n    member x.value: DirectiveLiteral = value    \n\n(** ##Program *)\n/// A complete program source tree.\n/// Parsers must specify sourceType as \"module\" if the source has been parsed as an ES6 module. \n/// Otherwise, sourceType must be \"script\".\ntype Program(fileName, originalFileName, loc, body, ?directives) =\n    inherit Node(\"Program\", loc)\n    member x.sourceType = \"module\" // Don't use \"script\"\n    member x.body: U2<Statement, ModuleDeclaration>[] = body\n    member x.directives: Directive[] = defaultArg directives [||]\n    // Properties below don't belong to babel specs\n    member x.fileName: string = fileName\n    member x.originalFileName: string = originalFileName\n\n(** ##Statements *)\n/// An expression statement, i.e., a statement consisting of a single expression.\ntype ExpressionStatement(expression, ?loc) =\n    inherit Statement(\"ExpressionStatement\", ?loc = loc)\n    member x.expression: Expression = expression\n\n/// A block statement, i.e., a sequence of statements surrounded by braces.\ntype BlockStatement(body, ?directives, ?loc) =\n    inherit Statement(\"BlockStatement\", ?loc = loc)\n    member x.body: Statement[] = body\n    member x.directives: Directive[] = defaultArg directives [||]\n\n/// An empty statement, i.e., a solitary semicolon.\ntype EmptyStatement(?loc) =\n    inherit Statement(\"EmptyStatement\", ?loc = loc)\n\ntype DebuggerStatement(?loc) =\n    inherit Statement(\"DebuggerStatement\", ?loc = loc)\n    \n// type WithStatement\n\n(** ##Control Flow *)\ntype ReturnStatement(argument, ?loc) =\n    inherit Statement(\"ReturnStatement\", ?loc = loc)\n    member x.argument: Expression = argument\n\n// type LabeledStatement\n// type BreakStatement\n// type ContinueStatement\n\n(** ##Choice *)\ntype IfStatement(test, consequent, ?alternate, ?loc) =\n    inherit Statement(\"IfStatement\", ?loc = loc)\n    member x.test: Expression = test\n    member x.consequent: Statement = consequent\n    member x.alternate: Statement option = alternate    \n\n/// A case (if test is an Expression) or default (if test === null) clause in the body of a switch statement.\ntype SwitchCase(consequent, ?test, ?loc) =\n    inherit Node(\"SwitchCase\", ?loc = loc)\n    member x.test: Expression option = test\n    member x.consequent: Statement[] = consequent\n\ntype SwitchStatement(discriminant, cases, ?loc) =\n    inherit Statement(\"SwitchStatement\", ?loc = loc)\n    member x.discriminant: Expression = discriminant\n    member x.cases: SwitchCase[] = cases\n\n(** ##Exceptions *)\ntype ThrowStatement(argument, ?loc) =\n    inherit Statement(\"ThrowStatement\", ?loc = loc)\n    member x.argument: Expression = argument\n\n/// A catch clause following a try block.\ntype CatchClause(param, body, ?loc) =\n    inherit Node(\"CatchClause\", ?loc = loc)\n    member x.param: Pattern = param\n    member x.body: BlockStatement = body\n\n/// If handler is null then finalizer must be a BlockStatement.\ntype TryStatement(block, ?handler, ?finalizer, ?loc) =\n    inherit Statement(\"TryStatement\", ?loc = loc)\n    member x.block: BlockStatement = block\n    member x.handler: CatchClause option = handler\n    member x.finalizer: BlockStatement option = finalizer\n\n(** ##Declarations *)\ntype VariableDeclarator(id, ?init, ?loc) =\n    inherit Declaration(\"VariableDeclarator\", ?loc = loc)\n    member x.id: Pattern = id\n    member x.init: Expression option = init\n\ntype VariableDeclarationKind = Var | Let | Const\n\ntype VariableDeclaration(kind, declarations, ?loc) =\n    inherit Declaration(\"VariableDeclaration\", ?loc = loc)\n    new (var, ?init, ?loc) =\n        VariableDeclaration(Var, [|VariableDeclarator(var, ?init=init, ?loc=loc)|], ?loc=loc)\n    member x.declarations: VariableDeclarator[] = declarations\n    member x.kind =\n        match kind with Var -> \"var\" | Let -> \"let\" | Const -> \"const\"\n\n(** ##Loops *)\ntype WhileStatement(test, body, ?loc) =\n    inherit Statement(\"WhileStatement\", ?loc = loc)\n    member x.test: Expression = test\n    member x.body: BlockStatement = body\n\ntype DoWhileStatement(body, test, ?loc) =\n    inherit Statement(\"DoWhileStatement\", ?loc = loc)\n    member x.body: BlockStatement = body\n    member x.test: Expression = test\n\ntype ForStatement(body, ?init, ?test, ?update, ?loc) =\n    inherit Statement(\"ForStatement\", ?loc = loc)\n    member x.body: BlockStatement = body\n    member x.init: U2<VariableDeclaration, Expression> option = init\n    member x.test: Expression option = test\n    member x.update: Expression option = update\n\n/// When passing a VariableDeclaration, the bound value must go through\n/// the `right` parameter instead of `init` property in VariableDeclarator\ntype ForInStatement(left, right, body, ?loc) =\n    inherit Statement(\"ForInStatement\", ?loc = loc)\n    member x.body: BlockStatement = body\n    member x.left: U2<VariableDeclaration, Expression> = left\n    member x.right: Expression = right\n\n/// When passing a VariableDeclaration, the bound value must go through\n/// the `right` parameter instead of `init` property in VariableDeclarator\ntype ForOfStatement(left, right, body, ?loc) =\n    inherit Statement(\"ForOfStatement\", ?loc = loc)\n    member x.body: BlockStatement = body\n    member x.left: U2<VariableDeclaration, Expression> = left\n    member x.right: Expression = right\n\n/// A function declaration. Note that id cannot be null.\ntype FunctionDeclaration(id, args, body, ?generator, ?async, ?loc) =\n    inherit Declaration(\"FunctionDeclaration\", ?loc = loc)\n    member x.id: Identifier = id\n    member x.``params``: Pattern[] = args\n    member x.body: BlockStatement = body\n    member x.generator = defaultArg generator false\n    member x.async = defaultArg async false\n\n(** ##Expressions *)\n\n/// A super pseudo-expression.\ntype Super(?loc) =\n    inherit Expression(\"Super\", ?loc = loc)\n\ntype ThisExpression(?loc) =\n    inherit Expression(\"ThisExpression\", ?loc = loc)\n\n/// A fat arrow function expression, e.g., let foo = (bar) => { /* body */ }.\ntype ArrowFunctionExpression(args, body, isExpression, ?async, ?loc) =\n    inherit Expression(\"ArrowFunctionExpression\", ?loc = loc)\n    member x.expression = isExpression\n    member x.``params``: Pattern[] = args\n    member x.body: U2<BlockStatement, Expression> = body\n    member x.async: bool = defaultArg async false\n        \ntype FunctionExpression(args, body, ?generator, ?async, ?id, ?loc) =\n    inherit Expression(\"FunctionExpression\", ?loc = loc)\n    member x.id: Identifier option = id\n    member x.``params``: Pattern[] = args\n    member x.body: BlockStatement = body\n    member x.generator: bool = defaultArg generator false\n    member x.async: bool = defaultArg async false\n    \n/// e.g., x = do { var t = f(); t * t + 1 };\n/// http://wiki.ecmascript.org/doku.php?id=strawman:do_expressions\n/// Doesn't seem to work well with block-scoped variables (let, const)\ntype DoExpression(body, ?loc) =\n    inherit Expression(\"DoExpression\", ?loc = loc)\n    member x.body: BlockStatement = body\n    \ntype YieldExpression(argument, ``delegate``, ?loc) =\n    inherit Expression(\"YieldExpression\", ?loc = loc)\n    member x.argument: Expression option = argument\n    /// Delegates to another generator? (yield* )\n    member x.``delegate``: bool = ``delegate``    \n\ntype AwaitExpression(argument, ?loc) =\n    inherit Expression(\"AwaitExpression\", ?loc = loc)\n    member x.argument: Expression option = argument\n\ntype RestProperty(argument, ?loc) =\n    inherit Node(\"RestProperty\", ?loc = loc)\n    member x.argument: Expression = argument\n\n/// e.g., var z = { x: 1, ...y } // Copy all properties from y \ntype SpreadProperty(argument, ?loc) =\n    inherit Node(\"SpreadProperty\", ?loc = loc)\n    member x.argument: Expression = argument\n\ntype SpreadElement(argument, ?loc) =\n    inherit Node(\"SpreadElement\", ?loc = loc)\n    member x.argument: Expression = argument\n    \ntype ArrayExpression(elements, ?loc) =\n    inherit Expression(\"ArrayExpression\", ?loc = loc)\n    member x.elements: U2<Expression, SpreadElement> option[] = elements\n\n[<AbstractClass>]\ntype ObjectMember(typ, key, ?value, ?computed, ?loc) =\n    inherit Node(typ, ?loc = loc)\n    member x.key: Expression = key\n    member x.value: Expression option = value\n    member x.computed: bool = defaultArg computed false\n    // member x.decorators: Decorator[] = defaultArg decorators []\n    \ntype ObjectProperty(key, value, ?shorthand, ?computed, ?loc) =\n    inherit ObjectMember(\"ObjectProperty\", key, value, ?computed=computed, ?loc=loc)\n    member x.shorthand: bool = defaultArg shorthand false\n\ntype ObjectMethodKind = ObjectGetter | ObjectSetter | ObjectMeth\n\ntype ObjectMethod(kind, key, args, body, ?computed, ?generator, ?async, ?loc) =\n    inherit ObjectMember(\"ObjectMethod\", key, ?computed=computed, ?loc=loc)\n    member x.kind = match kind with ObjectGetter -> \"get\"\n                                  | ObjectSetter -> \"set\"\n                                  | ObjectMeth -> \"method\"\n    member x.``params``: Pattern[] = args\n    member x.body: BlockStatement = body\n    member x.generator: bool = defaultArg generator false\n    member x.async: bool = defaultArg async false\n\n/// If computed is true, the node corresponds to a computed (a[b]) member expression and property is an Expression. \n/// If computed is false, the node corresponds to a static (a.b) member expression and property is an Identifier.\ntype MemberExpression(``object``, property, ?computed, ?loc) =\n    inherit Expression(\"MemberExpression\", ?loc = loc)\n    member x.``object``: Expression = ``object``\n    member x.property: Expression = property\n    member x.computed: bool = defaultArg computed false\n    interface Pattern\n\ntype ObjectExpression(properties, ?loc) =\n    inherit Expression(\"ObjectExpression\", ?loc = loc)\n    member x.properties: U3<ObjectProperty, ObjectMethod, SpreadProperty>[] = properties\n\n/// A conditional expression, i.e., a ternary ?/: expression.\ntype ConditionalExpression(test, consequent, alternate, ?loc) =\n    inherit Expression(\"ConditionalExpression\", ?loc = loc)\n    member x.test: Expression = test\n    member x.consequent: Expression = consequent\n    member x.alternate: Expression = alternate\n\n/// A function or method call expression.  \ntype CallExpression(callee, args, ?loc) =\n    inherit Expression(\"CallExpression\", ?loc = loc)\n    member x.callee: Expression = callee\n    member x.arguments: U2<Expression, SpreadElement>[] = args\n\ntype NewExpression(callee, args, ?loc) =\n    inherit Expression(\"NewExpression\", ?loc = loc)\n    member x.callee: Expression = callee\n    member x.arguments: U2<Expression, SpreadElement>[] = args\n\n/// A comma-separated sequence of expressions.\ntype SequenceExpression(expressions, ?loc) =\n    inherit Expression(\"SequenceExpression\", ?loc = loc)\n    member x.expressions: Expression[] = expressions\n\n(** ##Unary Operations *)\ntype UnaryExpression(operator, argument, ?prefix, ?loc) =\n    inherit Expression(\"UnaryExpression\", ?loc = loc)\n    member x.prefix: bool = defaultArg prefix true\n    member x.argument: Expression = argument\n    member x.operator =\n        match operator with\n        | UnaryMinus -> \"-\"\n        | UnaryPlus -> \"+\"\n        | UnaryNot -> \"!\"\n        | UnaryNotBitwise -> \"~\"\n        | UnaryTypeof -> \"typeof\"\n        | UnaryVoid -> \"void\"\n        | UnaryDelete -> \"delete\"           \n\ntype UpdateExpression(operator, prefix, argument, ?loc) =\n    inherit Expression(\"UpdateExpression\", ?loc = loc)\n    member x.prefix: bool = prefix\n    member x.argument: Expression = argument\n    member x.operator =\n        match operator with\n        | UpdateMinus -> \"--\"\n        | UpdatePlus -> \"++\"\n    \n\ntype AssignmentExpression(operator, left, right, ?loc) =\n    inherit Expression(\"AssignmentExpression\", ?loc = loc)\n    member x.left: Expression = left\n    member x.right: Expression = right\n    member x.operator =\n        match operator with    \n        | AssignEqual -> \"=\"\n        | AssignMinus -> \"-=\"\n        | AssignPlus -> \"+=\"\n        | AssignMultiply -> \"*=\"\n        | AssignDivide -> \"/=\"\n        | AssignModulus -> \"%=\"\n        | AssignShiftLeft -> \"<<=\"\n        | AssignShiftRightSignPropagating -> \">>=\"\n        | AssignShiftRightZeroFill -> \">>>=\"\n        | AssignOrBitwise -> \"|=\"\n        | AssignXorBitwise -> \"^=\"\n        | AssignAndBitwise -> \"&=\"\n    \ntype LogicalExpression(operator, left, right, ?loc) =\n    inherit Expression(\"LogicalExpression\", ?loc = loc)\n    member x.left: Expression = left\n    member x.right: Expression = right\n    member x.operator =\n        match operator with\n        | LogicalOr -> \"||\"\n        | LogicalAnd-> \"&&\"\n        \n\n(** ##Patterns *)\n// type AssignmentProperty(key, value, ?loc) =\n//     inherit ObjectProperty(\"AssignmentProperty\", ?loc = loc)\n//     member x.value: Pattern = value\n\n// type ObjectPattern(properties, ?loc) =\n//     inherit Node(\"ObjectPattern\", ?loc = loc)\n//     member x.properties: U2<AssignmentProperty, RestProperty>[] = properties\n//     interface Pattern\n\ntype ArrayPattern(elements, ?loc) =\n    inherit Node(\"ArrayPattern\", ?loc = loc)\n    member x.elements: Pattern option[] = elements\n    interface Pattern\n\ntype AssignmentPattern(left, right, ?loc) =\n    inherit Node(\"AssignmentPattern\", ?loc = loc)\n    member x.left: Pattern = left\n    member x.right: Expression = right\n    interface Pattern\n\ntype RestElement(argument, ?loc) =\n    inherit Node(\"RestElement\", ?loc = loc)\n    member x.argument: Pattern = argument\n    interface Pattern        \n\n(** ##Classes *)\ntype ClassMethodKind =\n    | ClassConstructor | ClassFunction | ClassGetter | ClassSetter\n\ntype ClassMethod(kind, key, args, body, computed, ``static``, ?loc) =\n    inherit Node(\"ClassMethod\", ?loc = loc)\n    member x.kind = match kind with ClassConstructor -> \"constructor\"\n                                  | ClassGetter -> \"get\"\n                                  | ClassSetter -> \"set\"\n                                  | ClassFunction -> \"method\"\n    member x.key: Expression = key\n    member x.``params``: Pattern[] = args\n    member x.body: BlockStatement = body\n    member x.computed: bool = computed\n    member x.``static``: bool = ``static``\n    // member x.decorators: Decorator[] = defaultArg decorators []\n    // This appears in astexplorer.net but it's not documented\n    // member x.expression: bool = false\n\n/// ES Class Fields & Static Properties\n/// https://github.com/jeffmo/es-class-fields-and-static-properties\n/// e.g, class MyClass { static myStaticProp = 5; myProp /* = 10 */; }\ntype ClassProperty(key, value, ?loc) =\n    inherit Node(\"ClassProperty\", ?loc = loc)\n    member x.key: Identifier = key\n    member x.value: Expression = value\n\ntype ClassBody(body, ?loc) =\n    inherit Node(\"ClassBody\", ?loc = loc)\n    member x.body: U2<ClassMethod, ClassProperty>[] = body\n\ntype ClassDeclaration(body, id, ?super, ?loc) =\n    inherit Declaration(\"ClassDeclaration\", ?loc = loc)\n    member x.body: ClassBody = body\n    member x.id: Identifier = id\n    member x.superClass: Expression option = super\n    // member x.decorators: Decorator[] = defaultArg decorators []\n\n/// Anonymous class: e.g., var myClass = class { }\ntype ClassExpression(body, ?id, ?super, ?loc) =\n    inherit Expression(\"ClassExpression\", ?loc = loc)\n    member x.body: ClassBody = body\n    member x.id: Identifier option = id    \n    member x.superClass: Expression option = super\n    // member x.decorators: Decorator[] = defaultArg decorators []\n\n// type MetaProperty(meta, property, ?loc) =\n//     inherit Expression(\"MetaProperty\", ?loc = loc)\n//     member x.meta: Identifier = meta\n//     member x.property: Expression = property\n\n(** ##Modules *)\n/// A specifier in an import or export declaration.\n[<AbstractClass>]\ntype ModuleSpecifier(typ, local, ?loc) =\n    inherit Node(typ, ?loc = loc)\n    member x.local: Identifier = local\n\n/// An imported variable binding, e.g., {foo} in import {foo} from \"mod\" or {foo as bar} in import {foo as bar} from \"mod\". \n/// The imported field refers to the name of the export imported from the module. \n/// The local field refers to the binding imported into the local module scope. \n/// If it is a basic named import, such as in import {foo} from \"mod\", both imported and local are equivalent Identifier nodes; in this case an Identifier node representing foo. \n/// If it is an aliased import, such as in import {foo as bar} from \"mod\", the imported field is an Identifier node representing foo, and the local field is an Identifier node representing bar.\ntype ImportSpecifier(local, imported, ?loc) =\n    inherit ModuleSpecifier(\"ImportSpecifier\", local, ?loc = loc)\n    member x.imported: Identifier = imported\n\n/// A default import specifier, e.g., foo in import foo from \"mod\".\ntype ImportDefaultSpecifier(local, ?loc) =\n    inherit ModuleSpecifier(\"ImportDefaultSpecifier\", local, ?loc = loc)\n    \n/// A namespace import specifier, e.g., * as foo in import * as foo from \"mod\".\ntype ImportNamespaceSpecifier(local, ?loc) =\n    inherit ModuleSpecifier(\"ImportNamespaceSpecifier\", local, ?loc = loc)\n\n/// e.g., import foo from \"mod\";.\ntype ImportDeclaration(specifiers, source, ?loc) =\n    inherit ModuleDeclaration(\"ImportDeclaration\", ?loc = loc)\n    member x.specifiers: U3<ImportSpecifier, ImportDefaultSpecifier, ImportNamespaceSpecifier>[] = specifiers\n    member x.source: Literal = source\n\n/// An exported variable binding, e.g., {foo} in export {foo} or {bar as foo} in export {bar as foo}. \n/// The exported field refers to the name exported in the module. \n/// The local field refers to the binding into the local module scope. \n/// If it is a basic named export, such as in export {foo}, both exported and local are equivalent Identifier nodes; \n/// in this case an Identifier node representing foo. If it is an aliased export, such as in export {bar as foo}, \n/// the exported field is an Identifier node representing foo, and the local field is an Identifier node representing bar.\ntype ExportSpecifier(local, exported, ?loc) =\n    inherit ModuleSpecifier(\"ExportSpecifier\", local, ?loc = loc)\n    member x.exported: Identifier = exported\n    \n/// An export named declaration, e.g., export {foo, bar};, export {foo} from \"mod\"; or export var foo = 1;.\n/// Note: Having declaration populated with non-empty specifiers or non-null source results in an invalid state.\ntype ExportNamedDeclaration(?declaration, ?specifiers, ?source, ?loc) =\n    inherit ModuleDeclaration(\"ExportNamedDeclaration\", ?loc = loc)\n    member x.declaration: Declaration option = declaration\n    member x.specifiers: ExportSpecifier[] = defaultArg specifiers [||]\n    member x.source: Literal option = source\n\n/// An export default declaration, e.g., export default function () {}; or export default 1;. \ntype ExportDefaultDeclaration(declaration, ?loc) =\n    inherit ModuleDeclaration(\"ExportDefaultDeclaration\", ?loc = loc)\n    member x.declaration: U2<Declaration, Expression> = declaration\n\n/// An export batch declaration, e.g., export * from \"mod\";.\ntype ExportAllDeclaration(source, ?loc) =\n    inherit ModuleDeclaration(\"ExportAllDeclaration\", ?loc = loc)\n    member x.source: Literal = source\n*)","﻿namespace TheGamma\nopen TheGamma.Common\n\n// ------------------------------------------------------------------------------------------------\n// Tokens and common \n// ------------------------------------------------------------------------------------------------\n\n/// Represents a range as character offset in a file. 0-indexed, the End position is the position\n/// of the last character of the thing in the range. Consider range of \"42\" in \"1 + 42 + 2\".\n/// The range of the token 42 here would be { Start = 4; End = 5 }:\n///\n///     1   +   4 2   +   2 \n///     0 1 2 3 4 5 6 7 8 9\n///\ntype Range = \n  { Start : int\n    End : int }\n\n/// Error with a range. Message can be Markdown, Range is generic so that we can reuse \n/// the data structure with both `Range` and line-based range when reporting errors.\ntype Error<'Range> =\n  { Number : int\n    Message : string\n    Range : 'Range }\n\n/// Binary operators (Equals is tokenized as separate token, but after parsing it can be operator)\ntype [<RequireQualifiedAccess>] Operator = \n  | Equals\n  | Modulo\n  | Plus\n  | Minus\n  | Multiply\n  | Divide\n  | Power\n  | GreaterThan\n  | LessThan\n  | GreaterThanOrEqual\n  | LessThanOrEqual\n\n/// Tokens produced by tokenizer\ntype [<RequireQualifiedAccess>] TokenKind = \n  | LParen\n  | RParen\n  | Equals\n  | Dot\n  | Comma\n  | Let\n  | LSquare\n  | RSquare\n  | Colon\n  | Fun\n  | Arrow\n  | Operator of Operator\n  | Boolean of bool\n  | Number of string * float\n  | String of string\n  | Ident of string\n  | QIdent of string\n  | White of string\n  | Newline\n  | Error of char\n  | EndOfFile\n\n/// Token with a range\ntype Token = \n  { Token : TokenKind \n    Range : Range }\n\n// ------------------------------------------------------------------------------------------------\n// Types and code generation\n// ------------------------------------------------------------------------------------------------\n\ntype Emitter = \n  { Emit : Babel.Expression (* Babel.Expression list *) -> Babel.Expression }\n\ntype Metadata = \n  { Context : string\n    Type : string\n    Data : obj }\n\ntype [<RequireQualifiedAccess>] Documentation = \n  | Text of string\n  | Details of string * string\n  | None \n\ntype Member = \n  { Name : string \n    Type : Type \n    Metadata : Metadata list \n    Emitter : Emitter }\n\nand ObjectType = \n  abstract Members : Member[] \n  abstract TypeEquals : ObjectType -> bool\n\nand [<RequireQualifiedAccess>] PrimitiveType = \n  | Number\n  | Date\n  | String\n  | Bool\n  | Unit\n\nand MethodArgument =\n  { Name : string\n    Optional : bool\n    Static : bool\n    Type : Type }\n\nand [<RequireQualifiedAccess>] Type =\n  | Delayed of Future<Type>\n  | Object of ObjectType\n  | Primitive of PrimitiveType\n  | List of elementType:Type\n  | Method of arguments:MethodArgument list * typ:((Type * RuntimeValue option) list -> Type option) \n  | Any\n\n// ------------------------------------------------------------------------------------------------\n// Entities - binder attaches those to individual constructs in the parsed AST\n// ------------------------------------------------------------------------------------------------\n\n/// Name. In expressions, it usually appears as Node<Name> \nand Name = \n  { Name : string }\n\n/// Represents constants that can appear in the code\n/// (We create separate entity for each, so that we can calculate\n/// values of entities and not just types)\nand [<RequireQualifiedAccess>] Constant = \n  | Number of float\n  | String of string\n  | Boolean of bool\n  | Empty\n\n/// Represents different kinds of entities that we create. Roughhly\n/// corresponds to all places in code where something has a name.\nand [<RequireQualifiedAccess>] EntityKind = \n\n  // Entities that represent root node, program and commands\n  | Root\n  | Program of commands:Entity list\n  | RunCommand of body:Entity\n  | LetCommand of variable:Entity * assignment:Entity\n\n  // Standard constructs of the language\n  | List of elements:Entity list\n  | Constant of Constant\n  | Function of variable:Entity * body:Entity\n  | Operator of left:Entity * operator:Operator * right:Entity\n\n  /// Reference to a global symbol or a local variable\n  | GlobalValue of name:Name * Babel.Expression option \n  | Variable of name:Name * value:Entity\n\n  /// Variable binding in lambda abstraction\n  | Binding of name:Name * callSite:Entity\n  /// Call site in which a lambda function appears. Marks method reference & argument\n  /// (the argument is the name or the index of the parameter in the list)\n  | CallSite of instance:Entity * parameter:Choice<string, int>\n\n  /// Represents all arguments passed to method; Antecedants are individual arguments\n  /// (a mix of named parameter & ordinary expression entities)\n  | ArgumentList of arguments:Entity list\n  /// Named param in a call site with an expression assigned to it\n  | NamedParam of name:Name * assignment:Entity\n\n  /// Placeholder with its name and the body entity\n  | Placeholder of name:Name * body:Entity\n\n  /// Member access and call with arguments (call has member access \n  /// as the instance; second argument of Member is MemberName)\n  | Call of instance:Entity * arguments:Entity\n  | Member of instance:Entity * name:Entity \n  | MemberAccess of membr:Entity\n  | MemberName of name:Name\n\n\n  \n/// An entity represents a thing in the source code to which we attach additional info.\n/// It is uniquely identified by its `Symbol` (which is also used for lookups)\nand Entity = \n  { Kind : EntityKind\n    Symbol : Symbol \n    mutable Value : EntityValue option\n    mutable Meta : Metadata list\n    mutable Type : Type option \n    mutable Errors : Error<Range> list }\n\nand RuntimeValue = obj\n\nand EntityValue =\n  { Value : RuntimeValue\n    Preview : Lazy<RuntimeValue option> }\n\n// ------------------------------------------------------------------------------------------------\n// Parsed AST \n// ------------------------------------------------------------------------------------------------\n\n/// Node wraps syntax element with other information. Whitespce before/after are tokens \n/// around it that the parser skipped (they may be whitespace, but also skipped error tokens).\n/// Entity is assigned to the expression later by a binder.\ntype Node<'T> = \n  { WhiteBefore : Token list\n    WhiteAfter : Token list\n    Range : Range \n    Node : 'T\n    mutable Entity : Entity option }\n\n/// Method call argument, optionally with a named\ntype Argument =\n  { Name : Node<Name> option\n    Value : Node<Expr> }\n\n/// A program is a list of commands (with range info)\nand Program = \n  { Body : Node<Node<Command> list> }\n\n/// Variable binding or an expression\nand Command = \n  | Let of Node<Name> * Node<Expr>\n  | Expr of Node<Expr>\n\n/// An expression (does not include let binding, which is a command)\nand [<RequireQualifiedAccess>] Expr = \n  | Variable of Node<Name>\n  | Member of Node<Expr> * Node<Expr>\n  | Call of Node<Expr> * Node<Argument list>\n  | Function of Node<Name> * Node<Expr>\n  | Placeholder of Node<Name> * Node<Expr>\n  | String of string\n  | Number of float\n  | Boolean of bool\n  | Binary of Node<Expr> * Node<Operator> * Node<Expr>\n  | List of Node<Expr> list\n  | Empty\n\n","namespace TheGamma.TypeProviders\n\nopen TheGamma\nopen TheGamma.Babel\nopen TheGamma.Common\nopen Fable.Import\n\ntype ProvidedType = \n  | NamedType of name:string * typ:Type\n  | GlobalValue of string * Metadata list * Expression * Type\n\nmodule ProviderHelpers = \n  let docMeta doc = \n    { Context = \"http://thegamma.net\"\n      Type = \"Documentation\"\n      Data = box doc }\n","﻿module Fable.Helpers.Babel\n\nopen Fable.Core\n\n[<Emit(\"eval($0)\")>]\nlet eval (s:string) : 'T = failwith \"JS only\"\n\ntype BabelOptions = \n  { presets : string[] }\n\ntype BabelResult = \n  { code : string }\n\ntype Babel =\n  abstract transformFromAst : obj * string * BabelOptions -> BabelResult\n\n[<Emit(\"Babel\")>]\nlet babel : Babel = Unchecked.defaultof<_> \n","namespace TheGamma.General\n\nopen System\nopen TheGamma\nopen TheGamma.Html\nopen TheGamma.Common\nopen Fable.Import.Browser\nopen Fable.Core\n\ntype math = \n  static member sqrt(f:float) = sqrt f\n  static member pow(f:float, k) = Math.Pow(f, k)\n  static member log(f:float, ?b) = match b with Some b -> Math.Log(f, b) | _ -> log f\n  static member min(f1:float, f2:float) = min f1 f2\n  static member max(f1:float, f2:float) = max f1 f2\n  static member round(n:float, decimals:int) = Math.Round(n, decimals)\n  static member ceil(n:float) = Math.Ceiling(n)\n  static member floor(n:float) = Math.Floor(n)\n\ntype date = \n  static member now() = DateTime.Now\n  static member date(year,month,day) = DateTime(year,month,day)\n  static member time(year,month,day,hour,minute,second) = DateTime(year,month,day,hour,minute,second)\n\ntype dateformat = \n  static member longDate(dt:obj) : string = formatLongDate (unbox<System.DateTime> dt)\n  \ntype number = \n  static member format(n:float, ?decimals) = niceNumber n (defaultArg decimals 999) \n\ntype pair<'t1, 't2> internal (v1:'t1, v2:'t2) = \n  member x.first = v1\n  member x.second = v2","﻿namespace TheGamma.Series\n\nopen Fable.Core\nopen TheGamma.Common\n\n// --------------------------------------------------------------------------------------------------------------------\n// Series helpers - various JavaScript functions needed for simple series implementation\n// --------------------------------------------------------------------------------------------------------------------\n\nmodule SeriesInternals =\n  open System.Collections.Generic\n\n  [<Emit(\"($0==null)\")>]\n  let isNull(o:obj) : bool = failwith \"never\"\n\n  [<Emit(\"$0[$1]\")>]\n  let getProperty<'T> (obj:obj) (name:string) : 'T = failwith \"never\"\n\n  [<Emit(\"($0 < $1 ? -1 : ($0 == $1 ? 0 : 1))\")>]\n  let compare (x:'a) (y:'a) : int = failwith \"never\"\n\n  let slice lo hi (arr:'T[]) =\n    Array.init (hi - lo + 1) (fun i -> arr.[lo + i])\n\n  let dictAny (v:seq<'k*'v>) = unbox<IDictionary<'k,'v>> (dict (unbox<seq<obj * obj>> v))\n\n  let zipUnsorted (arr1:_[]) (arr2:_[]) =\n    let d1 = dictAny arr1\n    let d2 = dictAny arr2\n    let res = ResizeArray<_>()\n    for kv1 in d1 do\n      let v2 =\n        if d2.ContainsKey(kv1.Key) then Some(d2.[kv1.Key])\n        else None\n      res.Add(kv1.Key, (Some kv1.Value, v2))\n    for kv2 in d2 do\n      if not (d1.ContainsKey(kv2.Key)) then\n        res.Add(kv2.Key, (None, Some kv2.Value))\n    Array.ofSeq res\n\n  let isSortedUsing test proj (arr:_[]) =\n    let rec loop i =\n      if i = arr.Length then true\n      else test (proj arr.[i-1]) (proj arr.[i]) && loop (i+1)\n    arr.Length = 0 || loop 1\n\n  let zipSorted (arr1:('k*'v1)[]) (arr2:('k*'v2)[]) =\n    let mutable i1 = 0\n    let mutable i2 = 0\n    let inline (<.) (a:'k) (b:'k) = compare a b < 0\n    let inline eq (a:'k) (b:'k) = compare a b = 0\n    let res = ResizeArray<_>()\n    while i1 < arr1.Length && i2 < arr2.Length do\n      let (k1, v1), (k2, v2) = arr1.[i1], arr2.[i2]\n      if eq k1 k2 then\n        res.Add(k1, (Some v1, Some v2))\n        i1 <- i1 + 1\n        i2 <- i2 + 1\n      elif k1 <. k2 then\n        res.Add(k1, (Some v1, None))\n        i1 <- i1 + 1\n      elif k2 <. k1 then\n        res.Add(k2, (None, Some v2))\n        i2 <- i2 + 1\n    while i1 < arr1.Length do\n      let k1, v1 = arr1.[i1]\n      res.Add(k1, (Some v1, None))\n      i1 <- i1 + 1\n    while i2 < arr2.Length do\n      let k2, v2 = arr2.[i2]\n      res.Add(k2, (None, Some v2))\n      i2 <- i2 + 2\n    Array.ofSeq res\n\n  let zipAny (arr1:('k*'v1)[]) (arr2:('k*'v2)[]) =\n    let (<=.) (a:'k) (b:'k) = compare a b <= 0\n    let (>=.) (a:'k) (b:'k) = compare a b >= 0\n    if isSortedUsing (<=.) fst arr1 && isSortedUsing (<=.) fst arr2 then zipSorted arr1 arr2\n    elif isSortedUsing (>=.) fst arr1 && isSortedUsing (>=.) fst arr2 then Array.rev (zipSorted (Array.rev arr1) (Array.rev arr2))\n    else zipUnsorted arr1 arr2\n\n// --------------------------------------------------------------------------------------------------------------------\n// Async series library for TheGamma - implements type `series<'k, 'v>` with various operations\n// --------------------------------------------------------------------------------------------------------------------\n\nopen SeriesInternals\n\ntype ``val``<'k> = \n  { value : Async<'k> }\n  member s.map(f) =\n    { value = async { \n        let! r = s.value \n        return f r } }\n\ntype internal helpers = \n  static member inline lift (f:('a*'b)[] -> ('c*'d)[]) (s:series<_, _>) =\n    let nd = async {\n      let! vs = s.data |> Async.AwaitFuture\n      return f vs } |> Async.StartAsFuture\n    { data = nd\n      keyName = s.keyName\n      valueName = s.valueName\n      seriesName = s.seriesName } \n  static member inline asyncLift (f:('a*'b)[] -> Async<('c*'d)[]>) (s:series<_, _>) =\n    let nd = async {\n      let! vs = s.data |> Async.AwaitFuture\n      return! f vs } |> Async.StartAsFuture\n    { data = nd\n      keyName = s.keyName\n      valueName = s.valueName\n      seriesName = s.seriesName }\n\n  static member inline liftAggregation f (s:series<_, _>) : ``val``<_> =\n    { value = async {\n        let! vs = s.data |> Async.AwaitFuture\n        return f vs } }\n\nand series<'k, 'v> = \n  internal \n    { data : Future<('k * 'v)[]> \n      keyName : string\n      valueName : string\n      seriesName : string }\n\n  member internal x.set(data, ?keyName, ?valueName, ?seriesName) = \n    { data = data \n      keyName = defaultArg keyName x.keyName\n      valueName = defaultArg valueName x.valueName\n      seriesName = defaultArg seriesName x.seriesName }\n  member x.setProperties(?keyName, ?valueName, ?seriesName) = \n    { x with \n        keyName = defaultArg keyName x.keyName\n        valueName = defaultArg valueName x.valueName\n        seriesName = defaultArg seriesName x.seriesName }\n\n//type series =\n  static member create(data, keyName, valueName, seriesName) = \n    { data = data |> Async.StartAsFuture; keyName = keyName; valueName = valueName; seriesName = seriesName }\n\n  // TODO: This is where the naming starts to suck\n  static member values(values) = \n    let data = async {\n      return values |> Array.mapi (fun i v -> i, v) } |> Async.StartAsFuture\n    { data = data; keyName = \"key\"; valueName = \"value\"; seriesName = \"\" }\n\n  static member range(from, ``to``) = \n    series<int, int>.values [| from .. ``to`` |]\n\n  static member rangeBy(from, ``to``, step) = \n    series<int, int>.values [| from .. step .. ``to`` |]\n\n  static member ordinal(data, keyName, valueName, seriesName) = \n    let data = async {\n      let! values = data\n      return values |> Array.mapi (fun i v -> i, v) } |> Async.StartAsFuture\n    { data = data; keyName = keyName; valueName = valueName; seriesName = seriesName }\n\n  member s.sortKeys(?reverse) =\n    s |> helpers.lift (fun arr ->\n      arr |> Array.sortWith (fun (k1, _) (k2, _) -> compare k1 k2)\n          |> (if reverse = Some true then Array.rev else id))\n\n  member s.sortValues(?reverse) =\n    s |> helpers.lift (fun arr ->\n      arr |> Array.sortWith (fun (_,v1) (_,v2) -> compare v1 v2)\n          |> (if reverse = Some true then Array.rev else id))\n\n  member s.sortBy(f, ?reverse) =\n    s |> helpers.lift (fun arr ->\n      arr |> Array.sortWith (fun (_,v1) (_,v2) -> compare (f v1) (f v2))\n          |> (if reverse = Some true then Array.rev else id))\n\n  member s.reverse() =\n    s |> helpers.lift (Array.rev)\n\n  member s.take(count) =\n    s |> helpers.lift (fun arr -> slice 0 ((min arr.Length count)-1) arr)\n\n  member s.skip(count) =\n    s |> helpers.lift (fun arr -> slice (min arr.Length count) (arr.Length-1) arr)\n\n  member s.shuffle() =\n    s |> helpers.lift (fun arr -> \n      let rnd = System.Random()\n      arr |> Array.sortBy (fun _ -> rnd.Next()) )\n\n  member s.map(f) =\n    s |> helpers.lift (Array.map (fun (k, v) -> k, f v))\n(*\n  member s.mapTask(f:'v -> value<'r>) =\n    s.set(async {\n      let! arr = s.data\n      let res = Array.init arr.Length (fun _ -> None)\n      for i in 0 .. arr.Length-1 do\n        let! r = (f(snd arr.[i])).value\n        res.[i] <- Some r\n      return Array.init arr.Length (fun i -> fst arr.[i], res.[i].Value)\n    })\n*)\n  member s.mapKeys(f) =\n    s |> helpers.lift (Array.map (fun (k, v) -> f k, v))\n\n  member s.mapPairs(f) =\n    s |> helpers.lift (Array.map (fun (k, v) -> k, f k v))\n\n  member s.filter(f) =\n    s |> helpers.lift (Array.filter (snd >> f))\n\n  member s.filterIndex(f) =\n    s |> helpers.lift (Array.mapi (fun i v -> f i, v) >> Array.filter fst >> Array.map snd)\n\n  member s.choose(f) =\n    s |> helpers.lift (Array.choose (fun (k, v) -> match f v with None -> None | Some r -> Some(k, r)))\n\n  member s.joinOuter<'v2>(s2:series<'k, 'v2>) : series<'k, 'v option * 'v2 option>=\n    let data = async {\n      let! v1 = s.data |> Async.AwaitFuture\n      let! v2 = s2.data |> Async.AwaitFuture\n      return zipAny v1 v2 }\n    series<obj,obj>.create(data, s.keyName, \"Values\", s.seriesName + \" and \" + s2.seriesName)\n\n  member s.joinInner<'v2>(s2:series<'k, 'v2>) : series<'k, TheGamma.General.pair<'v,'v2>> =\n    s.joinOuter(s2).choose(function Some(v1), Some(v2) -> Some(TheGamma.General.pair(v1, v2)) | _ -> None)\n\n  member s.appendScalar(key:'k, value:'v) =\n    s |> helpers.lift (fun arr -> Array.append arr [| key, value |])\n(*\n  member s.appendValue(key:'k, value:value<'v>) =\n    s.set(async {\n      let! arr = s.data\n      let! v = value.value\n      return Array.append arr [| key, v |] })\n*)\n  member s.append(s2:series<'k, 'v>) =\n    s.set(async {\n      let! arr1 = s.data |> Async.AwaitFuture\n      let! arr2 = s2.data |> Async.AwaitFuture\n      return Array.append arr1 arr2 } |> Async.StartAsFuture)\n\n  member s.count() =\n    s |> helpers.liftAggregation (fun arr -> arr.Length)\n\n  member s.last() =\n    s |> helpers.liftAggregation (fun arr -> snd arr.[arr.Length - 1])\n\n  member s.first() =\n    s |> helpers.liftAggregation (fun arr -> snd arr.[0])\n\n  member s.sumBy(f:'v -> float) =\n    s |> helpers.liftAggregation (Array.sumBy (fun (k, v) -> f v))\n\n  member s.minBy(f) =\n    s |> helpers.liftAggregation (Array.minBy (fun (k, v) -> f v))\n\n  member s.maxBy(f) =\n    s |> helpers.liftAggregation (Array.maxBy (fun (k, v) -> f v))\n\n  member s.realign(newKeys:series<'k, 'v>, defaultValue) = \n    s |> helpers.asyncLift (fun arr -> async {\n      let! newKeys = newKeys.data |> Async.AwaitFuture\n      let newKeys = newKeys |> Array.map (fun (k, v) -> unbox<System.IComparable> v)\n      let lookup = Map.ofArray (unbox<(System.IComparable * 'v)[]> arr)\n      return newKeys |> Array.map (fun k ->\n        match lookup.TryFind k with\n        | Some res -> unbox<'k> k, res\n        | None -> unbox<'k> k, defaultValue) })\n\n  member s.preview() = s.take(10)\n      \ntype ``inline`` =\n  { value : ``val``<obj> }\n  static member create(value:``val``<'v>) =\n    { value = unbox value }\n  member i.show(outputId) = Async.StartImmediate <| async {\n    let! v = i.value.value\n    Fable.Import.Browser.document.getElementById(outputId).innerText <- string v }\n\n\n(*\nopen System.Runtime.CompilerServices\n\n[<Extension>]\ntype SeriesExtensions =\n  [<Extension>]\n  static member sum(s:series<'k, float>) =\n    s |> helpers.liftAggregation (Array.sumBy snd)\n\n  [<Extension>]\n  static member series(values:seq<'v>) =\n    let getKey i (v:'v) =\n      let name = getProperty<string> v \"name\"\n      let id = getProperty<string> v \"id\"\n      if not (isNull name) then name\n        elif not (isNull id) then id\n          else string i\n    let data = async { return values |> Array.ofSeq |> Array.mapi (fun i v -> getKey i v, v) }\n    series.create(data, \"Key\", \"Value\", \"Series\")\n\n  [<Extension>]\n  static member series(values:list<'v>) =\n     SeriesExtensions.series(values :> seq<_>)\n[<Extension>]\ntype ListExtensions =\n  [<Extension>]\n  static member map(list, f) = List.map f list\n\n[<Extension>]\ntype TupleExtensions =\n  [<Extension>]\n  static member map((a,b), f) = (f a, f b)\n  [<Extension>]\n  static member map((a,b,c), f) = (f a, f b, f c)\n  [<Extension>]\n  static member map((a,b,c,d), f) = (f a, f b, f c, f d)\n  [<Extension>]\n  static member map((a,b,c,d,e), f) = (f a, f b, f c, f d, f e)\n  [<Extension>]\n  static member map((a,b,c,d,e,g), f) = (f a, f b, f c, f d, f e, f g)\n  [<Extension>]\n  static member map((a,b,c,d,e,g,h), f) = (f a, f b, f c, f d, f e, f g, f h)\n  *)","﻿// --------------------------------------------------------------------------------------------------------------------\n// Google chart API\n// --------------------------------------------------------------------------------------------------------------------\nnamespace TheGamma.GoogleCharts\n\nopen TheGamma.Common\nopen TheGamma.Series\nopen Fable.Core\nopen Fable.Import\n\nmodule GoogleCharts = \n  type DataTable =\n    abstract addRows : obj[][] -> unit\n    abstract addColumn : string * string -> unit \n    \n  [<Emit(\"new google.visualization.DataTable()\")>]\n  let createTable() : DataTable = failwith \"Never\"\n\n\ntype ChartData =\n  { data : Async<GoogleCharts.DataTable> }\n\ntype Chart = interface end\n\nmodule LazyCharting = \n  let chartsToDraw = ResizeArray<_>()\n  let mutable googleLoaded = false\n\n  let drawChartOnLoad f = \n    if googleLoaded then f()\n    else chartsToDraw.Add(f)\n\n  [<Emit(\"\"\"\n    if (typeof google != \"undefined\")\n      google.load('visualization', '1', { 'packages': ['corechart'], 'callback': function() { $0(); } });\n  \"\"\")>]\n  let initGoogle (f:unit -> unit) : unit = failwith \"JS\"\n\n  do initGoogle (fun () ->\n    googleLoaded <- true\n    for f in chartsToDraw do f() )\n\n  [<Emit(\"\"\"\n    var ctor = eval(\"(function(a) { return new google.visualization.\" + $0.typeName + \" (a); })\");\n    var ch = ctor(document.getElementById($2));\n    if ($0.options.height == undefined) $0.options.height = 400;\n    ch.draw($1, $0.options);\"\"\")>]\n  let drawChart (chart:#Chart) (data:GoogleCharts.DataTable) (id:string) : unit = failwith \"JS\"\n\nmodule Helpers =\n\n  [<Emit(\"undefined\")>]\n  let undefined<'T>() : 'T = failwith \"!\"\n\n  [<Emit(\"$0==null\")>]\n  let isNull(o:obj) : bool = failwith \"never\"\n\n  [<Emit(\"$0[$1]\")>]\n  let getProperty<'T> (obj:obj) (name:string) : 'T = failwith \"never\"\n\n  let copy o prop =\n    if isNull o then undefined<_>() else getProperty o prop\n\n  let orDefault newValue =\n    match newValue with\n    | Some a -> a\n    | _ -> undefined<_>()\n\n  let right o prop newValue =\n    match newValue with\n    | Some a -> a\n    | _ when isNull o -> undefined<_>()\n    | _ -> getProperty o prop\n\n  let showChart (chart:#Chart) (outputId:string) =\n    LazyCharting.drawChartOnLoad(fun () ->\n      async {\n        try\n          let! dt = (getProperty<ChartData> chart \"data\").data\n          LazyCharting.drawChart chart dt outputId \n        with e ->\n          Log.error(\"google\", \"Error when getting data or rendering chart: %O\", e) }\n        |> Async.StartImmediate)\n\nmodule ChartDataOperations =\n  let rec collect f l = async {\n    match l with \n    | x::xs -> \n        let! y = f x\n        let! ys = collect f xs\n        return List.append y ys\n    | [] -> return [] }\n\n  let oneKeyValue keyType (v:series<'k, float>) = { data = async {\n    let data = GoogleCharts.createTable()\n    data.addColumn(keyType, v.keyName) |> ignore\n    data.addColumn(\"number\", v.seriesName) |> ignore\n    let! vals = v.mapPairs(fun k v -> [| box k; box v |]).data |> Async.AwaitFuture\n    vals |> Array.map snd |> data.addRows |> ignore\n    return data } }\n\n  let oneKeyTwoValues keyType (v:series<'k, float * float>) = { data = async {\n    let data = GoogleCharts.createTable()\n    data.addColumn(keyType, v.keyName) |> ignore\n    data.addColumn(\"number\", v.seriesName) |> ignore\n    data.addColumn(\"number\", v.seriesName) |> ignore\n    let! vals = v.mapPairs(fun k (v1, v2) -> [| box k; box v1; box v2 |]).data |> Async.AwaitFuture\n    vals |> Array.map snd |> data.addRows |> ignore\n    return data } }\n\n  let oneKeyAppendValues keyType (vs:series<'k, float>[]) colors = { data = async {\n    let data = GoogleCharts.createTable()\n    data.addColumn(keyType, vs.[0].keyName) |> ignore\n    data.addColumn(\"number\", vs.[0].valueName) |> ignore\n    JsInterop.(?) data \"addColumn\" (JsInterop.createObj [ \"type\", box \"string\"; \"role\", box \"style\" ]) |> ignore    \n    let! all = Array.zip vs colors |> List.ofArray |> collect (fun (v, clr) -> async {\n      let! res = v.mapPairs(fun k v -> k, v, clr).data |> Async.AwaitFuture\n      return res |> Array.map snd |> List.ofArray })\n\n    all \n    |> List.sortByDescending (fun (_, v, _) -> v) |> Array.ofList\n    |> Array.map (fun (k, v, c) -> [| box k; box v; box c |])\n    |> data.addRows \n\n    return data } }\n\n(*\n  let oneKeyNValues keyType (v:seq<series<'k, float>>) = { data = async {\n    let data = GoogleCharts.createTable()\n    let v = Array.ofSeq v\n    data.addColumn(keyType, v.[0].keyName) |> ignore\n    for i in 0 .. v.Length - 1 do\n      data.addColumn(\"number\", v.[i].seriesName) |> ignore\n\n    let head = v.[0].map(fun v -> Map.ofList [0,v])\n    let tail = SeriesInternals.slice 1 (v.Length-1) v |> Array.mapi (fun i v -> i+1, v)\n    let all = (head,tail) ||> Array.fold (fun s1 (i, s2) ->\n      s1.joinOuter(s2).map(fun (l, r) ->\n        match defaultArg l Map.empty, r with\n        | lm, Some r -> Map.add i r lm\n        | lm, None -> lm ))\n\n    let! vals = all.mapPairs(fun k vals ->\n      let data = Array.init v.Length (fun i -> box (defaultArg (Map.tryFind i vals) (Helpers.undefined<_>())))\n      Array.append [| box k |] data).data\n    vals |> Array.map snd |> data.addRows |> ignore\n    return data } }\n*)\n  let oneKeyNValues keyType (v:series<'a, series<'k, float>>) = { data = async {\n    let data = GoogleCharts.createTable()\n    let! v = v.data |> Async.AwaitFuture\n    let v = Array.map snd v\n    data.addColumn(keyType, v.[0].keyName) |> ignore\n    for i in 0 .. v.Length - 1 do\n      data.addColumn(\"number\", v.[i].seriesName) |> ignore\n\n    let head = v.[0].map(fun v -> Map.ofList [0,v])\n    let tail = SeriesInternals.slice 1 (v.Length-1) v |> Array.mapi (fun i v -> i+1, v)\n    let all = (head,tail) ||> Array.fold (fun s1 (i, s2) ->\n      s1.joinOuter(s2).map(fun (l, r) ->\n        match defaultArg l Map.empty, r with\n        | lm, Some r -> Map.add i r lm\n        | lm, None -> lm ))\n\n    let! vals = all.mapPairs(fun k vals ->\n      let data = Array.init v.Length (fun i -> box (defaultArg (Map.tryFind i vals) (Helpers.undefined<_>())))\n      Array.append [| box k |] data).data |> Async.AwaitFuture\n    vals |> Array.map snd |> data.addRows |> ignore\n    return data } }\n\n  let twoValues (v1:series<'k, float>) (v2:series<'k,float>) = { data = async {\n    let data = GoogleCharts.createTable()\n    data.addColumn(\"number\", v1.seriesName) |> ignore\n    data.addColumn(\"number\", v2.seriesName) |> ignore\n    let! vals = v1.joinInner(v2).map(fun v -> [| box v.first; box v.second |]).data |> Async.AwaitFuture\n    vals |> Array.map snd |> data.addRows |> ignore\n    return data } }\n","﻿// --------------------------------------------------------------------------------------------------------------------\n// Google chart API \n// --------------------------------------------------------------------------------------------------------------------\n[<AutoOpen>]\nmodule TheGamma.GoogleCharts.Options\n\nopen System\n\ntype ChartSizeAxis = {\n    maxSize : float\n    maxValue : float\n    minSize : float\n    minValue : float\n}\n\ntype ChartTextStyle = {\n    fontName : string\n    fontSize : float\n    bold : bool\n    italic : bool\n    color : string\n    auraColor : string\n    opacity : float\n}\n\ntype ChartTooltip = {\n    isHtml : bool\n    showColorCode : bool\n    textStyle : ChartTextStyle\n    trigger : string\n}\n\ntype ChartLegend = {\n    alignment : string\n    maxLines : float\n    position : string\n    textStyle : ChartTextStyle\n    numberFormat : string\n}\n\ntype ChartColorAxis = {\n    minValue : float\n    maxValue : float\n    values : float[]\n    colors : string[]\n    legend : ChartLegend\n}\n\ntype GeoChartMagnifyingGlass = {\n    enable : bool\n    zoomFactor : float\n}\n\ntype GeoChartOptions = {\n    backgroundColor : obj\n    colorAxis : ChartColorAxis\n    datalessRegionColor : string\n    displayMode : string\n    enableRegionInteractivity : bool\n    height : float\n    keepAspectRatio : bool\n    legend : ChartLegend\n    region : string\n    magnifyingGlass : GeoChartMagnifyingGlass\n    markerOpacity : float\n    resolution : string\n    sizeAxis : ChartSizeAxis\n    tooltip : ChartTooltip\n    width : float\n}\n\ntype ChartBoxStyleGradient = {\n    color1: string\n    color2: string\n    x1: string\n    y1: string\n    x2: string\n    y2: string\n    useObjectBoundingBoxUnits : bool\n}\ntype ChartBoxStyle = {\n    stroke : string\n    strokeWidth : float\n    rx : float\n    ry : float\n    gradient : ChartBoxStyleGradient\n}\n\ntype ChartAnnotations = {\n    boxStyle : ChartBoxStyle\n    textStyle : ChartTextStyle\n}\n\ntype ChartCrosshairFocused = {\n    color : string\n    opacity : float\n}\ntype ChartCrosshairSelected = {\n    color : string\n    opacity : float\n}\ntype ChartCrosshair = {\n    color : string\n    focused : ChartCrosshairFocused\n    opacity : float\n    orientation : string\n    selected : ChartCrosshairSelected \n    trigger : string\n}\n\ntype ChartExplorer = {\n    actions : string[]\n    axis : string\n    keepInBounds : bool\n    maxZoomIn : float\n    maxZoomOut : float\n    zoomDelta : float\n}\n\ntype ChartStroke = {\n    stroke: string\n    strokeWidth: float\n    fill: string\n}\n\ntype ChartArea = {\n    top : obj\n    left : obj\n    width : obj\n    height : obj\n}\n\n\ntype TransitionAnimation = {\n    duration : float\n    easing : string // linear, in, out, inAndOut\n}\n\ntype ChartGridlines = {\n    color : string\n    count : float\n}\n\ntype ChartViewWindow = {\n    max : float\n    min : float\n}\n\ntype ChartAxis = {\n    baseline : float // This option is only supported for a continuous axis. https://google-developers.appspot.com/chart/interactive/docs/customizing_axes#Terminology\n    baselineColor : string // google's documentation on this is wrong, specifies it as a number. The color of the baseline for the horizontal axis. Can be obj HTML color string, for example: 'red' or '#00cc00'\n    direction : float // The direction in which the values along the horizontal axis grow. Specify -1 to reverse the order of the values.\n    format : string // icu pattern set http://icu-project.org/apiref/icu4c/classDecimalFormat.html#_details\n    gridlines : ChartGridlines\n    minorGridlines : ChartGridlines\n    logScale : bool\n    textPosition : string\n    textStyle : ChartTextStyle\n    ticks : obj[]\n    title : string\n    titleTextStyle : ChartTextStyle\n    allowContainerBoundaryTextCufoff : bool\n    slantedText : bool\n    slantedTextAngle : float\n    maxAlternation : float\n    maxTextLines : float\n    minTextSpacing : float\n    showTextEvery : float\n    maxValue : float\n    minValue : float\n    viewWindowMode : string\n    viewWindow : ChartViewWindow\n}\n\ntype ChartBoundingBox = {\n    left: float\n    top: float\n    width: float\n    height: float\n}\n\ntype GroupWidth = {\n    groupWidth: obj // number | string\n}\n\ntype Trendline = {\n    color: string\n    lineWidth: float\n    labelInLegend : string\n    opacity: float\n    pointSize: float \n    pointsVisible: bool\n    showR2 : bool\n    ``type``: string\n    visibleInLegend: float\n}\n\ntype ScatterChartOptions = {\n    aggregationTarget : string\n    animation : TransitionAnimation\n    annotations : ChartAnnotations\n    axisTitlesPosition : string // in, out, none\n    backgroundColor : obj\n    chartArea : ChartArea\n    colors : string[]\n    crosshair : ChartCrosshair\n    curveType : string\n    dataOpacity : float\n    enableInteractivity : bool\n    explorer : ChartExplorer\n    fontSize : float\n    fontName : string\n    forceIFrame : bool\n    hAxis : ChartAxis\n    height : float\n    legend : ChartLegend\n    lineWidth : float\n    pointSize : float\n    selectionMode : string\n    series : obj\n    theme : string\n    title : string\n    titlePosition : string\n    titleTextStyle : ChartTextStyle\n    tooltip : ChartTooltip\n    trendlines : Trendline[]\n    vAxis : ChartAxis\n    width : float\n}\n\ntype ColumnChartOptions = {\n    aggregationTarget : string\n    animation : TransitionAnimation\n    annotations : ChartAnnotations\n    axisTitlesPosition : string // in, out, none\n    backgroundColor : obj\n    bar : GroupWidth\n    chartArea : ChartArea\n    colors : string[]\n    enableInteractivity : bool\n    focusTarget : string\n    fontSize : float\n    fontName : string\n    hAxis : ChartAxis\n    height : float\n    isStacked : bool\n    legend : ChartLegend\n    reverseCategories : bool\n    selectionMode : string // single / multiple\n    series : obj\n    theme : string\n    title : string\n    titlePosition : string\n    titleTextStyle : ChartTextStyle\n    tooltip : ChartTooltip\n    vAxes : obj\n    vAxis : ChartAxis\n    width : float\n}\n\ntype LineChartOptions = {\n    aggregationTarget : string\n    animation : TransitionAnimation\n    annotations : ChartAnnotations\n    axisTitlesPosition : string\n    backgroundColor : obj\n    chartArea : ChartArea\n    colors : string[]\n    crosshair : ChartCrosshair\n    curveType : string\n    dataOpacity : float\n    enableInteractivity : bool\n    explorer : ChartExplorer\n    focusTarget : string\n    fontSize : float\n    fontName : string\n    hAxis : ChartAxis\n    height : float\n    interpolateNulls : bool\n    legend : ChartLegend\n    lineWidth : float\n    orientation : string\n    pointSize : float\n    reverseCategories : bool\n    selectionMode : string // single / multiple\n    series : obj\n    theme : string\n    title : string\n    titlePosition : string\n    titleTextStyle : ChartTextStyle\n    tooltip : ChartTooltip\n    vAxes : obj\n    vAxis : ChartAxis\n    width : float\n}\n\ntype BarChartOptions = {\n    aggregationTarget : string\n    animation : TransitionAnimation\n    annotations : ChartAnnotations\n    axisTitlesPosition : string // in, out, none\n    backgroundColor : obj\n    bar : GroupWidth\n    chartArea : ChartArea\n    colors : string[]\n    dataOpacity : float\n    enableInteractivity : bool\n    focusTarget : string\n    fontSize : float\n    fontName : string\n    hAxes : obj\n    hAxis : ChartAxis\n    height : float\n    isStacked : bool\n    legend : ChartLegend\n    reverseCategories : bool\n    series : obj\n    theme : string\n    title : string\n    titlePosition : string\n    titleTextStyle : ChartTextStyle\n    tooltip : ChartTooltip\n    vAxes : obj\n    vAxis : ChartAxis\n    width : float\n}\n\ntype HistogramHistogram = {\n    bucketSize : float\n    hideBucketItems : bool\n    lastBucketPercentile : float\n}\n\ntype HistogramOptions = {\n    animation : TransitionAnimation\n    axisTitlesPosition : string // in, out, none\n    backgroundColor : obj\n    bar : GroupWidth\n    chartArea : ChartArea\n    colors : string[]\n    dataOpacity : float\n    enableInteractivity : bool\n    focusTarget : string\n    fontSize : float\n    fontName : string\n    hAxis : ChartAxis\n    histogram : HistogramHistogram\n    height : float\n    interpolateNulls : bool\n    isStacked : bool\n    legend : ChartLegend\n    orientation : string\n    reverseCategories : bool\n    series : obj\n    theme : string\n    title : string\n    titlePosition : string\n    titleTextStyle : ChartTextStyle\n    tooltip : ChartTooltip\n    vAxes : obj\n    vAxis : ChartAxis\n    width : float\n}\n\ntype AreaChartOptions = {\n    aggregationTarget : string\n    animation : TransitionAnimation\n    areaOpacity : float\n    axisTitlesPosition : string\n    backgroundColor : obj\n    chartArea : ChartArea\n    colors : string[]\n    crosshair : ChartCrosshair\n    dataOpacity : float\n    enableInteractivity : bool\n    explorer : ChartExplorer\n    focusTarget : string\n    fontSize : float\n    fontName : string\n    hAxis : ChartAxis\n    height : float\n    interpolateNulls : bool\n    isStacked : bool\n    legend : ChartLegend\n    lineWidth : float\n    orientation : string\n    pointSize : float\n    reverseCategories : bool\n    selectionMode : string // single / multiple\n    series : obj\n    theme : string\n    title : string\n    titlePosition : string\n    titleTextStyle : ChartTextStyle\n    tooltip : ChartTooltip\n    vAxes : obj\n    vAxis : ChartAxis\n    width : float\n}\n\ntype AnnotationChartOptions = {\n    allowHtml : bool\n    allValuesSuffix : string\n    annotationsWidth : float\n    colors : string[]\n    dateFormat : string\n    displayAnnotations : bool\n    displayAnnotationsFilter : bool\n    displayDateTimeBarSeparator : bool\n    displayExactValues : bool\n    displayLegendDots : bool\n    displayLegendValues : bool\n    displayRangeSelector : bool\n    displayZoomButtons : bool\n    fill : float\n    legendPosition : string\n    max : float\n    min : float\n    numberFormats : obj\n    scaleColumns : float[]\n    scaleFormat : string\n    scaleType : string\n    thickness : float\n    zoomEndTime : DateTime\n    zoomStartTime : DateTime\n}\n\ntype SteppedAreaChartOptions = {\n    aggregationTarget : string\n    animation : TransitionAnimation\n    areaOpacity : float\n    axisTitlesPosition : string\n    backgroundColor : obj\n    chartArea : ChartArea\n    colors : string[]\n    connectSteps : bool\n    enableInteractivity : bool\n    focusTarget : string\n    fontSize : float\n    fontName : string\n    hAxis : ChartAxis\n    height : float\n    interpolateNulls : bool\n    isStacked : bool\n    legend : ChartLegend\n    reverseCategories : bool\n    selectionMode : string // single / multiple\n    series : obj\n    theme : string\n    title : string\n    titlePosition : string\n    titleTextStyle : ChartTextStyle\n    tooltip : ChartTooltip\n    vAxes : obj\n    vAxis : ChartAxis\n    width : float\n}\n\ntype PieChartOptions = {\n    backgroundColor : obj\n    chartArea : ChartArea\n    colors : string[]\n    enableInteractivity : bool\n    fontSize : float\n    fontName : string\n    height : float\n    is3D : bool\n    legend : ChartLegend\n    pieHole : float\n    pieSliceBorderColor : string\n    pieSliceText : string\n    pieSliceTextStyle : ChartTextStyle\n    pieStartAngle : float\n    reverseCategories : bool\n    pieResidueSliceColor : string\n    pieResidueSliceLabel : string\n    slices : obj\n    sliceVisibilityThreshold : float\n    title : string\n    titleTextStyle : ChartTextStyle\n    tooltip : ChartTooltip\n    width : float\n}\n\ntype ChartBubble = {\n    opacity : float\n    stroke : string\n    textStyle : ChartTextStyle\n}\n\ntype BubbleChartOptions = {\n    animation : TransitionAnimation\n    axisTitlesPosition : string // in, out, none\n    backgroundColor : obj\n    bubble : ChartBubble\n    chartArea : ChartArea\n    colors : string[]\n    colorAxis : ChartColorAxis\n    enableInteractivity : bool\n    explorer : ChartExplorer\n    fontSize : float\n    fontName : string\n    forceIFrame : bool\n    hAxis : ChartAxis\n    height : float\n    legend : ChartLegend\n    selectionMode : string\n    series : obj\n    sizeAxis : ChartSizeAxis\n    sortBubblesBySize : bool\n    theme : string\n    title : string\n    titlePosition : string\n    titleTextStyle : ChartTextStyle\n    tooltip : ChartTooltip\n    vAxis : ChartAxis\n    width : float\n}\n\ntype TreeMapOptions = {\n    fontColor : string\n    fontFamily : string\n    fontSize : float\n    forceIFrame : bool\n    headerColor : string\n    headerHeight : float\n    headerHighlightColor : string\n    hintOpacity : float\n    maxColor : string\n    maxDepth : float\n    maxHighlightColor : string\n    maxPostDepth : float\n    maxColorValue : float\n    midColor : string\n    midHighlightColor : string\n    minColor : string\n    minHighlightColor : string\n    minColorValue : float\n    showScale : bool\n    showTooltips : bool\n    textStyle : ChartTextStyle\n    title : string\n    titleTextStyle : ChartTextStyle\n    useWeightedAverageForAggregation : bool\n}\n\ntype CssClassNames = {\n    headerRow : string\n    tableRow : string\n    oddTableRow : string\n    selectedTableRow : string\n    hoverTableRow : string\n    headerCell : string\n    tableCell : string\n    rowNumberCell : string\n}\n\ntype TableOptions = {\n    allowHtml : bool\n    alternatingRowStyle : bool\n    cssClassName : CssClassNames\n    firstRowNumber : float\n    height : string\n    page : string\n    pageSize : float\n    rtlTable : bool\n    scrollLeftStartPosition : float\n    showRowNumber : bool\n    sort : string\n    sortAscending : bool\n    sortColumn : float\n    startPage : float\n    width : string\n}\n\ntype LabelStyle = {\n    color: string\n    fontName: string\n    fontSize: string\n}\n\ntype TimelineTimeline = {\n    barLabelStyle : LabelStyle\n    colorByRowLabel : bool\n    groupByRowLabel : bool\n    rowLabelStyle : LabelStyle\n    showRowLabels : bool\n    singleColor : string\n}\n\ntype TimelineOptions = {\n    avoidOverlappingGridLines : bool\n    backgroundColor : obj\n    colors : string[]\n    enableInteractivity : bool\n    forceIFrame : bool\n    height : float\n    timeline : TimelineTimeline\n    width : float\n}\n\ntype CandlestickCandlestick = {\n    hollowIsRising : bool\n    fallingColor : ChartStroke\n    risingColor : ChartStroke\n}\n\ntype CandlestickChartOptions = {\n    aggregationTarget : string\n    animation : TransitionAnimation\n    axisTitlesPosition : string\n    backgroundColor : obj\n    bar : GroupWidth\n    candlestick : CandlestickCandlestick\n    chartArea : ChartArea\n    colors : string[]\n    enableInteractivity : bool\n    focusTarget : string\n    fontSize : float\n    fontName : string\n    hAxis : ChartAxis\n    height : float\n    legend : ChartLegend\n    orientation : string\n    reverseCategories : bool\n    selectionMode : string // single / multiple\n    series : obj\n    theme : string\n    title : string\n    titlePosition : string\n    titleTextStyle : ChartTextStyle\n    tooltip : ChartTooltip\n    vAxes : obj\n    vAxis : ChartAxis\n    width : float\n}\n    ","namespace TheGamma.GoogleCharts\n\nopen System\nopen TheGamma\nopen TheGamma.Series\nopen TheGamma.GoogleCharts\n\ntype chart =\n  static member scatter(xval:series<_, _>, yval:series<_, _>) = \n    { Scatter.data = ChartDataOperations.twoValues xval yval; \n      typeName = \"ScatterChart\"; options = ScatterChartOptions.empty }\n\n  static member geo(data:series<string, float>) = \n    { Geo.data = ChartDataOperations.oneKeyValue \"string\" data; \n      typeName = \"GeoChart\"; options = GeoChartOptions.empty }\n  (*\n  static member geo(data:series<string, float * float>) = \n    { Geo.data = ChartDataOperations.oneKeyTwoValues \"string\" data; \n      typeName = \"GeoChart\"; options = GeoChartOptions.empty }\n  *)\n  static member pie(data:series<string, float>) = \n    { Pie.data = ChartDataOperations.oneKeyValue \"string\" data; \n      typeName = \"PieChart\"; options = PieChartOptions.empty }\n\n  static member bar(data:series<string, float>) = \n    { Bar.data = ChartDataOperations.oneKeyValue \"string\" data; \n      typeName = \"BarChart\"; options = BarChartOptions.empty }\n  (*\n  static member bar(data:seq<series<string, float>>) = \n    { Bar.data = ChartDataOperations.oneKeyNValues \"string\" data; \n      typeName = \"BarChart\"; options = BarChartOptions.empty }\n  static member column(data:seq<series<string, float>>) = \n    { Column.data = ChartDataOperations.oneKeyNValues \"string\" data; \n      typeName = \"ColumnChart\"; options = ColumnChartOptions.empty }\n  *)\n  static member column(data:series<string, float>) = \n    { Column.data = ChartDataOperations.oneKeyValue \"string\" data; \n      typeName = \"ColumnChart\"; options = ColumnChartOptions.empty }\n\n  static member columns(data:series<string, float>[], colors:string[]) = \n    { Line.data = ChartDataOperations.oneKeyAppendValues \"string\" data colors; \n      typeName = \"ColumnChart\"; options = LineChartOptions.empty }\n\n  static member line(data:series<int, float>) = \n    { Line.data = ChartDataOperations.oneKeyValue \"number\" data; \n      typeName = \"LineChart\"; options = LineChartOptions.empty }\n\n  static member lines(data:series<'a, series<'b, float>>) = \n    { Line.data = ChartDataOperations.oneKeyNValues \"number\" data; \n      typeName = \"LineChart\"; options = LineChartOptions.empty }\n(*\n  static member line(data:series<string, float>) = \n    { Line.data = ChartDataOperations.oneKeyValue \"string\" data; \n      typeName = \"LineChart\"; options = LineChartOptions.empty }\n  static member line(data:seq<series<string, float>>) = \n    { Line.data = ChartDataOperations.oneKeyNValues \"string\" data; \n      typeName = \"LineChart\"; options = LineChartOptions.empty }\n  static member line(data:seq<series<int, float>>) = \n    { Line.data = ChartDataOperations.oneKeyNValues \"number\" data; \n      typeName = \"LineChart\"; options = LineChartOptions.empty }\n*)\n(*\n  static member histogram(data) = \n    { Histogram.data = data; options = HistogramOptions.empty }\n*)\n  static member area(data:series<int, float>) = \n    { Area.data = ChartDataOperations.oneKeyValue \"number\" data; \n      typeName = \"AreaChart\"; options = AreaChartOptions.empty }\n\n  static member areas(data:series<'a, series<int, float>>, ?names:string[]) = \n    let i = ref 0;\n    let data = \n      match names with \n      | Some names -> data.map(fun s -> incr i; s.setProperties(seriesName=names.[i.Value-1]))\n      | None -> data\n    { Area.data = ChartDataOperations.oneKeyNValues \"number\" data; \n      typeName = \"AreaChart\"; options = AreaChartOptions.empty }\n(*\n  static member annotation(data) = \n    { Annotation.data = data; options = AnnotationChartOptions.empty }\n  static member steppedArea(data) = \n    { SteppedArea.data = data; options = SteppedAreaChartOptions.empty }\n  static member bubble(data) = \n    { Bubble.data = data; options = BubbleChartOptions.empty }\n  static member treeMap(data) = \n    { TreeMap.data = data; options = TreeMapOptions.empty }\n  static member table(data) = \n    { Table.data = data; options = TableOptions.empty }\n  static member timeline(data) = \n    { Timeline.data = data; options = TimelineOptions.empty }\n  static member candlestick(data) = \n    { Candlestick.data = data; options = CandlestickChartOptions.empty }\n*)\n\n  static member show(chart:#Chart) = \n    Helpers.showChart(chart)","module.exports = \"2\"\n","\"use strict\";\n\nmodule.exports = function isObject(x) {\n\treturn typeof x === \"object\" && x !== null;\n};\n","var diff = require(\"./vtree/diff.js\")\n\nmodule.exports = diff\n","var Document = require('./document.js');\n\nmodule.exports = new Document();\n","var topLevel = typeof global !== 'undefined' ? global :\n    typeof window !== 'undefined' ? window : {}\nvar minDoc = require('min-document');\n\nvar doccy;\n\nif (typeof document !== 'undefined') {\n    doccy = document;\n} else {\n    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];\n\n    if (!doccy) {\n        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;\n    }\n}\n\nmodule.exports = doccy;\n","var patch = require(\"./vdom/patch.js\")\n\nmodule.exports = patch\n","/*!\n * Cross-Browser Split 1.1.1\n * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>\n * Available under the MIT License\n * ECMAScript compliant, uniform cross-browser split method\n */\n\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * split('a b c d', ' ');\n * // -> ['a', 'b', 'c', 'd']\n *\n * // With limit\n * split('a b c d', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * split('..word1 word2..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', ' ', 'word', '2', '..']\n */\nmodule.exports = (function split(undef) {\n\n  var nativeSplit = String.prototype.split,\n    compliantExecNpcg = /()??/.exec(\"\")[1] === undef,\n    // NPCG: nonparticipating capturing group\n    self;\n\n  self = function(str, separator, limit) {\n    // If `separator` is not a regex, use `nativeSplit`\n    if (Object.prototype.toString.call(separator) !== \"[object RegExp]\") {\n      return nativeSplit.call(str, separator, limit);\n    }\n    var output = [],\n      flags = (separator.ignoreCase ? \"i\" : \"\") + (separator.multiline ? \"m\" : \"\") + (separator.extended ? \"x\" : \"\") + // Proposed for ES6\n      (separator.sticky ? \"y\" : \"\"),\n      // Firefox 3+\n      lastLastIndex = 0,\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      separator = new RegExp(separator.source, flags + \"g\"),\n      separator2, match, lastIndex, lastLength;\n    str += \"\"; // Type-convert\n    if (!compliantExecNpcg) {\n      // Doesn't need flags gy, but they don't hurt\n      separator2 = new RegExp(\"^\" + separator.source + \"$(?!\\\\s)\", flags);\n    }\n    /* Values for `limit`, per the spec:\n     * If undefined: 4294967295 // Math.pow(2, 32) - 1\n     * If 0, Infinity, or NaN: 0\n     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\n     * If negative number: 4294967296 - Math.floor(Math.abs(limit))\n     * If other: Type-convert, then use the above rules\n     */\n    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1\n    limit >>> 0; // ToUint32(limit)\n    while (match = separator.exec(str)) {\n      // `separator.lastIndex` is not reliable cross-browser\n      lastIndex = match.index + match[0].length;\n      if (lastIndex > lastLastIndex) {\n        output.push(str.slice(lastLastIndex, match.index));\n        // Fix browsers whose `exec` methods don't consistently return `undefined` for\n        // nonparticipating capturing groups\n        if (!compliantExecNpcg && match.length > 1) {\n          match[0].replace(separator2, function() {\n            for (var i = 1; i < arguments.length - 2; i++) {\n              if (arguments[i] === undef) {\n                match[i] = undef;\n              }\n            }\n          });\n        }\n        if (match.length > 1 && match.index < str.length) {\n          Array.prototype.push.apply(output, match.slice(1));\n        }\n        lastLength = match[0].length;\n        lastLastIndex = lastIndex;\n        if (output.length >= limit) {\n          break;\n        }\n      }\n      if (separator.lastIndex === match.index) {\n        separator.lastIndex++; // Avoid an infinite loop\n      }\n    }\n    if (lastLastIndex === str.length) {\n      if (lastLength || !separator.test(\"\")) {\n        output.push(\"\");\n      }\n    } else {\n      output.push(str.slice(lastLastIndex));\n    }\n    return output.length > limit ? output.slice(0, limit) : output;\n  };\n\n  return self;\n})();\n","var h = require(\"./virtual-hyperscript/index.js\")\n\nmodule.exports = h\n","var createElement = require(\"./vdom/create-element.js\")\n\nmodule.exports = createElement\n","var diff = require(\"./diff.js\")\r\nvar patch = require(\"./patch.js\")\r\nvar h = require(\"./h.js\")\r\nvar create = require(\"./create-element.js\")\r\nvar VNode = require('./vnode/vnode.js')\r\nvar VText = require('./vnode/vtext.js')\r\n\r\nmodule.exports = {\r\n    diff: diff,\r\n    patch: patch,\r\n    h: h,\r\n    create: create,\r\n    VNode: VNode,\r\n    VText: VText\r\n}\r\n","import { createDisposable } from \"./Util\";\r\nimport { iterate as seqIterate } from \"./Seq\";\r\nimport { Observer } from \"./Observable\";\r\nimport { protect } from \"./Observable\";\r\nvar Event = (function () {\r\n    function Event(_subscriber, delegates) {\r\n        this._subscriber = _subscriber;\r\n        this.delegates = delegates || new Array();\r\n    }\r\n    Event.prototype.Add = function (f) {\r\n        this._addHandler(f);\r\n    };\r\n    Object.defineProperty(Event.prototype, \"Publish\", {\r\n        get: function () {\r\n            return this;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Event.prototype.Trigger = function (value) {\r\n        seqIterate(function (f) { return f(value); }, this.delegates);\r\n    };\r\n    Event.prototype._addHandler = function (f) {\r\n        this.delegates.push(f);\r\n    };\r\n    Event.prototype._removeHandler = function (f) {\r\n        var index = this.delegates.indexOf(f);\r\n        if (index > -1)\r\n            this.delegates.splice(index, 1);\r\n    };\r\n    Event.prototype.AddHandler = function (handler) {\r\n        if (this._dotnetDelegates == null) {\r\n            this._dotnetDelegates = new Map();\r\n        }\r\n        var f = function (x) { handler(null, x); };\r\n        this._dotnetDelegates.set(handler, f);\r\n        this._addHandler(f);\r\n    };\r\n    Event.prototype.RemoveHandler = function (handler) {\r\n        if (this._dotnetDelegates != null) {\r\n            var f = this._dotnetDelegates.get(handler);\r\n            if (f != null) {\r\n                this._dotnetDelegates.delete(handler);\r\n                this._removeHandler(f);\r\n            }\r\n        }\r\n    };\r\n    Event.prototype._subscribeFromObserver = function (observer) {\r\n        var _this = this;\r\n        if (this._subscriber)\r\n            return this._subscriber(observer);\r\n        var callback = observer.OnNext;\r\n        this._addHandler(callback);\r\n        return createDisposable(function () { return _this._removeHandler(callback); });\r\n    };\r\n    Event.prototype._subscribeFromCallback = function (callback) {\r\n        var _this = this;\r\n        this._addHandler(callback);\r\n        return createDisposable(function () { return _this._removeHandler(callback); });\r\n    };\r\n    Event.prototype.Subscribe = function (arg) {\r\n        return typeof arg == \"function\"\r\n            ? this._subscribeFromCallback(arg)\r\n            : this._subscribeFromObserver(arg);\r\n    };\r\n    return Event;\r\n}());\r\nexport default Event;\r\nexport function add(callback, sourceEvent) {\r\n    sourceEvent.Subscribe(new Observer(callback));\r\n}\r\nexport function choose(chooser, sourceEvent) {\r\n    var source = sourceEvent;\r\n    return new Event(function (observer) {\r\n        return source.Subscribe(new Observer(function (t) {\r\n            return protect(function () { return chooser(t); }, function (u) { if (u != null)\r\n                observer.OnNext(u); }, observer.OnError);\r\n        }, observer.OnError, observer.OnCompleted));\r\n    }, source.delegates);\r\n}\r\nexport function filter(predicate, sourceEvent) {\r\n    return choose(function (x) { return predicate(x) ? x : null; }, sourceEvent);\r\n}\r\nexport function map(mapping, sourceEvent) {\r\n    var source = sourceEvent;\r\n    return new Event(function (observer) {\r\n        return source.Subscribe(new Observer(function (t) {\r\n            return protect(function () { return mapping(t); }, observer.OnNext, observer.OnError);\r\n        }, observer.OnError, observer.OnCompleted));\r\n    }, source.delegates);\r\n}\r\nexport function merge(event1, event2) {\r\n    var source1 = event1;\r\n    var source2 = event2;\r\n    return new Event(function (observer) {\r\n        var stopped = false, completed1 = false, completed2 = false;\r\n        var h1 = source1.Subscribe(new Observer(function (v) { if (!stopped)\r\n            observer.OnNext(v); }, function (e) {\r\n            if (!stopped) {\r\n                stopped = true;\r\n                observer.OnError(e);\r\n            }\r\n        }, function () {\r\n            if (!stopped) {\r\n                completed1 = true;\r\n                if (completed2) {\r\n                    stopped = true;\r\n                    observer.OnCompleted();\r\n                }\r\n            }\r\n        }));\r\n        var h2 = source2.Subscribe(new Observer(function (v) { if (!stopped)\r\n            observer.OnNext(v); }, function (e) {\r\n            if (!stopped) {\r\n                stopped = true;\r\n                observer.OnError(e);\r\n            }\r\n        }, function () {\r\n            if (!stopped) {\r\n                completed2 = true;\r\n                if (completed1) {\r\n                    stopped = true;\r\n                    observer.OnCompleted();\r\n                }\r\n            }\r\n        }));\r\n        return createDisposable(function () {\r\n            h1.Dispose();\r\n            h2.Dispose();\r\n        });\r\n    }, source1.delegates.concat(source2.delegates));\r\n}\r\nexport function pairwise(sourceEvent) {\r\n    var source = sourceEvent;\r\n    return new Event(function (observer) {\r\n        var last = null;\r\n        return source.Subscribe(new Observer(function (next) {\r\n            if (last != null)\r\n                observer.OnNext([last, next]);\r\n            last = next;\r\n        }, observer.OnError, observer.OnCompleted));\r\n    }, source.delegates);\r\n}\r\nexport function partition(predicate, sourceEvent) {\r\n    return [filter(predicate, sourceEvent), filter(function (x) { return !predicate(x); }, sourceEvent)];\r\n}\r\nexport function scan(collector, state, sourceEvent) {\r\n    var source = sourceEvent;\r\n    return new Event(function (observer) {\r\n        return source.Subscribe(new Observer(function (t) {\r\n            protect(function () { return collector(state, t); }, function (u) { state = u; observer.OnNext(u); }, observer.OnError);\r\n        }, observer.OnError, observer.OnCompleted));\r\n    }, source.delegates);\r\n}\r\nexport function split(splitter, sourceEvent) {\r\n    return [choose(function (v) { return splitter(v).valueIfChoice1; }, sourceEvent), choose(function (v) { return splitter(v).valueIfChoice2; }, sourceEvent)];\r\n}\r\n","namespace TheGamma\n\nopen System\nopen TheGamma\nopen TheGamma.Common\nopen TheGamma.Series\nopen TheGamma.Html\nopen Fable.Import.Browser\n\ntype Emit = Fable.Core.EmitAttribute\n\nopen TheGamma.Common.JsHelpers\n\ntype html =\n  static member img(url:string) = \n    box (h?img [ \"src\" => url ] [])\n\ntype list<'k,'v> =\n  { data : series<'k,'v> \n    listTag : string\n    elementTag : string\n    itemFormat : 'v -> obj }\n  member t.show(outputId) = Async.StartImmediate <| async {\n    let! vs = t.data.data |> Async.AwaitFuture\n    let els = [ for _, v in vs -> sprintf \"<%s>%s</%s>\" t.elementTag (string (t.itemFormat v)) t.elementTag ]\n    document.getElementById(outputId).innerHTML <-\n      sprintf \"<%s>%s</%s>\" t.listTag (String.concat \"\" els) t.listTag }\n  member t.setTags(list, element) = \n    { t with listTag = list; elementTag = element }\n  member t.setFormat(f:'v -> obj) = \n    { t with itemFormat = f }\n  static member create(data:series<_, _>) = \n    { data = data; listTag = \"ol\"; elementTag = \"li\"\n      itemFormat = fun o -> box o }\n\ntype table<'k,'v> =\n  { data : series<'k,'v>\n    showKey : bool option \n    emptyText : string\n    columnFormatters : Map<string, obj>\n    hiddenColumns : Set<string>\n    addedColumns : list<string * ('v -> obj)> }\n\n  static member create(data:series<_, _>) =\n    { table.data = data\n      emptyText = \"No data available\"\n      hiddenColumns = Set.empty\n      columnFormatters = Map.empty\n      addedColumns = []\n      showKey = None }\n\n  member t.set(?title:string, ?showKey:bool, ?emptyText) = \n    { table.data = t.data.set(t.data.data, seriesName=defaultArg title t.data.seriesName)\n      hiddenColumns = t.hiddenColumns\n      addedColumns = t.addedColumns\n      emptyText = defaultArg emptyText t.emptyText\n      columnFormatters = t.columnFormatters\n      showKey = match showKey with None -> t.showKey | sk -> sk }\n\n  member t.setFormat(column, formatter) = \n    { t with columnFormatters = t.columnFormatters.Add(column, formatter) }\n\n  member t.hideColumns(names:string[]) =\n    { t with hiddenColumns = Set.ofArray names }\n\n  member t.addColumn(name, f) =\n    { t with addedColumns = (name, f)::t.addedColumns }\n\n  member t.render() =\n    let row showKey (el:string) k (things:seq<DomNode>) =\n      let withTitle = function\n        | DomNode.Text s -> h?div [\"title\" => s] [text s]\n        | nd -> nd\n      h?tr [] [ \n        if showKey then yield h?(el) [] [ withTitle (text k) ]\n        for t in things -> h?(el) [] [ withTitle t ] \n      ]\n\n    let makeTable showKey k header body = \n      h?table [\"class\" => \"thegamma-table\"] [\n        if not (String.IsNullOrWhiteSpace t.data.seriesName) then\n          yield h?caption [] [ text t.data.seriesName ]\n        yield h?thead [] [ row showKey \"th\" k header ]\n        yield h?tbody [] body\n      ]\n\n    let formatAdded o = \n      // Did someone say hack..?\n      let isSeries = \n        [ for kv in properties o -> kv.key ] = \n          [\"data\"; \"keyName\"; \"valueName\"; \"seriesName\"]\n      if isSeries then\n        let mutable result = unbox null\n        (unbox<series<int, DomNode>> o).data.Then(fun r -> result <- r)\n        h?span [] (List.ofArray (Array.map snd result))\n      else text (o.ToString())\n\n    async {\n      try\n        let! vs = t.data.data |> Async.AwaitFuture\n        if vs.Length = 0 then\n          return h?div [\"class\" => \"placeholder\"] [ h?p [] [ text t.emptyText ] ]\n        else \n          let filteredProperties o =\n            properties o |> Array.filter (fun kv -> not (t.hiddenColumns.Contains kv.key))\n\n          let _, first = vs |> Seq.head\n          let headers = \n            [ if isObject first then for kv in filteredProperties first -> text kv.key\n              else yield text t.data.valueName \n              for k, _ in t.addedColumns -> text k ]\n          let showKey = match t.showKey with Some sk -> sk | _ -> not (isObject first)\n          return\n            [ for k, v in vs ->\n                let formattedVals =\n                  [ if isObject v then \n                      for kv in filteredProperties v do\n                        if t.columnFormatters.ContainsKey kv.key then yield text ((unbox<_ -> _> t.columnFormatters.[kv.key]) kv.value)\n                        elif isDate kv.value then yield text (formatDateTime kv.value)\n                        elif not (isNumber kv.value) then yield text (kv.value.ToString())\n                        elif isNaN (unbox kv.value) then yield text \"\"\n                        else yield text (niceNumber kv.value 2) \n                    elif isDate v then yield text (formatDateTime v)\n                    elif not (isNumber v) then yield text (v.ToString())\n                    elif isNaN (unbox v) then yield text \"\"\n                    else yield text (niceNumber v 2) \n                    for _, f in t.addedColumns -> formatAdded (f v) ] \n                row showKey \"td\" (unbox k) formattedVals ]\n            |> makeTable showKey t.data.keyName headers\n      with e ->\n        Log.exn(\"live\", \"Getting data for table failed: %O\", e) \n        return raise e }\n\n  member t.show(outputId) =\n    async { let! dom = t.render()\n            dom |> renderTo (document.getElementById(outputId)) }\n    |> Async.StartImmediate\n\ntype placeholder(message:string) =\n  static member create(message:string) = placeholder(message)\n  member x.show(outputId) =\n    h?div [\"class\" => \"placeholder\"] [ h?p [] [ text message ] ]\n    |> renderTo (document.getElementById(outputId))\n","// 20.2.2.21 Math.log10(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  log10: function log10(x) {\n    return Math.log(x) * Math.LOG10E;\n  }\n});\n","require('../../modules/es6.math.log10');\nmodule.exports = require('../../modules/_core').Math.log10;\n","module.exports = { \"default\": require(\"core-js/library/fn/math/log10\"), __esModule: true };","﻿namespace TheGamma.Interactive.Compost\n\nopen TheGamma\nopen TheGamma.Html\nopen Fable.Import.Browser\nopen Fable.Helpers\n\n// ------------------------------------------------------------------------------------------------\n// Domain that users see\n// ------------------------------------------------------------------------------------------------\n  \ntype Color =\n  | RGB of int * int * int\n  | HTML of string\n\ntype AlphaColor = float * Color \ntype Width = Pixels of int\ntype GradientStop = float * AlphaColor\n\ntype FillStyle =\n  | Solid of AlphaColor\n  | LinearGradient of seq<GradientStop>\n\ntype Number =\n  | Integer of int\n  | Percentage of float\n\ntype HorizontalAlign = Start | Center | End\ntype VerticalAlign = Baseline | Middle | Hanging\n\ntype continuous<[<Measure>] 'u> = CO of float<'u> \ntype categorical<[<Measure>] 'u> = CA of string\n\ntype Value<[<Measure>] 'u> = \n  | CAR of categorical<'u> * float\n  | COV of continuous<'u>\n\ntype Scale<[<Measure>] 'v> =\n  | Continuous of continuous<'v> * continuous<'v>\n  | Categorical of categorical<'v>[]\n\ntype Style = \n  { StrokeColor : AlphaColor\n    StrokeWidth : Width\n    StrokeDashArray : seq<Number>\n    Fill : FillStyle \n    Animation : option<int * string * (Style -> Style)>\n    Font : string\n    Cursor : string\n    FormatAxisXLabel : Scale<1> -> Value<1> -> string\n    FormatAxisYLabel : Scale<1> -> Value<1> -> string }\n\ntype EventHandler<[<Measure>] 'vx, [<Measure>] 'vy> = \n  | MouseMove of (MouseEvent -> (Value<'vx> * Value<'vy>) -> unit)\n  | MouseUp of (MouseEvent -> (Value<'vx> * Value<'vy>) -> unit)\n  | MouseDown of (MouseEvent -> (Value<'vx> * Value<'vy>) -> unit)\n  | Click of (MouseEvent -> (Value<'vx> * Value<'vy>) -> unit)\n  | TouchStart of (TouchEvent -> (Value<'vx> * Value<'vy>) -> unit)\n  | TouchMove of (TouchEvent -> (Value<'vx> * Value<'vy>) -> unit)\n  | TouchEnd of (TouchEvent -> unit)\n  | MouseLeave of (MouseEvent -> unit)\n\ntype Orientation = \n  | Vertical\n  | Horizontal\n\ntype Shape<[<Measure>] 'vx, [<Measure>] 'vy> = \n  | Style of (Style -> Style) * Shape<'vx, 'vy>\n  | Text of Value<'vx> * Value<'vy> * VerticalAlign * HorizontalAlign * float * string\n  | AutoScale of bool * bool * Shape<'vx, 'vy>\n  | InnerScale of option<continuous<'vx> * continuous<'vx>> * option<continuous<'vy> * continuous<'vy>> * Shape<'vx, 'vy>\n  | OuterScale of option<Scale<'vx>> * option<Scale<'vy>> * Shape<'vx, 'vy>\n  | Line of seq<Value<'vx> * Value<'vy>>\n  | Bubble of Value<'vx> * Value<'vy> * float * float\n  | Shape of seq<Value<'vx> * Value<'vy>>\n  | Stack of Orientation * seq<Shape<'vx, 'vy>>\n  | Layered of seq<Shape<'vx, 'vy>>\n  | Axes of bool * bool * bool * bool * Shape<'vx, 'vy>\n  | Interactive of seq<EventHandler<'vx, 'vy>> * Shape<'vx, 'vy>\n  | Padding of (float * float * float * float) * Shape<'vx, 'vy>\n  | Offset of (float * float) * Shape<'vx, 'vy>\n\n// ------------------------------------------------------------------------------------------------\n// SVG stuff\n// ------------------------------------------------------------------------------------------------\n\nmodule Svg =   \n\n  type StringBuilder() = \n    let mutable strs = [] \n    member x.Append(s) = strs <- s::strs\n    override x.ToString() = String.concat \"\" (List.rev strs)\n\n  type PathSegment = \n    | MoveTo of (float * float)\n    | LineTo of (float * float)\n\n  type SvgStyle = string\n  \n  type Svg =\n    | Path of PathSegment[] * SvgStyle\n    | Ellipse of (float * float) * (float * float) * SvgStyle\n    | Rect of (float * float) * (float * float) * SvgStyle\n    | Text of (float * float) * string * float * SvgStyle \n    | Combine of Svg[]\n    | Empty\n\n  let rec mapSvg f = function\n    | Combine svgs -> Combine(Array.map (mapSvg f) svgs)\n    | svg -> f svg\n\n  let formatPath path = \n    let sb = StringBuilder()\n    for ps in path do\n      match ps with\n      | MoveTo(x, y) -> sb.Append(\"M\" + string x + \" \" + string y + \" \")\n      | LineTo(x, y) -> sb.Append(\"L\" + string x + \" \" + string y + \" \")\n    sb.ToString()\n\n  type RenderingContext = \n    { Definitions : ResizeArray<DomNode> }\n\n  let rec renderSvg ctx svg = seq { \n    match svg with\n    | Empty -> ()\n    | Text((x,y), t, rotation, style) ->\n        let attrs = \n          [ yield \"style\" => style \n            if rotation = 0.0 then\n              yield \"x\" => string x\n              yield \"y\" => string y\n            else\n              yield \"x\" => \"0\"\n              yield \"y\" => \"0\"\n              yield \"transform\" => sprintf \"translate(%f,%f) rotate(%f)\" x y rotation ]\n        yield s?text attrs [ text t ]\n\n    | Combine ss ->\n        for s in ss do yield! renderSvg ctx s\n\n    | Ellipse((cx, cy),(rx, ry), style) ->\n        let attrs = \n          [ \"cx\" => string cx; \"cy\" => string cy;\n            \"rx\" => string rx; \"ry\" => string ry; \"style\" => style ]\n        yield s?ellipse attrs []\n\n    | Rect((x1, y1),(x2, y2), style) ->\n        let l, t = min x1 x2, min y1 y2\n        let w, h = abs (x1 - x2), abs (y1 - y2)\n        let attrs = \n          [ \"x\" => string l; \"y\" => string t; \"width\" => string w; \n            \"height\" => string h; \"style\" => style ]\n        yield s?rect attrs []\n\n    | Path(p, style) ->\n        let attrs = [ \"d\" => formatPath p; \"style\" => style ]\n        yield s?path attrs  [] }\n\n  let formatColor = function\n    | RGB(r,g,b) -> sprintf \"rgb(%d, %d, %d)\" r g b\n    | HTML(clr) -> clr\n\n  let formatNumber = function\n    | Integer n -> string n\n    | Percentage p -> string p + \"%\"\n\n  let rec formatStyle (defs:ResizeArray<_>) style = \n    let style, anim =\n      match style.Animation with \n      | Some (ms, ease, anim) ->\n          let id = \"anim_\" + System.Guid.NewGuid().ToString().Replace(\"-\", \"\")\n          let fromstyle = formatStyle defs { style with Animation = None }\n          let tostyle = formatStyle defs { anim style with Animation = None }\n          h?style [] [ text (sprintf \"@keyframes %s { from { %s } to { %s } }\" id fromstyle tostyle) ] |> defs.Add\n          anim style, sprintf \"animation: %s %dms %s; \" id ms ease\n      | None -> style, \"\"\n\n    anim +\n    ( String.concat \"\" [ for c in style.Cursor.Split(',') -> \"cursor:\" + c + \";\" ] ) +\n    ( \"font:\" + style.Font + \";\" ) +\n    ( let (so, clr) = style.StrokeColor \n      let (Pixels sw) = style.StrokeWidth\n      sprintf \"stroke-opacity:%f; stroke-width:%dpx; stroke:%s; \" so sw (formatColor clr) ) +\n    ( if Seq.isEmpty style.StrokeDashArray then \"\" \n      else \"stroke-dasharray:\" + String.concat \",\" (Seq.map formatNumber style.StrokeDashArray) + \";\" ) +\n    ( match style.Fill with\n      | LinearGradient(points) ->\n          let id = \"gradient_\" + System.Guid.NewGuid().ToString().Replace(\"-\", \"\")\n          s?linearGradient [\"id\"=>id] \n            [ for pt, (o, clr) in points ->\n                s?stop [\"offset\"=> string pt + \"%\"; \"stop-color\" => formatColor clr; \"stop-opacity\" => string o ] [] ]\n          |> defs.Add\n          sprintf \"fill:url(#%s)\" id\n      | Solid(fo, clr) ->\n          sprintf \"fill-opacity:%f; fill:%s; \" fo (formatColor clr) )\n\n// ------------------------------------------------------------------------------------------------\n// Calculating scales\n// ------------------------------------------------------------------------------------------------\n\nmodule Scales = \n  type ScaledShapeInner<[<Measure>] 'vx, [<Measure>] 'vy> = \n    | ScaledStyle of (Style -> Style) * ScaledShape<'vx, 'vy>\n    | ScaledOuterScale of option<Scale<'vx>> * option<Scale<'vy>> * ScaledShape<'vx, 'vy>\n    | ScaledText of Value<'vx> * Value<'vy> * VerticalAlign * HorizontalAlign * float * string    \n    | ScaledLine of (Value<'vx> * Value<'vy>)[]\n    | ScaledBubble of Value<'vx> * Value<'vy> * float * float\n    | ScaledShape of (Value<'vx> * Value<'vy>)[]\n    | ScaledLayered of ScaledShape<'vx, 'vy>[]\n    | ScaledStack of Orientation * ScaledShape<'vx, 'vy>[]\n    | ScaledInteractive of seq<EventHandler<'vx, 'vy>> * ScaledShape<'vx, 'vy>\n    | ScaledPadding of (float * float * float * float) * ScaledShape<'vx, 'vy>\n    | ScaledOffset of (float * float) * ScaledShape<'vx, 'vy>\n\n  and ScaledShape<[<Measure>] 'vx, [<Measure>] 'vy> =\n    Scaled of outer:(Scale<'vx> * Scale<'vy>) * inner:(Scale<'vx> * Scale<'vy>) * ScaledShapeInner<'vx, 'vy>\n\n  let getExtremes = function\n    | Continuous(l, h) -> COV l, COV h\n    | Categorical(vals) ->  CAR(vals.[0], 0.0), CAR(vals.[vals.Length-1], 1.0)\n\n  /// Given a range, return a new aligned range together with the magnitude  \n  let calculateMagnitudeAndRange (lo:float, hi:float) = \n    let magnitude = 10. ** round (log10 (hi - lo))\n    let magnitude = magnitude / 2.\n    magnitude, (floor (lo / magnitude) * magnitude, ceil (hi / magnitude) * magnitude)\n\n  /// Get number of decimal points to show for the given range\n  let decimalPoints range = \n    let magnitude, _ = calculateMagnitudeAndRange range\n    max 0. (ceil (-(log10 magnitude)))\n\n  /// Extend the given range to a nicely adjusted size\n  let adjustRange range = snd (calculateMagnitudeAndRange range)\n  let adjustRangeUnits (l:float<'u>,h:float<'u>) : float<'u> * float<'u> =\n    let l, h = adjustRange (unbox l, unbox h) in unbox l, unbox h\n\n  let toArray s = Array.ofSeq s // REVIEW: Hack to avoid Float64Array (which behaves oddly in Safari) see https://github.com/zloirock/core-js/issues/285\n\n  /// Generate points for a grid. Count specifies how many points to generate\n  /// (this is minimm - the result will be up to 5x more).\n  let generateSteps count k (lo, hi) = \n    let magnitude, (nlo, nhi) = calculateMagnitudeAndRange (lo, hi)\n    let dividers = [0.2; 0.5; 1.; 2.; 5.; 10.; 20.; 40.; 50.; 60.; 80.; 100.]\n    let magnitudes = dividers |> Seq.map (fun d -> magnitude / d)\n    let step = magnitudes |> Seq.filter (fun m -> (hi - lo) / m >= count) |> Seq.tryHead\n    let step = defaultArg step (magnitude / 100.)\n    seq { for v in nlo .. step * k .. nhi do\n            if v >= lo && v <= hi then yield v } |> toArray\n\n  let generateAxisSteps s =\n    match s with \n    | Continuous(CO l, CO h) ->\n        generateSteps 6. 1. (float l, float h) |> Array.map (fun f -> COV(CO (unbox f)))\n    | Categorical vs -> [| for CA s in vs -> CAR(CA s, 0.5) |]\n\n  let generateAxisLabels fmt (s:Scale<'v>) : (Value<'v> * string)[] =\n    let sunit = unbox<Scale<1>> s\n    match s with \n    | Continuous(CO l, CO h) ->\n        generateSteps 6. 2. (float l, float h) \n        |> Array.map (fun f -> COV(CO (unbox f)), fmt sunit (COV(CO(unbox<float<1>> f))))\n    | Categorical vs -> [| for v & CA s in vs -> CAR(CA s, 0.5), fmt sunit (CAR(CA s, 0.5)) |]\n\n  let unionScales s1 s2 =\n    match s1, s2 with\n    | Continuous(l1, h1), Continuous(l2, h2) -> Continuous(min l1 l2, max h1 h2)\n    | Categorical(v1), Categorical(v2) -> Categorical(Array.distinct (Array.append v1 v2))\n    | _ -> \n        failwith \"Cannot union continuous with categorical\"\n\n  // Replace scales in all immediately nested things that will\n  // share the same scale when combined via Layered\n  // (recursively over Interacitve & Layered with Line as leaf)\n\n  let rec replaceScales outer (Scaled(_, inner, shape) as scaled) =\n    match shape with\n    // Replace at the leafs\n    | ScaledLine _ \n    | ScaledText _\n    | ScaledBubble _\n    | ScaledShape _ -> Scaled(outer, inner, shape)\n    // Replace just top level scales\n    | ScaledOuterScale _ -> Scaled(outer, inner, shape)\n    // Propagate recursively\n    | ScaledOffset(d, shape) -> Scaled(outer, inner, ScaledOffset(d, replaceScales outer shape))\n    | ScaledStyle(f, shape) -> Scaled(outer, inner, ScaledStyle(f, replaceScales outer shape))\n    | ScaledPadding(pad, shape) -> Scaled(outer, inner, ScaledPadding(pad, replaceScales outer shape))\n    | ScaledInteractive(f, shape) -> Scaled(outer, inner, ScaledInteractive(f, replaceScales outer shape))\n    | ScaledLayered(shapes) -> Scaled(outer, inner, ScaledLayered(Array.map (replaceScales outer) shapes))\n    | ScaledStack(orient, shapes) -> Scaled(outer, inner, ScaledStack(orient, Array.map (replaceScales outer) shapes))\n\n  // From the leafs to the root, calculate the scales of\n  // everything (composing sales of leafs to get scale of root)\n\n  let calculateShapeScale vals = \n    let scales =\n      vals |> Array.fold (fun state value ->\n        match state, value with \n        | Choice1Of3(), COV(CO v) -> Choice2Of3([v])\n        | Choice2Of3(vs), COV(CO v) -> Choice2Of3(v::vs)\n        | Choice1Of3(), CAR(CA x, _) -> Choice3Of3([x])\n        | Choice3Of3(xs), CAR(CA x, _) -> Choice3Of3(x::xs)\n        | _ -> failwith \"Values with mismatching scales\") (Choice1Of3())\n    match scales with\n    | Choice1Of3() -> failwith \"No values for calculating a scale\"\n    | Choice2Of3(vs) -> Continuous (CO (List.min vs), CO (List.max vs))\n    | Choice3Of3(xs) -> Categorical (Array.distinct [| for x in List.rev xs -> CA x |])\n\n  let calculateShapeScales points = \n    let xs = points |> Array.map fst \n    let ys = points |> Array.map snd\n    calculateShapeScale xs, calculateShapeScale ys\n\n  // Always returns objects with the same inner and outer scales\n  // but outer scales can be replaced later by replaceScales\n  let rec calculateScales<[<Measure>] 'ux, [<Measure>] 'uy> style (shape:Shape<'ux, 'uy>) = \n    let calculateScalesStyle = calculateScales \n    let calculateScales = calculateScales style\n    match shape with\n    | OuterScale(sx, sy, shape) ->\n        let (Scaled((osx, osy), inner, _)) as scaled = calculateScales shape\n        let scales = defaultArg sx osx, defaultArg sy osy\n        Scaled(scales, inner, ScaledOuterScale(sx, sy, scaled))\n\n    | InnerScale(sx, sy, shape) ->\n        let (Scaled((asx, asy), _, shape)) = calculateScales shape\n        let scales = \n          (match sx with Some sx -> Continuous(sx) | _ -> asx), \n          (match sy with Some sy -> Continuous(sy) | _ -> asy) \n        Scaled(scales, scales, shape) |> replaceScales scales\n\n    | AutoScale(ax, ay, shape) ->\n        let (Scaled((asx, asy), _, shape)) = calculateScales shape\n        let autoScale = function\n          | Continuous(CO l, CO h) -> let l, h = adjustRangeUnits (l, h) in Continuous(CO l, CO h)\n          | scale -> scale\n        let scales = \n          ( if ax then autoScale asx else asx ),\n          ( if ay then autoScale asy else asy )\n        Scaled(scales, scales, shape) |> replaceScales scales    \n\n    | Offset(offs, shape) ->\n        let (Scaled(scales, _, shape)) = calculateScales shape\n        Scaled(scales, scales, ScaledOffset(offs, Scaled(scales, scales, shape)))\n\n    | Style(f, shape) ->\n        let (Scaled(scales, _, shape)) = calculateScalesStyle (f style) shape\n        Scaled(scales, scales, ScaledStyle(f, Scaled(scales, scales, shape)))\n\n    | Padding(pads, shape) ->\n        let (Scaled(scales, _, shape)) = calculateScales shape\n        Scaled(scales, scales, ScaledPadding(pads, Scaled(scales, scales, shape)))\n\n    | Bubble(x, y, rx, ry) ->\n        let makeSingletonScale = function COV(v) -> Continuous(v, v) | CAR(v, _) -> Categorical [| v |]\n        let scales = makeSingletonScale x, makeSingletonScale y\n        Scaled(scales, scales, ScaledBubble(x, y, rx, ry))\n\n    | Shape.Text(x, y, va, ha, r, t) ->\n        let makeSingletonScale = function COV(v) -> Continuous(v, v) | CAR(v, _) -> Categorical [| v |]\n        let scales = makeSingletonScale x, makeSingletonScale y\n        Scaled(scales, scales, ScaledText(x, y, va, ha, r, t))    \n\n    | Line line -> \n        let line = Seq.toArray line \n        let scales = calculateShapeScales line\n        Scaled(scales, scales, ScaledLine(line))\n\n(*\n    | Column(x, y) ->\n        let scales = Categorical [| x |], Continuous(CO 0.0<_>, y)\n        Scaled(scales, scales, ScaledColumn(x, y))\n\n    | Bar(x, y) ->\n        let scales = Continuous(CO 0.0<_>, x), Categorical [| y |]\n        Scaled(scales, scales, ScaledBar(x, y))\n\n    | Area area -> \n        let area = Seq.toArray area\n        let scales = calculateLineOrAreaScales area\n        Scaled(scales, scales, ScaledArea(area))\n*)\n    | Shape points -> \n        let points = Seq.toArray points\n        let scales = calculateShapeScales points\n        Scaled(scales, scales, ScaledShape(points))\n    \n    | Axes(showTop, showRight, showBottom, showLeft, shape) ->\n        let (Scaled(origScales & (sx, sy), _, _)) = calculateScales shape \n        let (lx, hx), (ly, hy) = getExtremes sx, getExtremes sy\n        \n        let LineStyle clr alpha width shape = \n          Style((fun s -> { s with Fill = Solid(1.0, HTML \"transparent\"); StrokeWidth = Pixels width; StrokeColor=alpha, HTML clr }), shape)\n        let FontStyle style shape = \n          Style((fun s -> { s with Font = style; Fill = Solid(1.0, HTML \"black\"); StrokeColor = 0.0, HTML \"transparent\" }), shape)\n\n        let shape = \n          Layered [ \n            for x in generateAxisSteps sx do\n              yield Line [x,ly; x,hy] |> LineStyle \"#e4e4e4\" 1.0 1\n            for y in generateAxisSteps sy do\n              yield Line [lx,y; hx,y] |> LineStyle \"#e4e4e4\" 1.0 1 \n            if showTop then\n              yield Line [lx,hy; hx,hy] |> LineStyle \"black\" 1.0 2\n              for x, l in generateAxisLabels style.FormatAxisXLabel sx do\n                yield Offset((0., -10.), Text(x, hy, VerticalAlign.Baseline, HorizontalAlign.Center, 0.0, l)) |> FontStyle \"9pt sans-serif\"\n            if showRight then\n              yield Line [hx,hy; hx,ly] |> LineStyle \"black\" 1.0 2\n              for y, l in generateAxisLabels style.FormatAxisYLabel sy do\n                yield Offset((10., 0.), Text(hx, y, VerticalAlign.Middle, HorizontalAlign.Start, 0.0, l)) |> FontStyle \"9pt sans-serif\"\n            if showBottom then\n              yield Line [lx,ly; hx,ly] |> LineStyle \"black\" 1.0 2\n              for x, l in generateAxisLabels style.FormatAxisXLabel sx do\n                yield Offset((0., 10.), Text(x, ly, VerticalAlign.Hanging, HorizontalAlign.Center, 0.0, l)) |> FontStyle \"9pt sans-serif\"\n            if showLeft then\n              yield Line [lx,hy; lx,ly] |> LineStyle \"black\" 1.0 2\n              for y, l in generateAxisLabels style.FormatAxisYLabel sy do\n                yield Offset((-10., 0.), Text(lx, y, VerticalAlign.Middle, HorizontalAlign.End, 0.0, l)) |> FontStyle \"9pt sans-serif\"\n            yield shape ] |> calculateScales\n\n        match shape with \n        | Scaled(_, _, ScaledLayered(shapes)) ->\n            let padding = \n              (if showTop then 30. else 0.), (if showRight then 50. else 0.),\n              (if showBottom then 30. else 0.), (if showLeft then 50. else 0.) \n            Scaled(origScales, origScales, \n              ScaledPadding(padding, \n                Scaled(origScales, origScales, \n                  ScaledLayered (Array.map (replaceScales origScales) shapes))))\n        | _ -> failwith \"calculateScales: processing layered shape did not return layered shape\"\n        \n    | Stack(orient, shapes) ->\n        let shapes = shapes |> Array.ofSeq\n        let scaled = shapes |> Array.map calculateScales \n        let sxs = scaled |> Array.map (fun (Scaled((sx, _), _, _)) -> sx)\n        let sys = scaled |> Array.map (fun (Scaled((_, sy), _, _)) -> sy)\n        let scales = (Array.reduce unionScales sxs, Array.reduce unionScales sys)\n        match orient, scales with \n        | Horizontal, (Continuous _, _) -> failwith \"Horizontal stacking of continuous axes is not supported\"\n        | Vertical, (_, Continuous _) -> failwith \"Vertical stacking of continuous axes is not supported\"\n        | _ -> ()\n        Scaled(scales, scales, ScaledStack(orient, scaled)) |> replaceScales scales \n\n    | Layered shapes ->\n        let shapes = shapes |> Array.ofSeq\n        let scaled = shapes |> Array.map calculateScales \n        let sxs = scaled |> Array.map (fun (Scaled((sx, _), _, _)) -> sx)\n        let sys = scaled |> Array.map (fun (Scaled((_, sy), _, _)) -> sy)\n        let scales = (Array.reduce unionScales sxs, Array.reduce unionScales sys)\n        Scaled(scales, scales, ScaledLayered scaled) |> replaceScales scales \n\n    | Interactive(f, shape) ->\n        let (Scaled(scales, _, shape)) = calculateScales shape\n        Scaled(scales, scales, ScaledInteractive(f, Scaled(scales, scales, shape)))\n\n// ------------------------------------------------------------------------------------------------\n// Calculate projections\n// ------------------------------------------------------------------------------------------------\n\nmodule Projections = \n  open Scales\n\n  type Projection<[<Measure>] 'vx, [<Measure>] 'vy, [<Measure>] 'ux, [<Measure>] 'uy> = \n    | Scale of (float<'ux> * float<'ux>) * (float<'uy> * float<'uy>)\n    \n    // given a projection that maps things to (0, 100), the floats\n    // specify subrange of the target domain, so i.e. specifying (0.2, 0.8) would\n    // result in all the vales being mapped to (20, 80)\n    | Rescale of (float * float) * (float * float) * Projection<'vx, 'vy, 'ux, 'uy> \n\n    | Padding of\n        // padding from top, right, bottom, left \n        padding:(float<'uy> * float<'ux> * float<'uy> * float<'ux>) * \n        // points on the scales relative to which the padding is calculated\n        // (essentially the size of the content around which padding is)\n        extremes:(Value<'vx> * Value<'vx> * Value<'vy> * Value<'vy>) * \n        Projection<'vx, 'vy, 'ux, 'uy>\n\n  type ProjectedShapeInner<[<Measure>] 'vx, [<Measure>] 'vy> = \n    | ProjectedStyle of (Style -> Style) * ProjectedShape<'vx, 'vy>\n    | ProjectedBubble of Value<'vx> * Value<'vy> * float * float\n    | ProjectedText of Value<'vx> * Value<'vy> * VerticalAlign * HorizontalAlign * float * string    \n    | ProjectedLine of (Value<'vx> * Value<'vy>)[]\n    | ProjectedShape of (Value<'vx> * Value<'vy>)[]\n    | ProjectedLayered of ProjectedShape<'vx, 'vy>[]\n    | ProjectedStack of Orientation * ProjectedShape<'vx, 'vy>[]\n    | ProjectedOffset of (float * float) * ProjectedShape<'vx, 'vy>\n    | ProjectedInteractive of seq<EventHandler<'vx, 'vy>> * ProjectedShape<'vx, 'vy>\n\n  /// Projection from values on the scales (specified) to pixels\n  and ProjectedShape<[<Measure>] 'vx, [<Measure>] 'vy> =\n    Projected of Projection<'vx, 'vy, 1, 1> * (Scale<'vx> * Scale<'vy>) * ProjectedShapeInner<'vx, 'vy>\n\n  let scaleOne (tlv:float<_>, thv:float<_>) scale coord = \n    match scale, coord with\n    | Categorical(vals), (CAR(CA v,f)) ->\n        let size = (thv - tlv) / float vals.Length\n        let i = vals |> Array.findIndex (fun (CA vv) -> v = vv)\n        let i = float i + f\n        CO(tlv + (i * size))\n    | Continuous(CO slv, CO shv), (COV (CO v)) ->\n        CO((v - slv) / (shv - slv) * (thv - tlv) + tlv)\n    | Categorical _, COV _ -> failwith \"Cannot project continuous value on a categorical scale.\"\n    | Continuous _, CAR _ -> failwith \"Cannot project categorical value on a continuous scale.\"\n\n  let rec project<[<Measure>] 'vx, [<Measure>] 'vy, [<Measure>] 'ux, [<Measure>] 'uy> \n      (sx:Scale<'vx>) (sy:Scale<'vy>) point (projection:Projection<'vx, 'vy, 'ux, 'uy>) : continuous<'ux> * continuous<'uy> = \n    match projection, point with\n    | Scale(tx, ty), (x, y) ->\n        scaleOne tx sx x, scaleOne ty sy y \n    \n    | Rescale((rlx, rhx), (rly, rhy), proj), point ->\n        let (lx, hx), (ly, hy) = getExtremes sx, getExtremes sy\n        let (CO x1, CO y1), (CO x2, CO y2) = project sx sy (lx, ly) proj, project sx sy (hx, hy) proj\n        let lx, hx, ly, hy = min x1 x2, max x1 x2, min y1 y2, max y1 y2\n\n        let (CO x, CO y) = project sx sy point proj \n        let nx = if lx = hx then x else lx + (hx - lx) * ((x - lx) / (hx - lx) * (rhx - rlx) + rlx)\n        let ny = if ly = hy then y else ly + (hy - ly) * ((y - ly) / (hy - ly) * (rhy - rly) + rly)\n        (CO nx, CO ny)\n\n    | Padding((t,r,b,l),(lx,hx,ly,hy),projection), _ ->\n        //let (lx, hx), (ly, hy) = getExtremes sx, getExtremes sy\n        let (CO x1, CO y1) = project sx sy (lx, ly) projection\n        let (CO x2, CO y2) = project sx sy (hx, hy) projection\n        let lx, hx, ly, hy = min x1 x2, max x1 x2, min y1 y2, max y1 y2\n\n        let (CO x, CO y) = project sx sy point projection\n\n        // Assuming the result is in pixels...\n        let nx = if lx = hx then x else lx + l + (hx - lx - l - r) / (hx - lx) * (x - lx)\n        let ny = if ly = hy then y else ly + t + (hy - ly - t - b) / (hy - ly) * (y - ly)\n        (CO nx, CO ny)\n    \n\n  // inverse operation to scaleOne\n  let scaleOneInv (tlv:float<'u>, thv:float<'u>) (scale:Scale<'v>) (coord:continuous<'u>) : Value<'v> =  \n    match scale, coord with\n    | Continuous(CO slv, CO shv), (CO v) ->\n        COV (CO((v - tlv) / (thv - tlv) * (shv - slv) + slv))\n    | Categorical(cats), (CO v) ->\n        let size = (thv - tlv) / float cats.Length\n        let i = floor (v / size)\n        let f = (v / size) - i\n        let i = if size < 0.<_> then (float cats.Length) + i else i // Negative when thv < tlv\n        if int i < 0 || int i >= cats.Length then CAR(CA \"<outside-of-range>\", f)\n        else CAR(cats.[int i], f)\n\n   // project:    scales<v> * point<v> * proj<v -> u> -> point<u>   // v = -1 .. 1     u = 0px .. 100px\n   // projectInv: scales<v> * point<u> * proj<v -> u> -> point<v>\n\n  let rec invertProj proj = \n    match proj with\n    | Rescale(rx, ry, Padding(p, ex, proj)) -> Padding(p, ex, Rescale(rx, ry, proj))\n    | Padding(p, ex, Rescale(rx, ry, proj)) -> Rescale(rx, ry, Padding(p, ex, proj))\n    | _ -> proj\n\n\n  let rec projectInv<[<Measure>] 'vx, [<Measure>] 'vy, [<Measure>] 'ux, [<Measure>] 'uy> \n      ((sx, sy):Scale<'vx> * Scale<'vy>) (point:continuous<'ux> * continuous<'uy>) \n      (projection:Projection<'vx, 'vy, 'ux, 'uy>) : Value<'vx> * Value<'vy> = \n    \n    match projection, point with\n    | Rescale((rlx, rhx), (rly, rhy), projection), (CO x, CO y) ->\n        let (lx, hx), (ly, hy) = getExtremes sx, getExtremes sy\n        let (CO x1, CO y1), (CO x2, CO y2) = project sx sy (lx, ly) projection, project sx sy (hx, hy) projection\n        let lx, hx, ly, hy = min x1 x2, max x1 x2, min y1 y2, max y1 y2\n\n        // Inverse of project\n        let (CO ox, CO oy) = point \n        let nx = lx + ((ox - lx) / (hx - lx) - rlx) / (rhx - rlx) * (hx - lx)\n        let ny = ly + ((oy - ly) / (hy - ly) - rly) / (rhy - rly) * (hy - ly)\n        projectInv (sx, sy) (CO nx, CO ny) projection\n\n    | Padding((t, r, b, l), (lx, hx, ly, hy), projection), (CO x, CO y) ->\n        let (CO x1, CO y1) = project sx sy (lx, ly) projection\n        let (CO x2, CO y2) = project sx sy (hx, hy) projection\n        let lx, hx, ly, hy = min x1 x2, max x1 x2, min y1 y2, max y1 y2\n        \n        // Imagine point is in 20px .. 60px, calculate equivalent point in 0px .. 100px (add padding)\n        let (CO ox, CO oy) = point \n        //let nx = (ox - l) / (hx - lx - l - r) * (hx - lx)\n        //let ny = (oy - t) / (hy - ly - t - b) * (hy - ly)\n        let nx = (ox - lx - l) / (hx - lx - l - r) * (hx - lx) + lx\n        let ny = (oy - ly - t) / (hy - ly - t - b) * (hy - ly) + ly\n        projectInv (sx, sy) (CO nx, CO ny) projection\n\n    | Scale(tx, ty), (x, y) ->\n        scaleOneInv tx sx x, scaleOneInv ty sy y \n\n\n  let rec calculateProjections<[<Measure>] 'ux, [<Measure>] 'uy> (shape:ScaledShape<'ux, 'uy>) projection = \n    match shape with\n    | Scaled(scales, _, ScaledOffset(offs, shape)) ->\n        Projected(projection, scales, ProjectedOffset(offs, calculateProjections shape projection))\n\n    | Scaled(scales, _, ScaledStyle(style, shape)) ->\n        Projected(projection, scales, ProjectedStyle(style, calculateProjections shape projection))\n\n    | Scaled((sx, sy), _, ScaledOuterScale(osx, osy, shape)) ->\n        //let pinner = Projection\n\n        // projection + shape scales determines mapping from shape scales to pixel space\n        // get range of osx/osy within scales and transform projection so that it only maps on this subrange\n        let adaptProjection os s = \n          match os with\n          | Some(o) ->\n              let ls, hs = getExtremes s\n              let ls', hs' = scaleOne (0.0, 1.0) s ls, scaleOne (0.0, 1.0) s hs\n              let lo, ho = getExtremes o\n              let (CO lo'), (CO ho') = scaleOne (0.0, 1.0) s lo, scaleOne (0.0, 1.0) s ho\n              (lo', ho')\n          | _ -> \n              (0.0, 1.0)\n\n        let px = adaptProjection osx sx\n        let py = adaptProjection osy sy \n        let projection = Rescale(px, py, projection)\n\n        let (Projected(pbody, scales, nested)) = calculateProjections shape projection\n        Projected(pbody, scales, nested)\n\n    | Scaled(scales, _, ScaledLine line) -> \n        Projected(projection, scales, ProjectedLine line)\n\n    | Scaled(scales, _, ScaledText(x, y, va, ha, r, t)) -> \n        Projected(projection, scales, ProjectedText(x, y, va, ha, r, t))\n\n    | Scaled(scales, _, ScaledBubble(x, y, rx, ry)) -> \n        Projected(projection, scales, ProjectedBubble(x, y, rx, ry))\n\n    | Scaled(scales, _, ScaledShape points) -> \n        Projected(projection, scales, ProjectedShape points)\n\n    | Scaled(_, _, ScaledPadding((t,r,b,l), shape)) ->\n        let (lx, hx), (ly, hy) = \n          let (Scaled(_, (sxinner, syinner), _)) = shape \n          getExtremes sxinner, getExtremes syinner\n        let ppad = Padding((t, r, b, l), (lx, hx, ly, hy), projection)\n        calculateProjections shape ppad\n\n    | Scaled(scales, _, ScaledStack(orient, shapes)) ->\n        Projected(projection, scales, ProjectedStack(orient, shapes |> Array.map (fun s -> calculateProjections s projection)))\n        \n    | Scaled(scales, _, ScaledLayered shapes) ->\n        Projected(projection, scales, ProjectedLayered(shapes |> Array.map (fun s -> calculateProjections s projection)))\n\n    | Scaled(scales, _, ScaledInteractive(f, shape)) ->\n        Projected(projection, scales, ProjectedInteractive(f, calculateProjections shape projection))\n\n// ------------------------------------------------------------------------------------------------\n// Drawing\n// ------------------------------------------------------------------------------------------------\n\nmodule Drawing = \n  open Svg\n  open Scales\n  open Projections\n\n  type DrawingContext = \n    { Style : Style\n      Definitions : ResizeArray<DomNode> }\n\n  let rec hideFill style = \n    { style with Fill = Solid(0.0, RGB(0, 0, 0)); Animation = match style.Animation with Some(n,e,f) -> Some(n,e,f >> hideFill) | _ -> None }\n  let rec hideStroke style = \n    { style with StrokeColor = (0.0, snd style.StrokeColor); Animation = match style.Animation with Some(n,e,f) -> Some(n,e,f >> hideStroke) | _ -> None }\n\n  let rec drawShape<[<Measure>] 'ux, [<Measure>] 'uy> ctx (shape:ProjectedShape<'ux, 'uy>) = \n    let (Projected(projection, (sx, sy), shape)) = shape\n\n    let projectCont (x, y) = \n      match project sx sy (x, y) projection with\n      | (CO x), (CO y) -> x, y\n    let projectContCov (x, y) = projectCont (COV x, COV y)\n\n    match shape, (sx, sy) with\n    | ProjectedOffset((dx, dy), shape), _ ->\n        drawShape ctx shape\n        |> mapSvg (function \n            | Text((x, y), t, r, s) -> Text((x + dx, y + dy), t, r, s)\n            | Path(seg, s) -> Path(Array.map (function \n                MoveTo(x, y) -> MoveTo(x + dx, y + dy) | LineTo(x, y) -> LineTo(x + dx, y + dy)) seg, s)\n            | s -> s)\n\n    | ProjectedStyle(sf, shape), _ ->\n        drawShape { ctx with Style =  sf ctx.Style } shape\n\n    | ProjectedText(x, y, va, ha, r, t), _ -> \n        let va = match va with Baseline -> \"baseline\" | Hanging -> \"hanging\" | Middle -> \"middle\"\n        let ha = match ha with Start -> \"start\" | Center -> \"middle\" | End -> \"end\"\n        let xy = projectCont (x, y)\n        Text(xy, t, r, sprintf \"alignment-baseline:%s; text-anchor:%s;\" va ha + formatStyle ctx.Definitions ctx.Style)\n\n    | ProjectedBubble(x, y, rx, ry), _ -> \n        Ellipse(projectCont (x, y), (rx, ry), formatStyle ctx.Definitions ctx.Style)\n\n    | ProjectedLine line, _ -> \n        let path = \n          [ yield MoveTo(projectCont (Seq.head line)) \n            for pt in Seq.skip 1 line do yield LineTo (projectCont pt) ]\n          |> Array.ofList\n        Path(path, formatStyle ctx.Definitions (hideFill ctx.Style))\n\n    | ProjectedShape(points), _ -> \n        let path = \n          [| yield MoveTo(projectCont (points.[0]))\n             for pt in Seq.skip 1 points do yield LineTo(projectCont pt) \n             yield LineTo(projectCont (points.[0])) |]\n        Path(path, formatStyle ctx.Definitions (hideStroke ctx.Style)) \n\n    | ProjectedLayered shapes, _ ->\n        Combine(shapes |> Array.map (fun s -> drawShape ctx s))\n\n    | ProjectedStack(_, shapes), _ ->\n        Combine(shapes |> Array.map (fun s -> drawShape ctx s))\n\n    | ProjectedInteractive(f, shape), _ ->\n        drawShape ctx shape\n\n// ------------------------------------------------------------------------------------------------\n// Event handling\n// ------------------------------------------------------------------------------------------------\n\nmodule Events = \n  open Scales\n  open Projections\n\n  type MouseEventKind = Click | Move | Up | Down\n  type TouchEventKind = Move | Start \n\n  type InteractiveEvent<[<Measure>] 'vx, [<Measure>] 'vy> = \n    | MouseEvent of MouseEventKind * (Value<'vx> * Value<'vy>)    \n    | TouchEvent of TouchEventKind * (Value<'vx> * Value<'vy>)    \n    | TouchEnd\n    | MouseLeave\n\n  let projectEvent scales projection event =\n    match event with\n    | MouseEvent(kind, (COV x, COV y)) -> MouseEvent(kind, projectInv scales (x, y) (invertProj projection))\n    | TouchEvent(kind, (COV x, COV y)) -> TouchEvent(kind, projectInv scales (x, y) (invertProj projection))\n    | MouseEvent _\n    | TouchEvent _ -> failwith \"TODO: projectEvent - not continuous\"\n    | TouchEnd -> TouchEnd\n    | MouseLeave -> MouseLeave\n\n  let inScale s v = \n    match s, v with\n    | Continuous(CO l, CO h), COV(CO v) -> v >= min l h && v <= max l h\n    | Categorical(cats), CAR(v, _) -> cats |> Seq.exists ((=) v)\n    | Continuous _, CAR _ -> failwith \"inScale: Cannot test if categorical value is in continuous scale\"\n    | Categorical _, COV _ -> failwith \"inScale: Cannot test if continuous value is in categorical scale\"\n\n  let inScales (sx, sy) event =\n    match event with\n    | MouseLeave -> true\n    | TouchEnd -> true\n    | MouseEvent(_, (x, y)) \n    | TouchEvent(_, (x, y)) -> inScale sx x && inScale sy y\n\n  let rec triggerEvent<[<Measure>] 'ux, [<Measure>] 'uy> (shape:ProjectedShape<'ux, 'uy>) (jse:Event) (event:InteractiveEvent<1,1>) = \n    let (Projected(projection, scales, shape)) = shape\n    match shape with\n    | ProjectedLine _\n    | ProjectedText _\n    | ProjectedBubble _\n    | ProjectedShape _ -> ()\n    | ProjectedStyle(_, shape)\n    | ProjectedOffset(_, shape) -> triggerEvent shape jse event\n    | ProjectedStack(_, shapes)\n    | ProjectedLayered shapes -> for shape in shapes do triggerEvent shape jse event\n    | ProjectedInteractive(handlers, shape) ->\n        let localEvent = projectEvent scales projection event\n        if inScales scales localEvent then \n          for handler in handlers do \n            match localEvent, handler with\n            | MouseEvent(MouseEventKind.Click, pt), EventHandler.Click(f) \n            | MouseEvent(MouseEventKind.Move, pt), MouseMove(f) \n            | MouseEvent(MouseEventKind.Up, pt), MouseUp(f) \n            | MouseEvent(MouseEventKind.Down, pt), MouseDown(f) -> \n                if jse <> null then jse.preventDefault()\n                f (unbox jse) pt\n            | TouchEvent(TouchEventKind.Move, pt), TouchMove(f) \n            | TouchEvent(TouchEventKind.Start, pt), TouchStart(f) ->\n                if jse <> null then jse.preventDefault()\n                f (unbox jse) pt\n            | TouchEnd, EventHandler.TouchEnd f -> f (unbox jse) \n            | MouseLeave, EventHandler.MouseLeave f -> f (unbox jse) \n            | MouseLeave, _ \n            | TouchEnd, _\n            | TouchEvent(_, _), _  \n            | MouseEvent(_, _), _  -> ()\n\n        triggerEvent shape jse event\n\n// ------------------------------------------------------------------------------------------------\n// Integration\n// ------------------------------------------------------------------------------------------------\n\nmodule Derived = \n  let Area(line) = Shape <| seq {\n    let line = Array.ofSeq line\n    let firstX, lastX = fst line.[0], fst line.[line.Length - 1]\n    yield firstX, COV (CO 0.0)\n    yield! line\n    yield lastX, COV (CO 0.0)\n    yield firstX, COV (CO 0.0) }\n\n  let VArea(line) = Shape <| seq {\n    let line = Array.ofSeq line\n    let firstY, lastY = snd line.[0], snd line.[line.Length - 1]\n    yield COV (CO 0.0), firstY\n    yield! line\n    yield COV (CO 0.0), lastY\n    yield COV (CO 0.0), firstY }\n\n  let VShiftedArea(offs, line) = Shape <| seq {\n    let line = Array.ofSeq line\n    let firstY, lastY = snd line.[0], snd line.[line.Length - 1]\n    yield COV (CO offs), firstY\n    yield! line\n    yield COV (CO offs), lastY\n    yield COV (CO offs), firstY }\n\n  let Bar(x, y) = Shape <| seq {\n    yield COV x, CAR(y, 0.0)\n    yield COV x, CAR(y, 1.0)\n    yield COV (CO 0.0), CAR(y, 1.0)\n    yield COV (CO 0.0), CAR(y, 0.0) }\n    \n  let Column(x, y) = Shape <| seq {\n    yield CAR(x, 0.0), COV y\n    yield CAR(x, 1.0), COV y\n    yield CAR(x, 1.0), COV (CO 0.0)\n    yield CAR(x, 0.0), COV (CO 0.0) }\n\nmodule Compost = \n  open Scales\n  open Projections\n  open Drawing\n  open Events\n  open Svg\n    \n  let defaultFormat scale value = \n    match value with\n    | CAR(CA s, _) -> s\n    | COV(CO v) ->\n        let dec = \n          match scale with\n          | Continuous(CO l, CO h) -> decimalPoints (unbox l, unbox h)\n          | _ -> 0.\n        Common.niceNumber (System.Math.Round(unbox<float> v, int dec)) (int dec)    \n\n  let defstyle = \n    { Fill = Solid(1.0, RGB(196, 196, 196))\n      StrokeColor = (1.0, RGB(256, 0, 0))\n      StrokeDashArray = []\n      StrokeWidth = Pixels 2\n      Animation = None \n      Cursor = \"default\"\n      Font = \"10pt sans-serif\"\n      FormatAxisXLabel = defaultFormat\n      FormatAxisYLabel = defaultFormat }\n\n  let rec mapShape f (Projected(pr, sc, s)) =\n    let s = \n      match s with\n      | ProjectedStyle(sf, s) -> (ProjectedStyle(sf, mapShape f s))\n      | ProjectedStack(o, sx) -> (ProjectedStack(o, Array.map (mapShape f) sx))\n      | ProjectedLayered(sx) -> (ProjectedLayered(Array.map (mapShape f) sx))\n      | ProjectedInteractive(e, s) -> (ProjectedInteractive(e, mapShape f s))\n      | ProjectedOffset(o, s) -> (ProjectedOffset(o, mapShape f s))\n      | (ProjectedBubble _ as s) | (ProjectedLine _ as s) | (ProjectedShape _ as s) | (ProjectedText _  as s) -> s \n    Projected(pr, sc, f s)\n\n  let createSvg revX revY (width, height) viz = \n    let scaled = calculateScales defstyle viz\n    let master = Scale((if revX then (width, 0.0) else (0.0, width)), (if revY then (0.0, height) else (height, 0.0)))\n    let projected = calculateProjections scaled master\n    let projected = \n      if not revX && not revY then projected else\n        projected |> mapShape (fun s -> \n          match s with\n          | ProjectedText(x, y, v, h, r, s) -> \n              let v = match v with VerticalAlign.Baseline when revY -> VerticalAlign.Hanging | VerticalAlign.Hanging when revY -> VerticalAlign.Baseline | v -> v\n              let h = match h with HorizontalAlign.Start when revX -> HorizontalAlign.End | HorizontalAlign.End when revX -> HorizontalAlign.Start | h -> h\n              ProjectedText(x, y, v, h, r, s)\n          | ProjectedOffset((ox, oy), s) ->               \n              ProjectedOffset(((if revX then -ox else ox), (if revY then -oy else oy)), s) \n          | s -> s)\n\n\n    let defs = ResizeArray<_>()\n    let svg = drawShape { Definitions = defs; Style = defstyle } projected\n\n    let getRelativeLocation el x y =\n      let rec getOffset (parent:HTMLElement) (x, y) = \n        if parent = null then (x, y)\n        else getOffset (unbox parent.offsetParent) (x-parent.offsetLeft, y-parent.offsetTop)\n      let rec getParent (parent:HTMLElement) = \n        // Safari: Skip over all the elements nested inside <svg> as they are weird\n        // IE: Use parentNode when parentElement is not available (inside <svg>?)\n        if parent.namespaceURI = \"http://www.w3.org/2000/svg\" && parent.tagName <> \"svg\" then\n          if parent.parentElement <> null then getParent parent.parentElement\n          else getParent (unbox parent.parentNode)\n        elif parent.offsetParent <> null then parent \n        elif parent.parentElement <> null then getParent parent.parentElement\n        else getParent (unbox parent.parentNode)\n      getOffset (getParent el) (x, y)\n    \n    let mouseHandler kind el (evt:Event) =\n      let evt = evt :?> MouseEvent\n      let x, y = getRelativeLocation el evt.pageX evt.pageY\n      triggerEvent projected evt (MouseEvent(kind, (COV(CO x), COV(CO y))))\n\n    let touchHandler kind el (evt:Event) =\n      let evt = evt :?> TouchEvent\n      let touch = evt.touches.[0]\n      let x, y = getRelativeLocation el touch.pageX touch.pageY\n      triggerEvent projected evt (TouchEvent(kind, (COV(CO x), COV(CO y))))\n\n    let counter = ref 0\n    let renderCtx = \n      { Definitions = defs }\n\n    h?div [\"style\"=>sprintf \"width:%dpx;height:%dpx;margin:0px auto 0px auto\" (int width) (int height)] [\n      s?svg [\n          \"width\"=>string (int width); \"height\"=> string(int height); \n          \"click\" =!> mouseHandler MouseEventKind.Click\n          \"mousemove\" =!> mouseHandler MouseEventKind.Move\n          \"mousedown\" =!> mouseHandler MouseEventKind.Down\n          \"mouseup\" =!> mouseHandler MouseEventKind.Up\n          \"mouseleave\" =!> fun _ evt -> triggerEvent projected evt MouseLeave\n          \"touchmove\" =!> touchHandler TouchEventKind.Move\n          \"touchstart\" =!> touchHandler TouchEventKind.Start\n          \"touchend\" =!> fun _ evt -> triggerEvent projected evt TouchEnd\n        ] [\n          let body = renderSvg renderCtx svg |> Array.ofSeq\n          yield! defs\n          yield! body\n        ]\n    ]","﻿namespace TheGamma.Interactive\n\nopen Fable.Core\nopen Fable.Helpers\nopen Fable.Import.Browser\n\nopen TheGamma.Common\nopen TheGamma.Series\nopen TheGamma.Html\nopen TheGamma.Interactive.Compost\nopen TheGamma.Interactive.Compost.Derived\n\nmodule FsOption = Microsoft.FSharp.Core.Option\n\n// ------------------------------------------------------------------------------------------------\n// Chart options\n// ------------------------------------------------------------------------------------------------\n\ntype AxisOptions = \n  { minValue : obj option\n    maxValue : obj option \n    label : string option\n    labelOffset : float option \n    labelMinimalSize : float option }\n  static member Default = { minValue = None; maxValue = None; label = None; labelOffset = None; labelMinimalSize = None }\n\ntype LegendOptions = \n  { position : string }\n  static member Default = { position = \"none\" }\n\ntype ChartOptions =\n  { size : float option * float option \n    xAxis : AxisOptions\n    yAxis : AxisOptions \n    title : string option\n    legend : LegendOptions\n    emptyMessage : string option } \n  static member Default = \n    { size = None, None; title = None\n      legend = LegendOptions.Default\n      xAxis = AxisOptions.Default\n      yAxis = AxisOptions.Default\n      emptyMessage = None }\n\n// ------------------------------------------------------------------------------------------------\n// Rendering helpers\n// ------------------------------------------------------------------------------------------------\n\nmodule InteractiveHelpers =\n  let showAppAsync outputId opts (data:series<_, _>) initial render update = async { \n    let id = \"container\" + System.Guid.NewGuid().ToString().Replace(\"-\", \"\")\n    h?div [\"id\" => id] [ ] |> renderTo (document.getElementById(outputId))        \n\n    // Get data & wait until the element is created\n    let! data = data.data |> Async.AwaitFuture \n    let mutable i = 10\n    while i > 0 && document.getElementById(id) = null do\n      do! Async.Sleep(10)\n      i <- i - 1\n    let element = document.getElementById(id)\n    if data.Length = 0 && opts.emptyMessage.IsSome then\n      h?p [\"class\"=>\"placeholder\"] [ text opts.emptyMessage.Value ] |> renderTo element\n    else\n      let size = \n        ( match opts.size with Some w, _ -> w | _ -> element.clientWidth ),\n        ( match opts.size with _, Some h -> h | _ -> max 400. (element.clientWidth / 2.) ) \n      do\n        try\n          createVirtualDomApp outputId (initial data) (render data size) (update data)\n        with e ->\n          Log.exn(\"GUI\", \"Interactive rendering failed: %O\", e) } \n\n  let showApp outputId opts data initial render update = \n    showAppAsync outputId opts data initial render update |> Async.StartImmediate \n\n  let showStaticAppAsync outputId opts data render = \n    showAppAsync outputId opts data\n      (fun _ -> ())\n      (fun _ size _ _ -> render size)\n      (fun _ _ _ -> ())\n\n  let showStaticApp outputId opts data render = \n    showApp outputId opts data\n      (fun _ -> ())\n      (fun data size _ _ -> render data size)\n      (fun _ _ _ -> ())\n\n  let calclateMax maxValue data = \n    let max = match maxValue with Some m -> m | _ -> Seq.max (Seq.map snd data)\n    snd (Scales.adjustRange (0.0, max))\n\n  let createLogger id logger = \n    match logger with\n    | Some log -> fun event data -> \n        JsInterop.createObj [\n          \"event\", box event\n          \"id\", box id\n          \"data\", JsInterop.createObj data\n        ] |> log\n    | None -> fun _ _ -> () \n\nmodule CompostHelpers = \n  let (|Cont|) = function COV(CO x) -> x | _ -> failwith \"Expected continuous value\"\n  let (|Cat|) = function CAR(CA x, r) -> x, r | _ -> failwith \"Expected categorical value\"\n  let Cont x = COV(CO x)\n  let Cat(x, r) = CAR(CA x, r)\n  let orElse (a:option<_>) b = if a.IsSome then a else b\n  let vega10 = [| \"#1f77b4\"; \"#ff7f0e\"; \"#2ca02c\"; \"#d62728\"; \"#9467bd\"; \"#8c564b\"; \"#e377c2\"; \"#7f7f7f\"; \"#bcbd22\"; \"#17becf\" |]\n  let infinitely s = \n    if Seq.isEmpty s then seq { while true do yield \"black\" }\n    else seq { while true do yield! s }\n\nopen CompostHelpers\n\n// ------------------------------------------------------------------------------------------------\n// Ordinary charts\n// ------------------------------------------------------------------------------------------------\n\nmodule Internal = \n\n  let prevAndNext (data:_[]) = \n    if data.Length = 1 then\n      [| data.[0], data.[0], data.[0] |]\n    else \n      let res = ResizeArray<_> [| data.[0], data.[0], data.[1] |]\n      for x in 1 .. data.Length - 2 do res.Add (data.[x-1], data.[x], data.[x+1])\n      res.Add(data.[data.Length - 2], data.[data.Length - 1], data.[data.Length - 1])\n      res.ToArray()\n\n  let inline interpolate (x1, y1) (x2, y2) x = \n    if x1 = x2 then [||] else \n    [| x, y1 + (y2 - y1) * (x - x1) / (x2 - x1) |]\n\n  let inline interpolateAt x points = \n    let p, n = points |> Seq.pairwise |> Seq.find (fun ((p, _), (n, _)) -> p <= x && n >= x)\n    interpolate p n x |> Seq.head\n\n  let inline cropLine points lx hx = \n    let inRange = \n      points \n      |> prevAndNext \n      |> Array.filter (fun (p, (x, y), n) -> x > lx && x < hx)\n    if inRange.Length = 0 then [||] else\n    let (s1, s2, _), (_, e1, e2) = inRange.[0], inRange.[inRange.Length-1]\n    let core = inRange |> Array.map (fun (_, v, _) -> v)\n    Array.concat [interpolate s1 s2 lx; core; interpolate e1 e2 hx]\n\n  // Helpers\n  let arrayMap f s = Array.map f s // REVIEW: Hack to avoid Float64Array (which behaves oddly in Safari) see: https://github.com/zloirock/core-js/issues/285\n\n  let parseColor (clr:string) = \n    let r = parseInt (clr.Substring(1,2)) 16\n    let g = parseInt (clr.Substring(3,2)) 16\n    let b = parseInt (clr.Substring(5,2)) 16\n    float r, float g, float b\n\n  let formatColor (r, g, b) = \n    let fi n = (formatInt (int n) 16).PadLeft(2, '0')\n    \"#\" + fi r + fi g + fi b\n\n  let mapColor f (clr:string) = \n    formatColor (f (parseColor clr))\n\n  type ScalePoints = \n    { Minimum : Value<1>; Maximum : Value<1>; Middle : Value<1>; PixelSize : float }\n\n  type ChartContext = \n    { Chart : Shape<1, 1> \n      Width : float\n      Height : float\n      XPoints : ScalePoints \n      YPoints : ScalePoints\n      XData : obj[]\n      YData : obj[]\n      Padding : float * float * float * float\n      ChartOptions : ChartOptions }\n\n  let calculateScales (width, height) chart = \n    let (Scales.Scaled((sx, sy), _, _)) as scaled = Scales.calculateScales Compost.defstyle chart\n    let getPoints = function\n      | Continuous(CO lo, CO hi) as scale -> \n        // Calculate projection and calculate pixel size\n        let master = Projections.Scale((0.0, width), (height, 0.0))\n        let (Projections.Projected(projection, _, _)) = Projections.calculateProjections scaled master\n        let (Cont z, _) = Projections.projectInv (scale, scale) (CO 100.0, CO 0.0) projection\n        let (Cont o, _) = Projections.projectInv (scale, scale) (CO 101.0, CO 0.0) projection\n        { Minimum = COV(CO lo); Maximum = COV(CO hi); Middle = COV(CO ((hi + lo) / 2.)); PixelSize = abs (z - o) }\n      | Categorical(vals) -> \n        { Minimum = CAR(vals.[0], 0.0); Maximum = CAR(vals.[vals.Length-1], 1.0)\n          Middle = if vals.Length % 2 = 1 then CAR(vals.[vals.Length/2], 0.5)\n                   else CAR(vals.[vals.Length/2], 0.0)\n          PixelSize = 0.0 } // TODO: This should probably not be allowed\n    getPoints sx, getPoints sy\n\n  let initChart size xdata ydata options chart =\n    let px, py = calculateScales size chart \n    { Chart = chart; XPoints = px; YPoints = py; Padding = (20., 20., 20., 20.)\n      XData = xdata; YData = ydata; ChartOptions = options \n      Width = fst size; Height = snd size }\n\n  let applyStyle f chart = \n    Style(f, chart)\n\n  let applyStyleCtx f ctx = \n    { ctx with Chart = Style(f, ctx.Chart) }\n\n  let applyInteractive e chart = \n    Interactive(e, chart)\n\n  let applyInteractiveCtx e ctx = \n    { ctx with Chart = Interactive(e ctx, ctx.Chart) }\n\n  /// Add InnerScale (when scales are set explicitly) and AutoScale for the rest\n  /// Recalculate points after changing the scales to make sure they're up to date\n  let applyScales ctx = \n    let getInnerScale axis sp = \n      match sp with\n      | _ when axis.minValue = None && axis.maxValue = None -> None \n      | { Minimum = COV(CO lo); Maximum = COV(CO hi) } ->\n          let amin = FSharp.Core.Option.map dateOrNumberAsNumber axis.minValue\n          let amax = FSharp.Core.Option.map dateOrNumberAsNumber axis.maxValue\n          let lo, hi = defaultArg amin lo, defaultArg amax hi\n          Some(CO(unbox lo), CO(unbox hi))\n      | _ -> None\n    let sx = getInnerScale ctx.ChartOptions.xAxis ctx.XPoints\n    let sy = getInnerScale ctx.ChartOptions.yAxis ctx.YPoints\n    let chart = AutoScale(sx.IsNone, sy.IsNone, InnerScale(sx, sy, ctx.Chart))\n    let xp, yp = calculateScales (ctx.Width, ctx.Height) chart \n    { ctx with Chart = chart; XPoints = xp; YPoints = yp }\n\n  /// \n  let applyAxes tlab rlab blab llab ctx = \n    let style data =\n      let isDate = data |> Seq.exists isDate\n      if isDate then\n        let values = data |> arrayMap dateOrNumberAsNumber\n        let lo, hi = asDate(Seq.min values), asDate(Seq.max values)\n        if (hi - lo).TotalDays <= 1. then fun _ (Cont v) -> formatTime(asDate(v))\n        else fun _ (Cont v) -> formatDate(asDate(v))\n      else Compost.defaultFormat\n    let chart =\n      Axes(tlab, rlab, blab, llab, ctx.Chart) |> applyStyle (fun s -> \n        { s with FormatAxisXLabel = style ctx.XData; FormatAxisYLabel = style ctx.YData })\n    { ctx with Chart = Padding(ctx.Padding, chart) }    \n\n\n  let applyLegend (width, height) labels ctx =     \n    let labels = Array.ofSeq labels\n\n    match ctx.ChartOptions.legend.position, width > 600. with\n    | \"right\", _ | \"auto\", true -> \n        let ptop, _, _, _ = ctx.Padding\n        let labs = \n          InnerScale(Some(CO 0., CO 100.), None, \n              Layered\n                [ for clr, lbl in labels do\n                    let style clr = applyStyle (fun s -> { s with Font = \"9pt Roboto,sans-serif\"; Fill=Solid(1., HTML clr); StrokeColor=(0.0, RGB(0,0,0)) })\n                    yield Padding((4., 0., 4., 0.), Bar(CO 6., CA lbl)) |> style clr\n                    yield Text(COV(CO 8.), CAR(CA lbl, 0.5), VerticalAlign.Middle, HorizontalAlign.Start, 0., lbl) |> style \"black\"\n                ] ) \n        let lwid, lhgt = (width - 250.) / width, (ptop + float labels.Length * 30.) / height    \n        let chart = \n          Layered\n            [ OuterScale(Some(Continuous(CO 0.0, CO lwid)), Some(Continuous(CO 0.0, CO 1.0)), ctx.Chart)\n              OuterScale(Some(Continuous(CO lwid, CO 1.0)), Some(Continuous(CO 0.0, CO lhgt)), Padding((ptop, 0., 0., 20.), labs)) ]\n        { ctx with Chart = chart }\n\n    | \"bottom\", _ | \"auto\", false -> \n        let _, pright, _, pleft = ctx.Padding\n        let labs = \n          InnerScale(Some(CO 0., CO 100.), None, \n              Layered\n                [ for clr, lbl in labels do\n                    let style clr = applyStyle (fun s -> { s with Font = \"9pt Roboto,sans-serif\"; Fill=Solid(1., HTML clr); StrokeColor=(0.0, RGB(0,0,0)) })\n                    yield Padding((4., 0., 4., 0.), Shape[ COV(CO 94.), CAR(CA lbl, 0.); COV(CO 94.), CAR(CA lbl, 1.); COV(CO 100.), CAR(CA lbl, 1.); COV(CO 100.), CAR(CA lbl, 0.) ]) |> style clr\n                    yield Text(COV(CO 92.), CAR(CA lbl, 0.5), VerticalAlign.Middle, HorizontalAlign.End, 0., lbl) |> style \"black\"\n                ] ) \n        let lhgt = (height - float labels.Length * 30.) / height\n        let chart = \n          Layered\n            [ OuterScale(Some(Continuous(CO 0.0, CO 1.0)), Some(Continuous(CO 0.0, CO lhgt)), ctx.Chart)\n              OuterScale(Some(Continuous(CO 0.0, CO 1.0)), Some(Continuous(CO lhgt, CO 1.0)), Padding((20., pright, 0., pleft), labs)) ]\n        { ctx with Chart = chart }\n    | _ -> ctx\n\n\n  let applyLabels ctx =     \n    let ptop, pright, pbot, pleft = ctx.Padding\n    let lblStyle font chart = \n      chart |> applyStyle (fun s -> \n        { s with StrokeWidth = Pixels 0; Fill = Solid(1., HTML \"black\"); Font = font })\n\n    // X axis label, Y axis label\n    let chart = ctx.Chart\n    let chart, pbot = \n      match ctx.ChartOptions.xAxis.label, ctx.ChartOptions.xAxis.labelMinimalSize with\n      | _, Some min when ctx.Height < min -> chart, pbot\n      | Some xl, _ -> \n          let offs = defaultArg ctx.ChartOptions.xAxis.labelOffset 40.\n          let lbl = Offset((0., offs), Text(ctx.XPoints.Middle, ctx.YPoints.Minimum, VerticalAlign.Middle, HorizontalAlign.Center, 0.0, xl))\n          Layered [ chart; lblStyle \"bold 9pt Roboto,sans-serif\" lbl ], (offs + 10.) - 30. // +10 space for label, -30 because offset 30 is added by Axes\n      | _ -> chart, pbot\n    let chart, pleft = \n      match ctx.ChartOptions.yAxis.label, ctx.ChartOptions.yAxis.labelMinimalSize with\n      | _, Some min when ctx.Width < min -> chart, pbot\n      | Some yl, _ -> \n          let offs = defaultArg ctx.ChartOptions.yAxis.labelOffset 60.\n          let lbl = Offset((-offs, 0.), Text(ctx.XPoints.Minimum, ctx.YPoints.Middle, VerticalAlign.Middle, HorizontalAlign.Center, -90.0, yl))\n          Layered [ chart; lblStyle \"bold 9pt Roboto,sans-serif\" lbl ], (offs + 10.) - 50. // +10 space for label, -50 because offset 50 is added by Axes\n      | _ -> chart, pleft\n\n    // Chart title\n    let chart, ptop = \n      match ctx.ChartOptions.title with \n      | Some title ->\n          let ttl = Offset((0., -30.), Text(ctx.XPoints.Middle, ctx.YPoints.Maximum, VerticalAlign.Hanging, HorizontalAlign.Center, 0.0, title))\n          Layered [ chart; lblStyle \"13pt Roboto,sans-serif\" ttl ], 40.\n      | _ -> chart, ptop\n\n    { ctx with Chart = chart; Padding = (ptop, pright, pbot, pleft) }\n\n  let createChart size ctx =   \n    h?div [\"style\"=>\"text-align:center;padding-top:20px\"] [\n      Compost.createSvg false false size ctx.Chart\n    ]\n        \n  let inAxis axis value =\n    if axis.minValue.IsSome && dateOrNumberAsNumber value < dateOrNumberAsNumber axis.minValue.Value then false\n    elif axis.maxValue.IsSome && dateOrNumberAsNumber value > dateOrNumberAsNumber axis.maxValue.Value then false\n    else true\n                \nmodule Charts = \n  open Internal\n\n  // Charts\n  \n  let renderBubbles trigger selectedBubble chartOptions size bc (data:(obj * obj * obj option * obj option)[]) =   \n    let xdata, ydata = Array.map (fun (x, _, _, _) -> x) data, Array.map (fun (_, y, _, _) -> y) data    \n    let tryFindBubble rx ry px py = \n      data \n      |> Seq.tryFindIndex (fun (x, y, s, _) ->\n        let size = unbox (defaultArg s (box 2.))\n        let rx, ry = rx * size * 2., ry * size * 2.\n        let x, y = dateOrNumberAsNumber x, dateOrNumberAsNumber y\n        ((px - x)*(px - x))/(rx*rx) + ((py - y)*(py - y))/(ry*ry) < 1.0 )\n    Layered [\n      for i, (x, y, s, l) in Seq.mapi (fun i v -> i, v) data do\n        if inAxis chartOptions.xAxis x && inAxis chartOptions.yAxis y then\n          let size = unbox (defaultArg s (box 2.))\n          let b = Bubble(COV(CO (dateOrNumberAsNumber x)), COV(CO (dateOrNumberAsNumber y)), size, size) \n          let alpha = if i = selectedBubble then 1.0 else 0.6\n          yield b |> applyStyle (fun s -> { s with StrokeWidth = Pixels 0; Fill = Solid(alpha, HTML bc) }) \n      for i, (x, y, s, l) in Seq.mapi (fun i v -> i, v) data do\n        if i = selectedBubble && l.IsSome then\n          let t = Text(COV(CO (dateOrNumberAsNumber x)), COV(CO (dateOrNumberAsNumber y)), VerticalAlign.Baseline, HorizontalAlign.Center, 0., unbox l.Value)\n          yield t |> applyStyle (fun s -> { s with Font = \"10pt roboto,sans-serif\"; StrokeWidth = Pixels 0; Fill = Solid(1., HTML \"black\") }) ]\n    |> initChart size xdata ydata chartOptions\n    |> applyInteractiveCtx (fun ctx -> \n        [ TouchStart(fun evt (Cont x, Cont y) -> \n            let bub = defaultArg (tryFindBubble ctx.XPoints.PixelSize ctx.YPoints.PixelSize x y) -1\n            if bub <> selectedBubble then trigger bub )\n          MouseMove(fun evt (Cont x, Cont y) -> \n            let bub = defaultArg (tryFindBubble ctx.XPoints.PixelSize ctx.YPoints.PixelSize x y) -1\n            if bub <> selectedBubble then trigger bub)\n          MouseLeave(fun _ -> trigger -1) ])\n    |> applyScales \n    |> applyLabels \n    |> applyAxes false false true true\n    //|> applyLegend chartOptions\n    |> createChart size \n\n  let renderLines isArea chartOptions size lcs labels (data:(obj * obj)[][]) =   \n    let xdata, ydata = Array.collect (Array.map fst) data, Array.collect (Array.map snd) data    \n    Layered [\n      for clr, line in Seq.zip (infinitely lcs) data do\n        let points = \n          [ for x, y in line do\n              if inAxis chartOptions.xAxis x && inAxis chartOptions.yAxis y then\n                yield COV(CO (dateOrNumberAsNumber x)), COV(CO (dateOrNumberAsNumber y)) ]\n        if not (List.isEmpty points) then \n          if isArea then yield Area points |> applyStyle (fun s -> { s with Fill = Solid(0.4, HTML clr); StrokeWidth = Pixels 0  })\n          yield Line points |> applyStyle (fun s -> { s with StrokeColor = 1.0, HTML clr; StrokeWidth = Pixels 2  }) ]\n    |> initChart size xdata ydata chartOptions\n    |> applyScales \n    |> applyLabels\n    |> applyAxes false false true true    \n    |> applyLegend size (Seq.zip (infinitely lcs) labels)\n    |> createChart size \n\n  let renderColsBars isBar inlineLabels chartOptions size clrs labels (data:(string * float)[]) =   \n    let xdata, ydata = \n      if isBar then Array.map (snd >> box) data, Array.map (fst >> box) data    \n      else Array.map (fst >> box) data, Array.map (snd >> box) data    \n    \n    let { XPoints = xp; YPoints = yp } =\n      Layered [ for lbl, v in data -> if isBar then Bar(CO v, CA lbl) else Column(CA lbl, CO v) ] \n      |> initChart size xdata ydata chartOptions |> applyScales \n    \n    let chartOptions = \n      if isBar && inlineLabels && chartOptions.yAxis.labelOffset.IsNone then { chartOptions with yAxis = { chartOptions.yAxis with labelOffset = None } }\n      elif not isBar && inlineLabels && chartOptions.yAxis.labelOffset.IsNone then { chartOptions with xAxis = { chartOptions.xAxis with labelOffset = None } }\n      else chartOptions\n\n    Layered [\n      for clr, (lbl, v) in Seq.zip (infinitely clrs) data do\n        let elem = \n          if isBar then Padding((6.,0.,6.,1.), Bar(CO v, CA lbl))\n          else Padding((0.,6.,1.,6.), Column(CA lbl, CO v)) \n        let label = \n          if not inlineLabels then None\n          elif isBar then Some(Offset((20., 0.), Text(xp.Minimum, CAR(CA lbl, 0.5), VerticalAlign.Middle, HorizontalAlign.Start, 0.0, lbl)))\n          else Some(Offset((0., -20.), Text(CAR(CA lbl, 0.5), yp.Minimum, VerticalAlign.Middle, HorizontalAlign.Start, -90.0, lbl)))\n        yield elem |> applyStyle (fun s -> { s with Fill = Solid(0.6, HTML clr) }) \n        if label.IsSome then\n          let clr = clr |> mapColor (fun (r,g,b) -> r*0.8, g*0.8, b*0.8)\n          yield label.Value |> applyStyle (fun s -> { s with Font = \"11pt Roboto,sans-serif\"; Fill = Solid(1.0, HTML clr); StrokeWidth = Pixels 0 }) ]\n    |> initChart size xdata ydata chartOptions\n    |> applyScales \n    |> applyLabels\n    |> applyAxes false false (not (inlineLabels && not isBar)) (not (inlineLabels && isBar))\n    |> applyLegend size (Seq.zip (infinitely clrs) labels)\n    |> createChart size \n\n// ------------------------------------------------------------------------------------------------\n// You Guess Line\n// ------------------------------------------------------------------------------------------------\n\nmodule YouGuessLineHelpers = \n  open Internal\n\n  type YouDrawEvent = \n    | ShowResults\n    | Draw of float * float\n\n  type Status = \n    | Autofilled of float\n    | Set of float\n    | NotSet\n    \n  type YouDrawState = \n    { Completed : bool\n      Clip : float\n      Data : (float * float)[]\n      XData : obj[]\n      YData : obj[]\n      Guessed : (float * Status)[] \n      IsKeyDate : bool }\n\n  let initState completed data clipx = \n    let isDate = data |> Seq.exists (fst >> isDate)\n    let numData = data |> Array.map (fun (k, v) -> dateOrNumberAsNumber k, v)\n    { Completed = completed\n      Data = numData\n      XData = Array.map (fst >> box) data\n      YData = Array.map (snd >> box) data\n      Clip = clipx\n      IsKeyDate = isDate\n      Guessed = \n        [| for x, y in numData do \n            if x > clipx then \n              if completed then yield x, Set y \n              else yield x, NotSet |] }\n\n  let handler log state evt = \n    let collectData () = state.Data |> Array.map (fun (k, v) -> [| box k; box v |]) |> box\n    let collectGuesses () = state.Guessed |> Seq.choose (function (k, Set v) -> Some [| box k; box v |] | _ -> None) |> Array.ofSeq |> box\n    match evt with\n    | ShowResults -> \n        log \"completed\" [ \"guess\", collectGuesses(); \"values\", collectData() ]\n        { state with Completed = true }\n    | Draw (downX, downY) ->\n        let indexed = Array.indexed state.Guessed\n        let nearest, _ = indexed |> Array.minBy (fun (_, (x, _)) -> abs (downX - x))\n        { state with\n            Guessed = indexed |> Array.map (fun (i, (x, y)) -> \n              match y with\n              | _ when i = nearest -> (x, Set downY) \n              | NotSet when i > nearest -> (x, Autofilled downY)\n              | _ -> (x, y) ) }\n\n  let render (solvedComment:string option) interactive chartOptions (width, height) (markers:(float*obj)[]) (leftLbl, rightLbl) \n    (leftClr,rightClr,guessClr,markClr) trigger state = \n\n    let all = \n      [| for x, y in state.Data -> Cont x, Cont y |]\n    let known = \n      [| for x, y in state.Data do if x <= state.Clip then yield Cont x, Cont y |]\n    let right = \n      [| yield Array.last known\n         for x, y in state.Data do if x > state.Clip then yield Cont x, Cont y |]\n    let guessed = \n      [| yield Array.last known\n         for x, y in state.Guessed do match y with Set v | Autofilled v -> yield Cont x, Cont v | _ -> () |]\n\n\n    let loy = match chartOptions.yAxis.minValue with Some v -> unbox v | _ -> state.Data |> Seq.map snd |> Seq.min\n    let hiy = match chartOptions.yAxis.maxValue with Some v -> unbox v | _ -> state.Data |> Seq.map snd |> Seq.max       \n    let lx, ly = (fst (Seq.head state.Data) + float state.Clip) / 2., loy + (hiy - loy) / 10.\n    let rx, ry = (fst (Seq.last state.Data) + float state.Clip) / 2., loy + (hiy - loy) / 10.\n    let tx, ty = float state.Clip, hiy - (hiy - loy) / 10.\n    let setColor c s = { s with Font = \"12pt Roboto,sans-serif\"; Fill=Solid(1.0, HTML c); StrokeColor=(0.0, RGB(0,0,0)) }\n    let labels = \n      Shape.Layered [\n        Style(setColor leftClr, Shape.Text(COV(CO lx), COV(CO ly), VerticalAlign.Baseline, HorizontalAlign.Center, 0., leftLbl))\n        Style(setColor rightClr, Shape.Text(COV(CO rx), COV(CO ry), VerticalAlign.Baseline, HorizontalAlign.Center, 0., rightLbl))\n      ]\n\n    let LineStyle shape = \n      Style((fun s -> \n        { s with \n            Fill = Solid(1.0, HTML \"transparent\"); \n            StrokeWidth = Pixels 2; \n            StrokeDashArray = [Integer 5; Integer 5]\n            StrokeColor=0.6, HTML markClr }), shape)\n    let FontStyle shape = \n      Style((fun s -> { s with Font = \"11pt Roboto,sans-serif\"; Fill = Solid(1.0, HTML markClr); StrokeColor = 0.0, HTML \"transparent\" }), shape)\n    \n    let loln, hiln = Scales.adjustRange (loy, hiy)\n    let markers = [\n        for i, (x, lbl) in Seq.mapi (fun i v -> i, v) markers do\n          let kl, kt = if i % 2 = 0 then 0.90, 0.95 else 0.80, 0.85\n          let ytx = loln + (hiln - loln) * kt\n          let hiln = loln + (hiln - loln) * kl\n          yield Line [(COV(CO x), COV(CO loln)); (COV(CO x), COV(CO hiln))] |> LineStyle\n          yield Text(COV(CO x), COV(CO ytx), VerticalAlign.Middle, HorizontalAlign.Center, 0., string lbl) |> FontStyle\n      ]\n\n    let coreChart = \n      Layered [\n        yield labels\n        yield! markers\n        yield Style(Drawing.hideFill >> Drawing.hideStroke, Line all)\n        yield Style(\n          (fun s -> { s with StrokeColor = (1.0, HTML leftClr); Fill = Solid(0.2, HTML leftClr) }), \n          Layered [ Area known; Line known ]) \n        if state.Completed then\n          yield Style((fun s -> \n            { s with \n                StrokeColor = (1.0, HTML rightClr)\n                StrokeDashArray = [ Percentage 0.; Percentage 100. ]\n                Fill = Solid(0.0, HTML rightClr)\n                Animation = Some(1000, \"ease\", fun s -> \n                  { s with\n                      StrokeDashArray = [ Percentage 100.; Percentage 0. ]\n                      Fill = Solid(0.2, HTML rightClr) } \n                ) }), \n            Layered [ Area right; Line right ])                 \n        if guessed.Length > 1 then\n          yield Style(\n            (fun s -> { s with StrokeColor = (1.0, HTML guessClr); StrokeDashArray = [ Integer 5; Integer 5 ] }), \n            Line guessed ) ]\n    \n    let { Internal.ChartContext.Chart = chart } = \n      coreChart\n      |> initChart (width, height) state.XData state.YData chartOptions \n      |> applyScales \n      |> applyLabels \n      |> applyAxes false false true true\n\n    let chart =\n      chart |> applyInteractive\n          ( if state.Completed then []\n            else\n              [ MouseMove(fun evt (Cont x, Cont y) -> \n                  if (int evt.buttons) &&& 1 = 1 then trigger(Draw(x, y)) )\n                TouchMove(fun evt (Cont x, Cont y) -> \n                  trigger(Draw(x, y)) )\n                MouseDown(fun evt (Cont x, Cont y) -> trigger(Draw(x, y)) )\n                TouchStart(fun evt (Cont x, Cont y) -> trigger(Draw(x, y)) ) ])\n    \n    h?div [\"style\"=>\"text-align:center;padding-top:20px\"] [\n      yield Compost.createSvg false false (width, height) chart\n      if state.Completed && solvedComment.IsSome then\n        yield h?div [\"style\"=>\"padding-bottom:20px\"] [\n          h?p [\"class\"=>\"solved\"] [text solvedComment.Value]\n        ]\n      elif interactive then\n        yield h?div [\"style\"=>\"padding-bottom:20px\"] [\n          h?button [\n              yield \"type\" => \"button\"\n              yield \"click\" =!> fun _ _ -> trigger ShowResults\n              if state.Guessed |> Seq.last |> snd = NotSet then\n                yield \"disabled\" => \"disabled\"\n            ] [ text \"Show me how I did\" ]\n          ]\n    ]\n\n// ------------------------------------------------------------------------------------------------\n// You Guess Line offset\n// ------------------------------------------------------------------------------------------------\n\nmodule YouGeussLineOffsetHelpers = \n  open Internal\n\n  type YouDrawEvent =   \n    | Animate\n    | HideOverlay\n    | ShowResults\n    | StopMoving\n    | StartMoving of float\n    | ContinueMoving of float\n\n  type YouDrawState = \n    { Completed : bool\n      Interactive : bool\n      Data : (float * float)[]\n      XData : obj[]\n      YData : obj[]\n      IsKeyDate : bool\n      OffsetStart : float option\n      Offset : float \n      OffsetRange : float * float\n      XRange : float * float\n      YRange : float * float \n      OverlayHiding : bool\n      OverlayOpacity : float\n      CompletionStep : float\n      ChartOptions : ChartOptions }\n\n  let initState completed chartOptions data = \n    let isDate = data |> Seq.exists (fst >> isDate)\n    let numData = data |> Array.map (fun (k, v) -> dateOrNumberAsNumber k, v)\n\n    let range axis data = \n      dateOrNumberAsNumber (defaultArg axis.minValue (box (Seq.min data))),\n      dateOrNumberAsNumber (defaultArg axis.maxValue (box (Seq.max data)))\n    let lx, hx = range chartOptions.xAxis (Seq.map snd numData)\n    let ly, hy = range chartOptions.yAxis (Seq.map fst numData)\n    let minData = data |> Seq.map (fst >> dateOrNumberAsNumber) |> Seq.min\n    let maxData = data |> Seq.map (fst >> dateOrNumberAsNumber) |> Seq.max\n\n    { Completed = completed\n      Interactive = not completed\n      ChartOptions = chartOptions\n      Data = numData\n      XData = Array.map (snd >> box) data\n      YData = Array.map (fst >> box) data\n      IsKeyDate = isDate \n      Offset = ly - minData\n      OffsetRange = hy - maxData, ly - minData\n      OffsetStart = None\n      XRange = lx, hx\n      YRange = ly, hy \n      OverlayHiding = completed\n      OverlayOpacity = if completed then 1. else 0.\n      CompletionStep = if completed then 1. else 0. }\n\n  let handler log state evt = \n    let collectData () = state.Data |> Array.map (fun (k, v) -> [| box k; box v |]) |> box\n    match evt with\n    | StopMoving -> { state with OffsetStart = None }\n    | HideOverlay -> { state with OverlayOpacity = state.OverlayOpacity + 0.1 }\n    | StartMoving y -> \n        { state with OffsetStart = Some (y - state.Offset); OverlayHiding = true }\n    | ContinueMoving y -> \n        let lo, hi = state.OffsetRange\n        if state.OffsetStart.IsNone then state // should not happen\n        else { state with Offset = min hi (max lo (y - state.OffsetStart.Value)) }\n    | ShowResults -> \n        log \"completed\" [ \"offset\", box state.Offset; \"values\", collectData() ]\n        { state with Completed = true }\n    | Animate -> { state with CompletionStep = min 1.0 (state.CompletionStep + 0.05) }\n\n  let render (solvedComment:string option) interactive (width, height) labels (markers:(float*obj)[]) (guessClr, correctClr, markerClr) trigger state = \n    if state.Completed && state.CompletionStep < 1.0 then\n      window.setTimeout((fun () -> trigger Animate), 50) |> ignore\n    if state.OverlayHiding && state.OverlayOpacity < 1. then\n      window.setTimeout((fun () -> trigger HideOverlay), 50) |> ignore\n\n    let (lx, hx), (ly, hy) = state.XRange, state.YRange\n    let visiblePoints offset = \n      let lo = dateOrNumberAsNumber state.ChartOptions.yAxis.minValue.Value - offset\n      let hi = dateOrNumberAsNumber state.ChartOptions.yAxis.maxValue.Value - offset\n      cropLine state.Data lo hi |> Array.map (fun (y, x) -> COV(CO x), COV(CO (y + offset)))\n\n    let coreChart = \n      Layered [\n        for (y, str), label in Seq.zip markers labels do\n          let _, inx = state.Data |> Seq.map (fun (y, x) -> y + state.Offset * (1.0 - state.CompletionStep), x) |> interpolateAt y\n          let b = Bubble(COV(CO hx), COV(CO y), 4., 4.) \n          let t = Offset((0., 5.), Text(COV(CO hx), COV(CO y), VerticalAlign.Hanging, HorizontalAlign.End, 0.0, label))\n          yield t |> applyStyle (fun s -> { s with StrokeWidth = Pixels 0; Fill = Solid(0.8, HTML markerClr) }) \n          let l = Line [COV(CO inx), COV(CO y); COV(CO hx), COV(CO y)] \n          yield l |> applyStyle (fun s -> { s with StrokeWidth = Pixels 2; StrokeColor = 0.8, HTML markerClr }) \n\n        if not state.Completed then\n          yield Style(\n            (fun s -> { s with Fill = Solid(0.5, HTML guessClr) }), \n            VShiftedArea(lx, visiblePoints state.Offset) )\n        if state.Interactive then\n          yield Style(\n            (fun s -> { s with StrokeColor = (1.0, HTML guessClr); StrokeDashArray = [ Integer 5; Integer 5 ] }), \n            Line(visiblePoints state.Offset) )\n\n        if state.Completed then \n          let r1, g1, b1 = parseColor guessClr\n          let r2, g2, b2 = parseColor correctClr\n          let dc c1 c2 = (1.0 - state.CompletionStep) * c1 + state.CompletionStep * c2\n          let clr = formatColor (dc r1 r2, dc g1 g2, dc b1 b2)\n          let correct = visiblePoints (state.Offset * (1.0 - state.CompletionStep))\n          yield Style(\n            (fun s -> { s with Fill = Solid(0.5, HTML clr) }), \n            VShiftedArea(lx, correct) )\n          yield Style(\n            (fun s -> { s with StrokeColor = (1.0, HTML clr) }), \n            Layered [ Line correct]) \n        \n        yield \n          Shape [ \n            COV(CO lx), COV(CO ly); COV(CO lx), COV(CO hy);\n            COV(CO hx), COV(CO hy); COV(CO hx), COV(CO ly) ]\n          |> applyStyle (fun x -> { x with Fill = Solid(0.75 * (1. - state.OverlayOpacity), HTML \"#eaeaea\") })\n\n      ] |> applyStyle(fun s -> \n        let cursor = \n          if state.Completed then \"\"\n          //elif state.OffsetStart.IsSome then \"move,grabbing,-moz-grabbing,-webkit-grabbing\" \n          else \"move,grab,-moz-grab,-webkit-grab\"\n        { s with Cursor = cursor }) \n\n    let { Internal.ChartContext.Chart = chart } = \n      coreChart\n      |> initChart (width, height) state.XData state.YData state.ChartOptions \n      |> applyScales \n      |> applyLabels \n      |> applyAxes false false true true\n\n    let chart =\n      Padding((20., 0., 0., 0.), chart)\n      |> applyInteractive\n          ( if state.Completed then []\n            else\n              [ MouseUp(fun _ _ -> trigger(StopMoving))\n                TouchEnd(fun _ -> trigger(StopMoving))\n                MouseMove(fun evt (Cont x, Cont y) -> \n                  if (int evt.buttons) &&& 1 = 1 then trigger(ContinueMoving y) )\n                TouchMove(fun evt (Cont x, Cont y) -> trigger(ContinueMoving y) )\n                MouseDown(fun evt (Cont x, Cont y) -> trigger(StartMoving y) ) \n                TouchStart(fun evt (Cont x, Cont y) -> trigger(StartMoving y) ) ])\n    \n    h?div [\"style\"=>\"text-align:center;padding-top:20px\"] [\n      yield h?div [\"style\" => sprintf \"width:%dpx; height:0px; margin:0px auto 0px auto\" (int width) ] [\n        h?div [\"style\" => \n          \"pointer-events:none; move,grab,-moz-grab,-webkit-grab;\" +\n          sprintf \"opacity:%f; width:50px; height:70px; border-radius:15px; background:#808080;\" (0.5 * (1. - state.OverlayOpacity)) + \n          sprintf \"position:relative; left:%dpx;top:%dpx\" (int (width - 50.) / 2 + 45) (int (height - 70.) / 2 - 30) ] [\n          h?i [ \"style\" => \"margin:12px 0px 0px 1px;font-size:42px;color:#f0f0f0\"; \"class\" => \"fa fa-hand-o-down\" ] []\n        ]\n      ]\n\n      yield Compost.createSvg false state.IsKeyDate (width, height) chart\n      if state.Completed && solvedComment.IsSome then\n        yield h?div [\"style\"=>\"padding-bottom:20px\"] [\n          h?p [\"class\"=>\"solved\"] [text solvedComment.Value]\n        ]\n      elif interactive then\n        yield h?div [\"style\"=>\"padding-bottom:20px\"] [\n          h?button [\n              yield \"type\" => \"button\"\n              yield \"click\" =!> fun _ _ -> trigger ShowResults\n              if state.OverlayOpacity < 1. then\n                yield \"disabled\" => \"disabled\"\n            ] [ text \"Show me how I did\" ]\n          ]\n    ]\n            \n// ------------------------------------------------------------------------------------------------\n// You Guess Bar & You Guess Column\n// ------------------------------------------------------------------------------------------------\n\nmodule YouGuessColsHelpers = \n  open Internal\n\n  type YouGuessState = \n    { Completed : bool\n      CompletionStep : float\n      Default : float\n      Maximum : float\n      XData : obj[]\n      YData : obj[]\n      Data : (string * float)[]\n      Guesses : Map<string, float> }\n\n  type YouGuessEvent = \n    | ShowResults \n    | Animate \n    | Update of string * float\n\n  let initState completed isBar data maxValue =     \n    { Completed = completed\n      CompletionStep = 0.0\n      Data = data \n      XData = if isBar then arrayMap (snd >> box) data else arrayMap (fst >> box) data\n      YData = if isBar then arrayMap (fst >> box) data else arrayMap (snd >> box) data\n      Default = Array.averageBy snd data\n      Maximum = InteractiveHelpers.calclateMax maxValue data\n      Guesses = if completed then Map.ofSeq data else Map.empty }\n\n  let update log state evt = \n    let collectData () = state.Data |> Array.map (fun (k, v) -> [| box k; box v |]) |> box\n    let collectGuesses () = state.Guesses |> Seq.map (fun (KeyValue(k, v)) -> [| box k; box v |]) |> Array.ofSeq |> box\n    match evt with\n    | ShowResults -> \n        log \"completed\" [ \"guess\", collectGuesses(); \"values\", collectData() ]\n        { state with Completed = true }\n    | Animate -> { state with CompletionStep = min 1.0 (state.CompletionStep + 0.05) }\n    | Update(k, v) -> { state with Guesses = Map.add k v state.Guesses }\n\n  let renderCols (solvedComment:string option) interactive (width, height) topLabel trigger state = \n    if state.Completed && state.CompletionStep < 1.0 then\n      window.setTimeout((fun () -> trigger Animate), 50) |> ignore\n    let chart = \n      Axes(false, false, true, true, \n        AutoScale(false, true, \n          Interactive\n            ( ( if state.Completed then []\n                else\n                  [ EventHandler.MouseMove(fun evt (Cat(x, _), Cont y) ->\n                      if (int evt.buttons) &&& 1 = 1 then trigger (Update(x, y)) )\n                    EventHandler.MouseDown(fun evt (Cat(x, _), Cont y) ->\n                      trigger (Update(x, y)) )\n                    EventHandler.TouchStart(fun evt (Cat(x, _), Cont y) ->\n                      trigger (Update(x, y)) )\n                    EventHandler.TouchMove(fun evt (Cat(x, _), Cont y) ->\n                      trigger (Update(x, y)) ) ] ),\n              Style\n                ( (fun s -> if state.Completed then s else { s with Cursor = \"row-resize\" }),\n                  (Layered [\n                    yield Stack\n                      ( Horizontal, \n                        [ for clr, (lbl, value) in Seq.zip (infinitely vega10) state.Data -> \n                            let sh = Style((fun s -> { s with Fill = Solid(0.2, HTML \"#a0a0a0\") }), Column(CA lbl, CO state.Maximum )) \n                            Shape.Padding((0., 10., 0., 10.), sh) ])\n                    yield Stack\n                      ( Horizontal, \n                        [ for clr, (lbl, value) in Seq.zip (infinitely vega10) state.Data -> \n                            let alpha, value = \n                              match state.Completed, state.Guesses.TryFind lbl with\n                              | true, Some guess -> 0.6, state.CompletionStep * value + (1.0 - state.CompletionStep) * guess\n                              | _, Some v -> 0.6, v\n                              | _, None -> 0.2, state.Default\n                            let sh = Style((fun s -> { s with Fill = Solid(alpha, HTML clr) }), Column(CA lbl, CO value)) \n                            Shape.Padding((0., 10., 0., 10.), sh) ])\n                    for clr, (lbl, value) in Seq.zip (infinitely vega10) state.Data do\n                      match state.Guesses.TryFind lbl with\n                      | None -> () \n                      | Some guess ->\n                          let line = Line [ CAR(CA lbl, 0.0), COV (CO guess); CAR(CA lbl, 1.0), COV (CO guess) ]\n                          yield Style(\n                            (fun s -> \n                              { s with\n                                  StrokeColor = (1.0, HTML clr)\n                                  StrokeWidth = Pixels 4\n                                  StrokeDashArray = [ Integer 5; Integer 5 ] }), \n                            Shape.Padding((0., 10., 0., 10.), line))\n                    match topLabel with\n                    | None -> ()\n                    | Some lbl ->\n                        let x = CAR(CA (fst state.Data.[state.Data.Length/2]), if state.Data.Length % 2 = 0 then 0.0 else 0.5)\n                        let y = COV(CO (state.Maximum * 0.9))\n                        yield Style(\n                          (fun s -> { s with Font = \"13pt Roboto,sans-serif\"; Fill=Solid(1.0, HTML \"#808080\"); StrokeColor=(0.0, RGB(0,0,0)) }),\n                          Text(x, y, VerticalAlign.Baseline, HorizontalAlign.Center, 0., lbl) )\n                  ]) ))))\n\n    h?div [\"style\"=>\"text-align:center;padding-top:20px\"] [\n      yield Compost.createSvg false false (width, height) chart\n      if state.Completed && solvedComment.IsSome then\n        yield h?div [\"style\"=>\"padding-bottom:20px\"] [\n          h?p [\"class\"=>\"solved\"] [text solvedComment.Value]\n        ]\n      elif interactive then \n        yield h?div [\"style\"=>\"padding-bottom:20px\"] [\n          h?button [\n              yield \"type\" => \"button\"\n              yield \"click\" =!> fun _ _ -> trigger ShowResults\n              if state.Guesses.Count <> state.Data.Length then\n                yield \"disabled\" => \"disabled\"\n            ] [ text \"Show me how I did\" ]\n          ]\n    ]\n\n\n  let renderBars (solvedComment:string option) interactive inlineLabels size chartOptions trigger state = \n    if state.Completed && state.CompletionStep < 1.0 then\n      window.setTimeout((fun () -> trigger Animate), 50) |> ignore\n\n    let chartOptions = \n      if (*isBar && *)inlineLabels && chartOptions.yAxis.labelOffset.IsNone then { chartOptions with yAxis = { chartOptions.yAxis with labelOffset = Some 10. } }\n      //elif not isBar && inlineLabels then { chartOptions with xAxis = { chartOptions.xAxis with labelOffset = Some 10. } }\n      else chartOptions\n\n    let chart = \n      Layered [\n        yield \n          Stack\n            ( Vertical, \n              [ for clr, (lbl, value) in Seq.zip (infinitely vega10) state.Data -> \n                  let sh = Style((fun s -> { s with Fill = Solid(0.2, HTML \"#a0a0a0\") }), Bar(CO state.Maximum, CA lbl)) \n                  Shape.Padding((10., 0., 10., 0.), sh) ])\n        yield Stack\n          ( Vertical, \n            [ for clr, (lbl, value) in Seq.zip (infinitely vega10) state.Data -> \n                let alpha, value = \n                  match state.Completed, state.Guesses.TryFind lbl with\n                  | true, Some guess -> 0.6, state.CompletionStep * value + (1.0 - state.CompletionStep) * guess\n                  | _, Some v -> 0.6, v\n                  | _, None -> 0.2, state.Default\n                let sh = Style((fun s -> { s with Fill = Solid(alpha, HTML clr) }), Bar(CO value, CA lbl)) \n                Shape.Padding((10., 0., 10., 0.), sh) ])\n\n        if inlineLabels then\n          for clr, (lbl, _) in Seq.zip (infinitely vega10) state.Data do \n            let x = COV(CO (state.Maximum * 0.95))\n            let y = CAR(CA lbl, 0.5)\n            yield Style(\n              (fun s -> { s with Font = \"13pt Roboto,sans-serif\"; Fill=Solid(1.0, HTML clr); StrokeColor=(0.0, RGB(0,0,0)) }),\n              Text(x, y, VerticalAlign.Middle, HorizontalAlign.End, 0., lbl) )\n\n        for clr, (lbl, value) in Seq.zip (infinitely vega10) state.Data do\n          match state.Guesses.TryFind lbl with\n          | None -> () \n          | Some guess ->\n              let line = Line [ COV (CO guess), CAR(CA lbl, 0.0); COV (CO guess), CAR(CA lbl, 1.0) ]\n              yield Style(\n                (fun s -> \n                  { s with\n                      StrokeColor = (1.0, HTML clr)\n                      StrokeWidth = Pixels 4\n                      StrokeDashArray = [ Integer 5; Integer 5 ] }), \n                Shape.Padding((10., 0., 10., 0.), line)) ]\n      |> applyInteractive\n            ( if state.Completed then []\n              else\n                [ EventHandler.MouseMove(fun evt (Cont x, Cat(y, _)) ->\n                    if (int evt.buttons) &&& 1 = 1 then trigger (Update(y, x)) )\n                  EventHandler.MouseDown(fun evt (Cont x, Cat(y, _)) ->\n                    trigger (Update(y, x)) )\n                  EventHandler.TouchStart(fun evt (Cont x, Cat(y, _)) ->\n                    trigger (Update(y, x)) )\n                  EventHandler.TouchMove(fun evt (Cont x, Cat(y, _)) ->\n                    trigger (Update(y, x)) ) ] )\n      |> applyStyle (fun s -> \n          if state.Completed then s else { s with Cursor = \"col-resize\" })\n\n    let ctx = \n      chart\n      |> initChart size state.XData state.YData chartOptions\n      |> applyScales \n      |> applyLabels\n      //|> applyAxes false false (not (inlineLabels && not isBar)) (not (inlineLabels && isBar))\n      |> applyAxes false false true (not inlineLabels)\n      |> applyLegend size (Seq.zip (infinitely vega10) (Seq.map fst state.Data))\n    \n    h?div [\"style\"=>\"text-align:center;padding-top:20px\"] [\n      yield Compost.createSvg false false size ctx.Chart\n      if state.Completed && solvedComment.IsSome then\n        yield h?div [\"style\"=>\"padding-bottom:20px\"] [\n          h?p [\"class\"=>\"solved\"] [text solvedComment.Value]\n        ]\n      elif interactive then \n        yield h?div [\"style\"=>\"padding-bottom:20px\"] [\n          h?button [\n              yield \"type\" => \"button\"\n              yield \"click\" =!> fun _ _ -> trigger ShowResults\n              if state.Guesses.Count <> state.Data.Length then\n                yield \"disabled\" => \"disabled\"\n            ] [ text \"Show me how I did\" ]\n          ]\n    ]\n\n// ------------------------------------------------------------------------------------------------\n// You Guess Sort Bars\n// ------------------------------------------------------------------------------------------------\n\nmodule YouGuessSortHelpers = \n  type YouGuessState = \n    { Data : (string * float)[] \n      Colors : System.Collections.Generic.IDictionary<string, string>\n      Assignments : Map<string, string>\n      Selected : string\n      Maximum : float \n      CompletionStep : float\n      Completed : bool }\n\n  type YouGuessEvent = \n    | SelectItem of string\n    | AssignCurrent of string\n    | ShowResults \n    | Animate \n\n  let initState completed maxValue data =     \n    { Data = data \n      CompletionStep = 0.0\n      Completed = completed\n      Colors = Seq.map2 (fun (lbl, _) clr -> lbl, clr) data vega10 |> dict \n      Selected = fst (Seq.head data)\n      Maximum = InteractiveHelpers.calclateMax maxValue data \n      Assignments = \n        if completed then Map.ofSeq [for k, _ in data -> k, k]\n        else Map.empty }\n\n  let update log state evt = \n    let collectData () = state.Data |> Array.map (fun (k, v) -> [| box k; box v |]) |> box\n    let collectGuesses () = \n      state.Assignments |> Seq.map (fun (KeyValue(vk, k)) -> \n        let v = state.Data |> Seq.pick (fun (k, v) -> if k = vk then Some v else None)\n        [| box k; box v |]) |> Array.ofSeq |> box\n    match evt with\n    | Animate -> { state with CompletionStep = min 1.0 (state.CompletionStep + 0.05) }\n    | ShowResults -> \n        log \"completed\" [ \"values\", collectData (); \"guess\", collectGuesses () ] \n        { state with Completed = true }\n    | SelectItem s -> \n        log \"select\" [ \"selection\", box s ]\n        { state with Selected = s }\n    | AssignCurrent target -> \n        let newAssigns = \n          state.Assignments\n          |> Map.filter (fun _ v -> v <> state.Selected)\n          |> Map.add target state.Selected\n        let assigned = newAssigns |> Seq.map (fun kvp -> kvp.Value) |> set\n        let newSelected = \n          state.Data\n          |> Seq.map fst \n          |> Seq.filter (assigned.Contains >> not)\n          |> Seq.tryHead\n        { state with Assignments = newAssigns; Selected = defaultArg newSelected state.Selected }\n  \n  let renderBars (solvedComment:string option) interactive (width, height) trigger (state:YouGuessState) = \n    if state.Completed && state.CompletionStep < 1.0 then\n      window.setTimeout((fun () -> trigger Animate), 50) |> ignore\n    let chart = \n      Axes(false, false, true, false, \n        AutoScale(true, false,\n          Interactive\n            ( ( if state.Completed then [] else\n                  [ EventHandler.MouseDown(fun evt (_, Cat(y, _)) -> trigger(AssignCurrent y))\n                    EventHandler.TouchStart(fun evt (_, Cat(y, _)) -> trigger(AssignCurrent y))\n                    EventHandler.TouchMove(fun evt (_, Cat(y, _)) -> trigger(AssignCurrent y)) ]),\n              Style\n                ( (fun s -> if state.Completed then s else { s with Cursor = \"pointer\" }),\n                  (Layered [\n                    yield Stack\n                      ( Vertical, \n                        [ for i, (lbl, original) in Seq.mapi (fun i v -> i, v) (Seq.sortBy snd state.Data) do\n                            let alpha, value, clr = \n                              match state.Completed, state.Assignments.TryFind lbl with\n                              | true, Some assigned -> \n                                  let _, actual = state.Data |> Seq.find (fun (lbl, _) -> lbl = assigned)\n                                  0.6, state.CompletionStep * actual + (1.0 - state.CompletionStep) * original, state.Colors.[assigned]\n                              | _, Some assigned -> 0.6, original, state.Colors.[assigned]\n                              | _, None -> 0.3, original, \"#a0a0a0\"\n\n                            if i = state.Data.Length - 1 && state.Assignments.Count = 0 then\n                              let txt = Text(COV(CO(state.Maximum * 0.05)), CAR(CA lbl, 0.5), Middle, Start, 0., \"Assign highlighted value to one of the bars by clicking on it!\")\n                              yield Style((fun s -> { s with Font = \"13pt Roboto,sans-serif\"; Fill = Solid(1.0, HTML \"#606060\"); StrokeColor=(0.0, HTML \"white\") }), txt ) \n\n                            let sh = Style((fun s -> { s with Fill = Solid(alpha, HTML clr) }), Bar(CO value, CA lbl)) \n                            if clr <> \"#a0a0a0\" then\n                              let line = Line [ COV (CO original), CAR(CA lbl, 0.0); COV (CO original), CAR(CA lbl, 1.0) ]\n                              yield Style(\n                                (fun s -> \n                                  { s with\n                                      StrokeColor = (1.0, HTML clr)\n                                      StrokeWidth = Pixels 4\n                                      StrokeDashArray = [ Integer 5; Integer 5 ] }), \n                                Shape.Padding((5., 0., 5., 0.), line))\n                            yield Shape.Padding((5., 0., 5., 0.), sh) ])\n                  ]) ))))\n\n    let labs = \n      Padding(\n        (0., 20., 20., 25.),\n        InnerScale(Some(CO 0., CO 100.), None, \n          Interactive(\n            ( if state.Completed then [] else\n                [ EventHandler.MouseDown(fun evt (_, Cat(lbl, _)) -> trigger (SelectItem lbl))\n                  EventHandler.TouchStart(fun evt (_, Cat(lbl, _)) -> trigger (SelectItem lbl)) \n                  EventHandler.TouchMove(fun evt (_, Cat(lbl, _)) -> trigger (SelectItem lbl)) ]),\n            Layered\n              [ for lbl, _ in Seq.rev state.Data do\n                  let clr = state.Colors.[lbl]\n                  let x = COV(CO 5.)\n                  let y = CAR(CA lbl, 0.5)\n                  let af, al = if state.Completed || lbl = state.Selected then 0.9, 1.0 else 0.2, 0.6\n                  yield \n                    Style((fun s -> { s with Fill=Solid(af, HTML clr)  }), \n                      Padding((2., 0., 2., 0.), Bar(CO 4., CA lbl)))\n                  yield Style(\n                    (fun s -> { s with Font = \"11pt Roboto,sans-serif\"; Fill=Solid(al, HTML clr); StrokeColor=(0.0, RGB(0,0,0)) }),\n                    Text(x, y, VerticalAlign.Middle, HorizontalAlign.Start, 0., lbl) ) \n                  if not state.Completed then\n                    yield \n                      Style((fun s -> { s with Cursor=\"pointer\"; Fill=Solid(0.0, HTML \"white\")  }), Bar(CO 100., CA lbl))\n                ])))\n             \n    let all = \n      Layered\n        [ OuterScale(None, Some(Continuous(CO 0.0, CO 3.0)), labs) \n          OuterScale(None, Some(Continuous(CO 3.0, CO 10.0)), Padding((0.,20.,0.,20.), chart)) ]\n\n    h?div [\"style\"=>\"text-align:center;padding-top:20px\"] [\n      yield Compost.createSvg false false (width, height) all\n      if state.Completed && solvedComment.IsSome then\n        yield h?div [\"style\"=>\"padding-bottom:20px\"] [\n          h?p [\"class\"=>\"solved\"] [text solvedComment.Value]\n        ]\n      elif interactive then\n        yield h?div [\"style\"=>\"padding-bottom:20px\"] [\n          h?button [\n              yield \"type\" => \"button\"\n              yield \"click\" =!> fun _ _ -> trigger ShowResults\n              if state.Assignments.Count <> state.Data.Length then\n                yield \"disabled\" => \"disabled\"\n            ] [ text \"Show me how I did\" ]\n          ]\n    ]\n    \n// ------------------------------------------------------------------------------------------------\n// You Guess API\n// ------------------------------------------------------------------------------------------------\n\nopen TheGamma.Series\nopen TheGamma.Common\n\ntype YouGuessColsBarsKind = Cols | Bars\n\ntype YouGuessColsBars =\n  private \n    { kind : YouGuessColsBarsKind\n      data : series<string, float> \n      logger : (obj -> unit) option\n      interactive : bool\n      solvedComment : string option\n  // [copy-paste]\n      options : ChartOptions }  \n  member y.setEmptyMessage(message) =\n    { y with options = { y.options with emptyMessage = Some message } }\n  member y.setTitle(?title) =\n    { y with options = { y.options with title = title } }\n  member y.setLegend(position) = \n    { y with options = { y.options with legend = { position = position } } }\n  member y.setSize(?width, ?height) = \n    { y with options = { y.options with size = (orElse width (fst y.options.size), orElse height (snd y.options.size)) } }\n  member y.setAxisX(?minValue, ?maxValue, ?label, ?labelOffset, ?labelMinimalSize) = \n    let ax = { y.options.xAxis with minValue = orElse minValue y.options.xAxis.minValue; maxValue = orElse maxValue y.options.xAxis.maxValue; label = orElse label y.options.xAxis.label; labelOffset = orElse labelOffset y.options.xAxis.labelOffset; labelMinimalSize = orElse labelMinimalSize y.options.xAxis.labelMinimalSize }\n    { y with options = { y.options with xAxis = ax } }\n  member y.setAxisY(?minValue, ?maxValue, ?label, ?labelOffset, ?labelMinimalSize) = \n    let ax = { y.options.yAxis with minValue = orElse minValue y.options.yAxis.minValue; maxValue = orElse maxValue y.options.yAxis.maxValue; label = orElse label y.options.yAxis.label; labelOffset = orElse labelOffset y.options.yAxis.labelOffset; labelMinimalSize = orElse labelMinimalSize y.options.yAxis.labelMinimalSize  }\n    { y with options = { y.options with yAxis = ax } }\n  // [/copy-paste]\n  member y.setSolvedComment(comment) = { y with solvedComment = Some comment }\n  member y.setLogger(logger) = { y with logger = Some logger }\n  member y.setLabel(top:string) = y.setTitle(top) // TODO: Deprecated\n  member y.setMaximum(max:float) = if y.kind = Bars then y.setAxisX(maxValue=box max) else y.setAxisY(maxValue=box max) // TODO: Deprecated\n  member y.setInteractive(state) = { y with interactive = state }\n  member y.show(outputId) =   \n    InteractiveHelpers.showApp outputId y.options y.data\n      (fun data -> YouGuessColsHelpers.initState (not y.interactive) (y.kind = Bars) data (unbox (if y.kind = Bars then y.options.xAxis.maxValue else y.options.yAxis.maxValue)))\n      (fun _ size -> \n          match y.kind with \n          | Bars -> YouGuessColsHelpers.renderBars y.solvedComment y.interactive true size y.options\n          | Cols -> YouGuessColsHelpers.renderCols y.solvedComment y.interactive size y.options.title)\n      (fun _ -> YouGuessColsHelpers.update (InteractiveHelpers.createLogger outputId y.logger) )\n\ntype YouGuessLine = \n  private \n    { data : series<obj, float> \n      markers : series<obj, obj> option\n      clip : float option\n      markerColor : string option\n      knownColor : string option\n      unknownColor : string option \n      drawColor : string option \n      knownLabel : string option\n      guessLabel : string option \n      logger : (obj -> unit) option\n      interactive : bool\n      solvedComment : string option\n  // [copy-paste]\n      options : ChartOptions }  \n  member y.setEmptyMessage(message) =\n    { y with options = { y.options with emptyMessage = Some message } }\n  member y.setTitle(?title) =\n    { y with options = { y.options with title = title } }\n  member y.setLegend(position) = \n    { y with options = { y.options with legend = { position = position } } }\n  member y.setSize(?width, ?height) = \n    { y with options = { y.options with size = (orElse width (fst y.options.size), orElse height (snd y.options.size)) } }\n  member y.setAxisX(?minValue, ?maxValue, ?label, ?labelOffset, ?labelMinimalSize) = \n    let ax = { y.options.xAxis with minValue = orElse minValue y.options.xAxis.minValue; maxValue = orElse maxValue y.options.xAxis.maxValue; label = orElse label y.options.xAxis.label; labelOffset = orElse labelOffset y.options.xAxis.labelOffset; labelMinimalSize = orElse labelMinimalSize y.options.xAxis.labelMinimalSize }\n    { y with options = { y.options with xAxis = ax } }\n  member y.setAxisY(?minValue, ?maxValue, ?label, ?labelOffset, ?labelMinimalSize) = \n    let ax = { y.options.yAxis with minValue = orElse minValue y.options.yAxis.minValue; maxValue = orElse maxValue y.options.yAxis.maxValue; label = orElse label y.options.yAxis.label; labelOffset = orElse labelOffset y.options.yAxis.labelOffset; labelMinimalSize = orElse labelMinimalSize y.options.yAxis.labelMinimalSize  }\n    { y with options = { y.options with yAxis = ax } }\n  // [/copy-paste]\n  member y.setSolvedComment(comment) = { y with solvedComment = Some comment }\n  member y.setLogger(logger) = { y with logger = Some logger }\n  member y.setRange(min, max) = y.setAxisY(min, max) // TODO: Deprecated\n  member y.setClip(clip) = { y with clip = Some (dateOrNumberAsNumber clip) }\n  member y.setColors(known, unknown) = { y with knownColor = Some known; unknownColor = Some unknown }\n  member y.setDrawColor(draw) = { y with drawColor = Some draw }\n  member y.setMarkerColor(marker) = { y with markerColor = Some marker }\n  member y.setLabels(?top, ?known, ?guess) = \n    { y with knownLabel = orElse known y.knownLabel; guessLabel = orElse guess y.guessLabel; options = { y.options with title = orElse top y.options.title } }\n  member y.setMarkers(markers) = { y with markers = Some markers }\n  member y.setInteractive(state) = { y with interactive = state }\n  member y.show(outputId) = Async.StartImmediate <| async {\n    let markers = defaultArg y.markers (series<string, float>.create(async.Return [||], \"\", \"\", \"\"))\n    let! markers = markers.data |> Async.AwaitFuture\n    let markers = markers |> Array.map (fun (k, v) -> dateOrNumberAsNumber k, v) |> Array.sortBy fst\n    return! InteractiveHelpers.showAppAsync outputId y.options y.data\n      (fun data ->\n          let clipx = match y.clip with Some v -> v | _ -> dateOrNumberAsNumber (fst (data.[data.Length / 2]))\n          YouGuessLineHelpers.initState (not y.interactive) (Array.sortBy (fst >> dateOrNumberAsNumber) data) clipx)\n      (fun data size trig ->           \n          let lc, dc, gc, mc = \n            defaultArg y.knownColor \"#606060\", defaultArg y.unknownColor \"#FFC700\", \n            defaultArg y.drawColor \"#808080\", defaultArg y.markerColor \"#C65E31\"    \n          let data = Array.sortBy (fst >> dateOrNumberAsNumber) data\n          let co = { y.options with xAxis = { y.options.xAxis with minValue = Some (box (dateOrNumberAsNumber (fst data.[0]))); maxValue = Some (box (dateOrNumberAsNumber (fst data.[data.Length-1]))) } }\n          YouGuessLineHelpers.render y.solvedComment y.interactive co size markers (defaultArg y.knownLabel \"\", defaultArg y.guessLabel \"\") (lc,dc,gc,mc) trig) \n      (fun _ -> YouGuessLineHelpers.handler (InteractiveHelpers.createLogger outputId y.logger)) } \n\ntype YouGuessLineOffset = \n  private \n    { data : series<obj, float> \n      markers : series<obj, obj> option\n      labels : string[]\n      logger : (obj -> unit) option\n      interactive : bool\n      lineColor : string option \n      guessColor : string option\n      markerColor : string option\n      solvedComment : string option\n  // [copy-paste]\n      options : ChartOptions }  \n  member y.setEmptyMessage(message) =\n    { y with options = { y.options with emptyMessage = Some message } }\n  member y.setTitle(?title) =\n    { y with options = { y.options with title = title } }\n  member y.setLegend(position) = \n    { y with options = { y.options with legend = { position = position } } }\n  member y.setSize(?width, ?height) = \n    { y with options = { y.options with size = (orElse width (fst y.options.size), orElse height (snd y.options.size)) } }\n  member y.setAxisX(?minValue, ?maxValue, ?label, ?labelOffset, ?labelMinimalSize) = \n    let ax = { y.options.xAxis with minValue = orElse minValue y.options.xAxis.minValue; maxValue = orElse maxValue y.options.xAxis.maxValue; label = orElse label y.options.xAxis.label; labelOffset = orElse labelOffset y.options.xAxis.labelOffset; labelMinimalSize = orElse labelMinimalSize y.options.xAxis.labelMinimalSize }\n    { y with options = { y.options with xAxis = ax } }\n  member y.setAxisY(?minValue, ?maxValue, ?label, ?labelOffset, ?labelMinimalSize) = \n    let ax = { y.options.yAxis with minValue = orElse minValue y.options.yAxis.minValue; maxValue = orElse maxValue y.options.yAxis.maxValue; label = orElse label y.options.yAxis.label; labelOffset = orElse labelOffset y.options.yAxis.labelOffset; labelMinimalSize = orElse labelMinimalSize y.options.yAxis.labelMinimalSize  }\n    { y with options = { y.options with yAxis = ax } }\n  // [/copy-paste]\n  member y.setLabels(labels) = { y with labels = labels }\n  member y.setSolvedComment(comment) = { y with solvedComment = Some comment }\n  member y.setLogger(logger) = { y with logger = Some logger }\n  member y.setColors(?draw, ?solved, ?marker) = { y with guessColor = orElse draw y.guessColor; lineColor = orElse solved y.lineColor; markerColor = orElse marker y.markerColor }\n  member y.setMarkers(markers) = { y with markers = Some markers }\n  member y.setInteractive(state) = { y with interactive = state }\n  member y.show(outputId) = Async.StartImmediate <| async {\n    let markers = defaultArg y.markers (series<string, float>.create(async.Return [||], \"\", \"\", \"\"))\n    let! markers = markers.data |> Async.AwaitFuture\n    let markers = markers |> Array.map (fun (k, v) -> dateOrNumberAsNumber k, v) |> Array.sortBy fst\n    return! InteractiveHelpers.showAppAsync outputId y.options y.data\n      (fun data ->\n          let data = Array.sortBy (fst >> dateOrNumberAsNumber) data\n          let lo = defaultArg y.options.yAxis.minValue (box (dateOrNumberAsNumber (fst data.[0])))\n          let hi = defaultArg y.options.yAxis.maxValue (box (dateOrNumberAsNumber (fst data.[data.Length-1])))\n          let co = { y.options with yAxis = { y.options.yAxis with minValue = Some lo; maxValue = Some hi } }\n          YouGeussLineOffsetHelpers.initState (not y.interactive) co (Array.sortBy (fst >> dateOrNumberAsNumber) data))\n      (fun data size trig ->           \n          let lc = defaultArg y.lineColor \"#bcbd22\"\n          let gc = defaultArg y.guessColor \"#808080\"\n          let mc = defaultArg y.markerColor \"#800080\"\n          YouGeussLineOffsetHelpers.render y.solvedComment y.interactive size y.labels markers (gc, lc, mc) trig) \n      (fun _ -> YouGeussLineOffsetHelpers.handler (InteractiveHelpers.createLogger outputId y.logger)) } \n\ntype YouGuessSortBars = \n  private \n    { data : series<string, float> \n      maxValue : float option \n      size : float option * float option \n      logger : (obj -> unit) option \n      interactive : bool \n      solvedComment : string option }\n  member y.setSolvedComment(comment) = { y with solvedComment = Some comment }\n  member y.setLogger(logger) = { y with logger = Some logger }\n  member y.setMaximum(max) = { y with maxValue = Some max }\n  member y.setSize(?width, ?height) = \n    { y with size = (orElse width (fst y.size), orElse height (snd y.size)) }\n  member y.setInteractive(state) = { y with interactive = state }\n  member y.show(outputId) = \n    InteractiveHelpers.showApp outputId { ChartOptions.Default with size = y.size } y.data\n      (YouGuessSortHelpers.initState (not y.interactive) y.maxValue)\n      (fun _ size -> YouGuessSortHelpers.renderBars y.solvedComment y.interactive size)\n      (fun _ -> YouGuessSortHelpers.update (InteractiveHelpers.createLogger outputId y.logger))\n\ntype youguess = \n  static member columns(data:series<string, float>) = \n    { YouGuessColsBars.data = data; kind = Cols; options = ChartOptions.Default; logger = None; interactive = true; solvedComment = None }\n  static member bars(data:series<string, float>) = \n    { YouGuessColsBars.data = data; kind = Bars; options = ChartOptions.Default; logger = None; interactive = true; solvedComment = None }\n  static member sortBars(data:series<string, float>) = \n    { YouGuessSortBars.data = data; maxValue = None; size = None, None; logger = None; interactive = true; solvedComment = None }\n  static member line(data:series<obj, float>) =\n    { YouGuessLine.data = data; clip = None; \n      markerColor = None; guessLabel = None; knownLabel = None; markers = None\n      knownColor = None; unknownColor = None; drawColor = None; \n      options = ChartOptions.Default; logger = None; interactive = true; solvedComment = None }\n  static member vlineOffset(data:series<obj, float>) =\n    { YouGuessLineOffset.data = data; markers = None; lineColor = None; \n      guessColor = None; markerColor = None; labels = [| for c in 'A' .. 'Z' -> string c |]\n      options = ChartOptions.Default; logger = None; interactive = true; solvedComment = None }\n\n// ------------------------------------------------------------------------------------------------\n// Compost Charts API\n// ------------------------------------------------------------------------------------------------\n\ntype CompostBubblesChartSet =\n  private \n    { data : series<obj, obj> \n      selectY : obj -> obj\n      selectX : obj -> obj\n      selectLabel : option<obj -> obj>\n      selectSize : option<obj -> obj>\n      bubbleColor : string option\n  // [copy-paste]\n      options : ChartOptions }\n  member y.setEmptyMessage(message) =\n    { y with options = { y.options with emptyMessage = Some message } }\n  member y.setTitle(?title) =\n    { y with options = { y.options with title = title } }\n  member y.setLegend(position) = \n    { y with options = { y.options with legend = { position = position } } }\n  member y.setSize(?width, ?height) = \n    { y with options = { y.options with size = (orElse width (fst y.options.size), orElse height (snd y.options.size)) } }\n  member y.setAxisX(?minValue, ?maxValue, ?label, ?labelOffset, ?labelMinimalSize) = \n    let ax = { y.options.xAxis with minValue = orElse minValue y.options.xAxis.minValue; maxValue = orElse maxValue y.options.xAxis.maxValue; label = orElse label y.options.xAxis.label; labelOffset = orElse labelOffset y.options.xAxis.labelOffset; labelMinimalSize = orElse labelMinimalSize y.options.xAxis.labelMinimalSize }\n    { y with options = { y.options with xAxis = ax } }\n  member y.setAxisY(?minValue, ?maxValue, ?label, ?labelOffset, ?labelMinimalSize) = \n    let ax = { y.options.yAxis with minValue = orElse minValue y.options.yAxis.minValue; maxValue = orElse maxValue y.options.yAxis.maxValue; label = orElse label y.options.yAxis.label; labelOffset = orElse labelOffset y.options.yAxis.labelOffset; labelMinimalSize = orElse labelMinimalSize y.options.yAxis.labelMinimalSize  }\n    { y with options = { y.options with yAxis = ax } }\n  // [/copy-paste]\n  member y.setColors(?bubbleColor) = \n    { y with bubbleColor = defaultArg bubbleColor y.bubbleColor }\n  member y.show(outputId) = \n    InteractiveHelpers.showApp outputId y.options y.data\n      (fun data -> -1)\n      (fun data size trigger selectedBubble -> \n        let ss f = match f with Some f -> (fun x -> Some(f x)) | _ -> (fun _ -> None)\n        let data = data |> Array.map (fun (_, v) -> y.selectX v, y.selectY v, ss y.selectSize v, ss y.selectLabel v)\n        let bc = defaultArg y.bubbleColor \"#20a030\"\n        Charts.renderBubbles trigger selectedBubble y.options size bc data)\n      (fun _ _ evt -> evt)\n\ntype CompostBubblesChart<'k, 'v>(data:series<'k, 'v>) = \n  member c.set(x:'v -> obj, y:'v -> obj, ?size:'v -> obj, ?label:'v -> obj) = \n    { CompostBubblesChartSet.data = unbox data\n      selectX = unbox x; selectY = unbox y\n      selectSize = unbox size; bubbleColor = None \n      options = ChartOptions.Default; selectLabel = unbox label }\n\n\ntype CompostColBarChart =\n  private \n    { isBar : bool\n      data : series<string, float>\n      colors : string[] option\n      inlineLabels : bool\n  // [copy-paste]\n      options : ChartOptions }  \n  member y.setEmptyMessage(message) =\n    { y with options = { y.options with emptyMessage = Some message } }\n  member y.setTitle(?title) =\n    { y with options = { y.options with title = title } }\n  member y.setLegend(position) = \n    { y with options = { y.options with legend = { position = position } } }\n  member y.setSize(?width, ?height) = \n    { y with options = { y.options with size = (orElse width (fst y.options.size), orElse height (snd y.options.size)) } }\n  member y.setAxisX(?minValue, ?maxValue, ?label, ?labelOffset, ?labelMinimalSize) = \n    let ax = { y.options.xAxis with minValue = orElse minValue y.options.xAxis.minValue; maxValue = orElse maxValue y.options.xAxis.maxValue; label = orElse label y.options.xAxis.label; labelOffset = orElse labelOffset y.options.xAxis.labelOffset; labelMinimalSize = orElse labelMinimalSize y.options.xAxis.labelMinimalSize }\n    { y with options = { y.options with xAxis = ax } }\n  member y.setAxisY(?minValue, ?maxValue, ?label, ?labelOffset, ?labelMinimalSize) = \n    let ax = { y.options.yAxis with minValue = orElse minValue y.options.yAxis.minValue; maxValue = orElse maxValue y.options.yAxis.maxValue; label = orElse label y.options.yAxis.label; labelOffset = orElse labelOffset y.options.yAxis.labelOffset; labelMinimalSize = orElse labelMinimalSize y.options.yAxis.labelMinimalSize  }\n    { y with options = { y.options with yAxis = ax } }\n  // [/copy-paste]\n  member y.setStyle(?inlineLabels) = \n    { y with inlineLabels = defaultArg inlineLabels y.inlineLabels }\n  member y.setColors(?colors) = \n    { y with colors = defaultArg colors y.colors }\n  member y.show(outputId) = \n    InteractiveHelpers.showStaticApp outputId y.options y.data\n      (fun data size -> \n        let cc = defaultArg y.colors vega10\n        Charts.renderColsBars y.isBar y.inlineLabels y.options size cc (Seq.map fst data) data)\n\n\ntype CompostLineAreaChart =\n  private \n    { isArea : bool\n      data : series<obj, obj>\n      lineColor : string option\n  // [copy-paste]\n      options : ChartOptions }  \n  member y.setEmptyMessage(message) =\n    { y with options = { y.options with emptyMessage = Some message } }\n  member y.setTitle(?title) =\n    { y with options = { y.options with title = title } }\n  member y.setLegend(position) = \n    { y with options = { y.options with legend = { position = position } } }\n  member y.setSize(?width, ?height) = \n    { y with options = { y.options with size = (orElse width (fst y.options.size), orElse height (snd y.options.size)) } }\n  member y.setAxisX(?minValue, ?maxValue, ?label, ?labelOffset, ?labelMinimalSize) = \n    let ax = { y.options.xAxis with minValue = orElse minValue y.options.xAxis.minValue; maxValue = orElse maxValue y.options.xAxis.maxValue; label = orElse label y.options.xAxis.label; labelOffset = orElse labelOffset y.options.xAxis.labelOffset; labelMinimalSize = orElse labelMinimalSize y.options.xAxis.labelMinimalSize }\n    { y with options = { y.options with xAxis = ax } }\n  member y.setAxisY(?minValue, ?maxValue, ?label, ?labelOffset, ?labelMinimalSize) = \n    let ax = { y.options.yAxis with minValue = orElse minValue y.options.yAxis.minValue; maxValue = orElse maxValue y.options.yAxis.maxValue; label = orElse label y.options.yAxis.label; labelOffset = orElse labelOffset y.options.yAxis.labelOffset; labelMinimalSize = orElse labelMinimalSize y.options.yAxis.labelMinimalSize  }\n    { y with options = { y.options with yAxis = ax } }\n  // [/copy-paste]\n  member y.setColors(?lineColor) = \n    { y with lineColor = defaultArg lineColor y.lineColor }\n  member y.show(outputId) = \n    InteractiveHelpers.showStaticApp outputId y.options y.data\n      (fun data size -> \n        let lc = defaultArg y.lineColor \"#1f77b4\"\n        Charts.renderLines y.isArea y.options size [| lc |] [\"Data\"] [| data |])\n\n\ntype CompostLinesAreasChart =\n  private \n    { isArea : bool\n      data : series<obj, obj>[]\n      lineColors : string[] option\n  // [copy-paste]\n      options : ChartOptions }  \n  member y.setEmptyMessage(message) =\n    { y with options = { y.options with emptyMessage = Some message } }\n  member y.setTitle(?title) =\n    { y with options = { y.options with title = title } }\n  member y.setLegend(position) = \n    { y with options = { y.options with legend = { position = position } } }\n  member y.setSize(?width, ?height) = \n    { y with options = { y.options with size = (orElse width (fst y.options.size), orElse height (snd y.options.size)) } }\n  member y.setAxisX(?minValue, ?maxValue, ?label, ?labelOffset, ?labelMinimalSize) = \n    let ax = { y.options.xAxis with minValue = orElse minValue y.options.xAxis.minValue; maxValue = orElse maxValue y.options.xAxis.maxValue; label = orElse label y.options.xAxis.label; labelOffset = orElse labelOffset y.options.xAxis.labelOffset; labelMinimalSize = orElse labelMinimalSize y.options.xAxis.labelMinimalSize }\n    { y with options = { y.options with xAxis = ax } }\n  member y.setAxisY(?minValue, ?maxValue, ?label, ?labelOffset, ?labelMinimalSize) = \n    let ax = { y.options.yAxis with minValue = orElse minValue y.options.yAxis.minValue; maxValue = orElse maxValue y.options.yAxis.maxValue; label = orElse label y.options.yAxis.label; labelOffset = orElse labelOffset y.options.yAxis.labelOffset; labelMinimalSize = orElse labelMinimalSize y.options.yAxis.labelMinimalSize  }\n    { y with options = { y.options with yAxis = ax } }\n  // [/copy-paste]\n  member y.setColors(?lineColors) = \n    { y with lineColors = defaultArg lineColors y.lineColors }\n  member y.show(outputId) = Async.StartImmediate <| async {\n    let! data = Async.Parallel [ for d in y.data -> Async.AwaitFuture d.data ]\n    let allData = y.data |> Seq.fold (fun (s1:series<_,_>) s2 -> s1.append(s2)) (series<int,int>.create(async.Return [||], \"\", \"\", \"\"))\n    return! InteractiveHelpers.showStaticAppAsync outputId y.options allData\n      (fun size -> \n        let lcs = defaultArg y.lineColors vega10\n        Charts.renderLines y.isArea y.options size lcs (y.data |> Seq.map (fun s -> s.seriesName)) data) }\n      \ntype CompostCharts() = \n  member c.bubbles(data:series<'k, 'v>) = \n    CompostBubblesChart<'k, 'v>(data)\n  member c.line(data:series<'k, 'v>) = \n    { CompostLineAreaChart.data = unbox data; lineColor = None; options = ChartOptions.Default; isArea = false }\n  member c.area(data:series<'k, 'v>) = \n    { CompostLineAreaChart.data = unbox data; lineColor = None; options = ChartOptions.Default; isArea = true }\n  member c.lines(data:series<'k, 'v>[]) = \n    { CompostLinesAreasChart.data = unbox data; lineColors = None; options = ChartOptions.Default; isArea = false }\n  member c.areas(data:series<'k, 'v>[]) = \n    { CompostLinesAreasChart.data = unbox data; lineColors = None; options = ChartOptions.Default; isArea = true }\n  member c.bar(data:series<string, float>) = \n    { CompostColBarChart.data = data; colors = None; options = ChartOptions.Default; isBar = true; inlineLabels = false }\n  member c.column(data:series<string, float>) = \n    { CompostColBarChart.data = data; colors = None; options = ChartOptions.Default; isBar = false; inlineLabels = false }\n\ntype compost = \n  static member charts = CompostCharts()\n","export function createFromValue(v) {\r\n    return new Lazy(function () { return v; });\r\n}\r\nvar Lazy = (function () {\r\n    function Lazy(factory) {\r\n        this.factory = factory;\r\n        this.isValueCreated = false;\r\n    }\r\n    Object.defineProperty(Lazy.prototype, \"value\", {\r\n        get: function () {\r\n            if (!this.isValueCreated) {\r\n                this.createdValue = this.factory();\r\n                this.isValueCreated = true;\r\n            }\r\n            return this.createdValue;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return Lazy;\r\n}());\r\nexport default Lazy;\r\n","﻿module TheGamma.Errors\nopen TheGamma.Ast\n\nmodule Tokenizer = \n  let inputEndInsideString rng s =\n    { Number = 101; Range = rng; Message = sprintf \"Missing \\\" at the end of the input. The string \\\"%s\\\" ends without closing double-quote.\" s }\n  let missingClosingQuote rng q = \n    { Number = 102; Range = rng; Message = sprintf \"Quoted identifier '%s' is missing closing quote.\" q }\n  let unexpectedCharacter rng (c:char) =\n    { Number = 103; Range = rng; Message = sprintf \"Unexcpected character '%s' in the input.\" (string c) }\n\nmodule Parser = \n  let unexpectedTokenAfterDot rng tok =\n    { Number = 201; Range = rng; Message = sprintf \"Unexpected %s after '.' in method chain\" (formatTokenInfo tok) }\n\n  let unexpectedScopeEndAfterDot rng tok =\n    { Number = 202; Range = rng; Message = sprintf \"Unexpected end of scope after %s. Did you forget to indent the rest of the member chain?\" (formatTokenInfo tok) }\n\n  let unexpectedTokenInPlaceholder rng tok =\n    { Number = 203; Range = rng; Message = sprintf \"Unexpected token '%s' in placeholder expression. Shold be `[ident: <expr>]`\" (formatTokenInfo tok) }\n\n  let unexpectedScopeEndInPlaceholder rng tok =\n    if Option.isSome tok then { Number = 204; Range = rng; Message = sprintf \"Unexpected end of scope in placeholder after %s. Did you forget to indent the body of the plceholder?\" (formatTokenInfo tok.Value) }\n    else { Number = 204; Range = rng; Message = \"Unexpected end of scope in placeholder after expression. Did you forget to indent the body of the plceholder?\" }\n\n  let unexpectedEndOfPlaceholder rng =\n    { Number = 205; Range = rng; Message = \"Incomplete placeholder expression. Shold be `[ident: <expr>]`\" }\n\n  let unexpectedEndAfterOperator rng op =\n    { Number = 206; Range = rng; Message = sprintf \"Unexpected token after operator '%s'. Expected an expression or closing parenthesis.\" (formatTokenInfo op) }\n\n  let unexpectedTokenInArgList rng tok =\n    { Number = 207; Range = rng; Message = sprintf \"Unexpected token '%s' in list of call arguments\" (formatTokenInfo tok) }\n\n  let unexpectedScopeEndInArgList rng =\n    { Number = 208; Range = rng; Message = \"Unexpected end of argument list. Did you forget to indent the arguments?\" }\n\n  let unexpectedTokenInParenthesizedExpr rng tok =\n    { Number = 209; Range = rng; Message = sprintf \"Unexpected token '%s' in parenthesized expression. Are you missing ')'?\" (formatTokenInfo tok) }\n\n  let unexpectedScopeEndInParenthesizedExpr rng =\n    { Number = 210; Range = rng; Message = \"Unexpected end of nested expression in `(`. Did you forget to indent the body of the expression?\" }\n\n  let missingParenthesizedExpr rng =\n    { Number = 211; Range = rng; Message = \"The parenthesized expression (...) is missing body!\" }\n\n  let unexpectedTokenInList rng tok =\n    { Number = 212; Range = rng; Message = sprintf \"Unexpected token '%s' in list expression\" (formatTokenInfo tok) }\n\n  let unexpectedScopeEndInList rng =\n    { Number = 213; Range = rng; Message = \"Unexpected end of list expression. Did youu forget to indent the elements of the list?\" }\n\n  let unexpectedTokenInLetBinding rng tok =\n    { Number = 214; Range = rng; Message = sprintf \"Unexpected token '%s' in let declaration (should be `let name = expr`)\" (formatTokenInfo tok) }\n\n  let missingBodyInLetBinding rng =\n    { Number = 215; Range = rng; Message = \"This let binding is missing body after equals (should be `let name = expr`\" }\n\n  let unexpectedNestedTokenInCommand rng tok =\n    { Number = 216; Range = rng; Message = sprintf \"Unexpected indented token '%s' in command list. Try removing the indentation before the token.\" (formatTokenInfo tok) }\n\n  let unexpectedTokenAfterFun rng tok =\n    { Number = 217; Range = rng; Message = sprintf \"Unexpected token '%s' after `fun`. Expected variable name.\" (formatTokenInfo tok) }\n\n  let missingArrowInFunc rng =\n    { Number = 218; Range = rng; Message = \"Missing arrow after variable in function definition\" }\n\n  let unexpectedScopeEndInFunc rng =\n    { Number = 219; Range = rng; Message = \"Unexpected end of function declaration. Did you forget to indent the body of the function?\" }\n\n  let missingBodyOfFunc rng =\n    { Number = 220; Range = rng; Message = \"The function is missing body. Did you forget to indent the body of the function?\" }\n\n  let unexpectedScopeEndInLet rng =\n    { Number = 221; Range = rng; Message = \"Unexpected end of let declaration. Did you forget to indent the body of the let declaration?\" }\n\n  let exceptionWhileParsing rng msg = \n    { Number = 299; Range = rng; Message = \"Unexpected exception while parsing: \" + msg }\n\n    \nmodule TypeChecker = \n  let numericOperatorExpectsNumbers op idx typs typ rng =\n    { Number = 301; Range = rng \n      Message = \n        sprintf \"Both operands of binary operator '%s' should be %s but the %s operand was %s instead.\" \n          (String.concat \" or \" (List.map formatTypeInfo typs))\n          (formatToken (TokenKind.Operator op)) (if idx = 0 then \"left\" else \"right\") (formatTypeInfo typ) }\n\n  let variableNotInScope name rng =\n    { Number = 302; Range = rng \n      Message = sprintf \"Variable '%s' is not in scope.\" name }\n\n  let private formatMembers (members:seq<Member>) =     \n    let members = members |> Array.ofSeq\n    let suffix = if members.Length > 10 then sprintf \", (%d members)\" (members.Length - 10) else \"\"\n    (String.concat \", \" [ for m in members -> m.Name ]) + suffix\n\n  let memberMissing name members rng = \n    { Number = 303; Range = rng \n      Message = sprintf \"Could not find property '%s' in the list '%s'.\" name (formatMembers members) }\n\n  let notAnObject name typ rng = \n    { Number = 305; Range = rng \n      Message = sprintf \"Type is not an object but %s and it does not have member `%s`\" (formatTypeInfo typ) name }\n\n  let listElementTypeDoesNotMatch listty elty rng = \n    { Number = 306; Range = rng \n      Message = sprintf \"The type of this list element is %s but it should be %s\" (formatTypeInfo elty) (formatTypeInfo listty) }\n\n  let nameBasedParamMustBeLast rng = \n    { Number = 307; Range = rng \n      Message = \"All named parameters must be at the end of parameter list.\" }\n\n  let parameterMissingValue par rng = \n    { Number = 308; Range = rng \n      Message = sprintf \"Required parameter `%s` is not given a value.\" par }\n\n  let notAnMethod name typ rng = \n    { Number = 309; Range = rng \n      Message = sprintf \"The type of member %s is `%s` and not a method and so it cannot be called.\" name (formatTypeInfo typ) }\n\n(*\n  let incorrectParameterType parName parType actualType err1 err2 rng = \n    { Number = 309; Range = rng \n      Message = \n        sprintf \"The value of parameter `%s` has wrong type. Expected %s but got %s. The type %s does not match the type %s.\"\n          parName (formatTypeInfo parType) (formatTypeInfo actualType) (formatTypeInfo err1) (formatTypeInfo err2) }\n\n  let inferenceConflict var t1 t2 rng = \n    { Number = 310; Range = rng \n      Message = \n        sprintf \"The arguments of the call have conflicting types. The type %s assigned to a variable %s does not match the type %s.\"\n          (formatTypeInfo t1) var (formatTypeInfo t2) }\n*)\n  let parameterConflict rng = \n    { Number = 310; Range = rng \n      Message = \"Invalid argument type\" }\n\n  let callMissingInstance name rng = \n    { Number = 311; Range = rng \n      Message = sprintf \"The `%s` property access or call is missing an instance\" name }\n","module.exports = '\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003' +\n  '\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n","var $export = require('./_export');\nvar defined = require('./_defined');\nvar fails = require('./_fails');\nvar spaces = require('./_string-ws');\nvar space = '[' + spaces + ']';\nvar non = '\\u200b\\u0085';\nvar ltrim = RegExp('^' + space + space + '*');\nvar rtrim = RegExp(space + space + '*$');\n\nvar exporter = function (KEY, exec, ALIAS) {\n  var exp = {};\n  var FORCE = fails(function () {\n    return !!spaces[KEY]() || non[KEY]() != non;\n  });\n  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];\n  if (ALIAS) exp[ALIAS] = fn;\n  $export($export.P + $export.F * FORCE, 'String', exp);\n};\n\n// 1 -> String#trimLeft\n// 2 -> String#trimRight\n// 3 -> String#trim\nvar trim = exporter.trim = function (string, TYPE) {\n  string = String(defined(string));\n  if (TYPE & 1) string = string.replace(ltrim, '');\n  if (TYPE & 2) string = string.replace(rtrim, '');\n  return string;\n};\n\nmodule.exports = exporter;\n","var $parseFloat = require('./_global').parseFloat;\nvar $trim = require('./_string-trim').trim;\n\nmodule.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str) {\n  var string = $trim(String(str), 3);\n  var result = $parseFloat(string);\n  return result === 0 && string.charAt(0) == '-' ? -0 : result;\n} : $parseFloat;\n","var $export = require('./_export');\nvar $parseFloat = require('./_parse-float');\n// 20.1.2.12 Number.parseFloat(string)\n$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });\n","require('../../modules/es6.number.parse-float');\nmodule.exports = parseFloat;\n","module.exports = { \"default\": require(\"core-js/library/fn/number/parse-float\"), __esModule: true };","﻿namespace TheGamma\n\n/// Represents range in 1-based line / 1-based column format\ntype LineColumnRange =\n  { StartLineNumber : int\n    StartColumn : int\n    EndLineNumber : int\n    EndColumn : int }\n\ntype LocationMapper(code:string) = \n  // ResizeArray is workaround for \"TypeError: TypedArray.from requires its this argument subclass a TypedArray constructor\" in Safari\n  let lengths = ResizeArray<_>(code.Split('\\n') |> Seq.map (fun s -> s.Length)) \n\n  /// Convert absolute 0-based location to 1-based line and 1-based column location\n  member x.AbsoluteToLineCol(offs) = \n    let mutable line = 0\n    let mutable col = 0\n    let mutable offs = offs\n    while line <= lengths.Count && offs > lengths.[line] do\n      offs <- offs - lengths.[line] - 1\n      line <- line + 1\n    line + 1, offs + 1\n\n  /// Convert 1-based line and 1-based column location to an absolute 0-based location\n  member x.LineColToAbsolute(line, col) = \n    let mutable offs = 0\n    for l in 1 .. line-1 do offs <- offs + lengths.[l-1] + 1\n    offs + col - 1\n\n"],"names":["setType","fullName","cons","fableGlobal","types","set","Option","t","NonDeclaredType","FableArray","isTypedArray","def","genArg","Tuple","ts","GenericParam","definition","Interface","makeGeneric","typeDef","genArgs","hasInterface","obj","interfaceName","Symbol","iterator","FSymbol","reflection","interfaces","Array","isArray","indexOf","getPropertyNames","propertyMap","properties","Object","getOwnPropertyNames","getRestParams","args","idx","_len","length","restArgs","_key","toString","o","ToString","String","equals","x","y","getPrototypeOf","Equals","i","ArrayBuffer","isView","byteLength","dv1","DataView","buffer","dv2","getUint8","Date","getTime","compare","CompareTo","j","b1","b2","equalsRecords","keys","compareRecords","res","equalsUnions","Case","Fields","compareUnions","createDisposable","f","_a","Dispose","createObj","fields","iter","cur","next","done","value","round","digits","m","Math","pow","n","toFixed","floor","r","randomNext","min","max","random","defaultArg","arg","defaultValue","addRangeInPlace","range","xs","push","unzip","bs","cs","ofArray","base","acc","List","__failIfNone","Error","toList","foldBack","delay","unfold","append","ys","firstDone","iters","averageBy","count","reduce","concat","output","innerIter","hasFinished","collect","map","choose","trySkipToNext","compareWith","nonZero","tryFind","map2","empty","enumerateWhile","cond","exists","aux","filter","fold","arr","from","forAll","tryHead","head","initialize","tryItem","iterate","_","iterateIndexed","isEmpty","tryLast","err","last","mapIndexed","iter1","iter2","cur1","cur2","maxBy","minBy","pairwise","skip","scan","rangeStep","first","step","rangeChar","fromCharCode","charCodeAt","reverse","slice","seed","singleton","skipWhile","hasPassed","sortWith","sort","sumBy","take","truncate","takeWhile","find","tryFindIndex","tryPick","pick","zip","escape","str","replace","isLong","Long","fromInt","unsigned","cachedObj","cache","UINT_CACHE","fromBits","INT_CACHE","fromNumber","isNaN","isFinite","UZERO","ZERO","TWO_PWR_64_DBL","MAX_UNSIGNED_VALUE","TWO_PWR_63_DBL","MIN_VALUE","MAX_VALUE","neg","TWO_PWR_32_DBL","lowBits","highBits","fromString","radix","RangeError","p","substring","radixToPower","pow_dbl","result","size","parseInt","power","mul","add","fromValue","val","low","high","totalDays","parse","v","kind","date","create","year","month","day","h","s","ms","UTC","now","hour","d","getHours","getUTCHours","millisecond","getMilliseconds","getUTCMilliseconds","minute","getMinutes","getUTCMinutes","second","getSeconds","getUTCSeconds","subtract","that","op_Subtraction","toHex","abs","fsFormat","isObject","Number","Boolean","formatOnce","rep","fsFormatRegExp","prefix","flags","pad","precision","format","toPrecision","toExponential","JSON","stringify","k","join","toUpperCase","plusPrefix","ch","padLeft","makeFn","str2","test","_cont","_i","arguments","cont","endsWith","search","lastIndexOf","insert","startIndex","isNullOrEmpty","isNullOrWhiteSpace","delimiter","newGuid","uuid","len","isRight","RegExp","split","splitters","removeEmpty","splits","reg","exec","index","lastIndex","trim","side","chars","groupBy","vs","get","countBy","kv","tree_sizeAux","tree_size","tree_empty","MapTree","tree_height","_arg1","tree_mk","l","matchValue","$target1","hl","hr","tree_rebalance","t1","t2","t1h","t2h","tree_add","comparer","c","Compare","tree_find","tree_tryFind","tree_filter1","tree_filterAux","tree_filter","tree_mem","tree_mkFromEnumerator","e","tree_ofSeq","ie","tree_collapseLHS","stack","tail","listOfArray","tree_mkIterator","started","tree_moveNext","current","tree","FableMap","GenericComparer","tryGetValue","key","has","seqFold","distinctBy","seqChoose","tup","seqScan","distinct","tree_countAux","tree_count","tree_SetOne","SetTree","tree_SetNode","tree_tolerance","tree_compareStacks","l1","l2","$target8","n1k","$target9","n1l","n1r","$target11","n2k","n2l","n2r","emp","tree_compare","s1","s2","FableSet","item","protectedCont","ctx","cancelToken","isCancelled","onCancel","trampoline","incrementAndCheck","hijack","onError","protectedBind","computation","binder","onSuccess","ex","protectedReturn","emptyContinuation","awaitPromise","fromContinuations","conts","then","catch","parallel","computations","Promise","all","w","startAsPromise","sleep","millisecondsDueTime","setTimeout","start","cancellationToken","startWithContinuations","startImmediate","continuation","exceptionContinuation","cancellationContinuation","Trampoline","defaultCancellationToken","resolve","reject","dot","decs","patternInput","_Array$from","i_1","window","g","trimRight","trimLeft","call","VirtualPatch","type","vNode","patch","this","isVirtualNode","version","isVirtualText","isWidget","isThunk","handleThunk","a","b","renderedA","renderedB","renderThunk","thunk","previous","renderedThunk","vnode","render","isVNode","isVText","isHook","hook","hasOwnProperty","unhook","diffProps","diff","aKey","undefined","aValue","bValue","getPrototype","objectDiff","bKey","__proto__","constructor","prototype","walk","apply","applyClear","thunks","clearState","appendPatch","VPatch","REMOVE","tagName","namespace","propsPatch","PROPS","diffChildren","VNODE","text","VTEXT","WIDGET","aChildren","children","orderedSet","reorder","bChildren","aLen","bLen","leftNode","rightNode","INSERT","moves","ORDER","destroyWidgets","destroy","hasWidgets","hasThunks","child","nodes","thunkPatch","hasPatches","THUNK","hooks","undefinedKeys","descendantHooks","bChildIndex","keyIndex","bKeys","bFree","free","aChildIndex","aKeys","newChildren","freeIndex","freeCount","deletedItems","itemIndex","aItem","lastFreeIndex","newItem","simulateItem","simulate","simulateIndex","removes","inserts","wantedItem","remove","to","splice","iterativelyWalk","cb","node","shift","ret","childNodes","Comment","data","owner","nodeValue","ownerDocument","DOMText","dispatchEvent","ev","elem","target","listeners","forEach","listener","currentTarget","handleEvent","parentNode","addEventListener","removeEventListener","list","serializeNode","nodeType","escapeText","serializeElement","strings","tagname","namespaceURI","toLowerCase","datasetify","voidElements","textContent","innerText","innerHTML","isProperty","style","stylify","styles","attr","ds","dataset","props","name","attributes","tuple","escapeAttributeValue","ns","_attributes","attribute","prop","className","DOMElement","htmlns","nodeName","DocumentFragment","Event","family","Document","createElement","body","documentElement","appendChild","applyProperties","propName","propValue","removeProperty","patchObject","previousValue","attrName","removeAttribute","replacer","attrValue","setAttribute","opts","doc","document","warn","init","createTextNode","createElementNS","childNode","domIndex","rootNode","indices","ascending","recurse","rootIndex","indexInRange","vChildren","vChild","noChild","nextIndex","left","right","currentIndex","currentItem","minIndex","maxIndex","updateWidget","id","applyPatch","vpatch","domNode","renderOptions","removeNode","insertNode","stringPatch","widgetPatch","vNodePatch","reorderChildren","replaceRoot","removeChild","destroyWidget","newNode","leftVNode","vText","replaceData","replaceChild","widget","updating","update","keyMap","insertBefore","oldRoot","newRoot","patches","patchRecursive","patchIndices","nodeIndex","patchList","patchOp","VirtualNode","noProperties","noChildren","descendants","property","isVHook","VirtualText","parseTag","tag","noId","tagParts","classIdSplit","notClassId","classes","part","charAt","SoftSetHook","Individual","root","OneVersion","moduleName","enforceKey","versionValue","EvStore","hash","hashKey","EvHook","isChildren","softSetHook","transformProperties","addChild","VNode","VText","isChild","UnexpectedVirtualElement","foreignObject","parentVnode","substr","evHook","isVThunk","message","errorString","callback","source","Subscribe","Observer","append_1","el","node_2","renderVirtual","evt","builder_","u","needsEscaping","r1","formatToken","ma_1","formatType","mem","mems","Serializer","exprBuilder","activePatternResult7108","activePatternResult7115","getValue","nameBased","activePatternResult7124","BabelOperators","lastChainElement","visited","$var314","m1","typesEqual","Async_AwaitFuture_Static","mapGenericType","$var398","applyTypes","$var399","$var402","map_1","substituteTypeParams","schema","assigns","partiallySubstituteTypeParams","mapType","$var407","assigns_3","assigns_4","Http","fromRawType","tupledArg","lookupNamed","ProviderHelpers","parseDoc","createReturnType","propAccess","listsEqual","encodeURIComponent","methCall","dataCall","concatUrl","load","createRestType","Transform","makePivotType","makeMethodEmitter","getTypeAndEmitter","makeDataEmitter","pgid","makeProperty","droppedFields","usedKeys","isDate","isNumeric","makeMethod","aggs","make","makeAggMember","containsField","isBool","isConcatenable","aggregationMembers","op","conds","makeObjectType","field","matchValue_1","makeDataMember","fld","handleGetSeriesRequest","handlePagingRequest","handleSortRequest","handleDropRequest","handleFilterEqNeqRequest","handleFilterRequest","handleWindowRequest","handleWindowExpandAggRequest","handleGroupRequest","handleGroupAggRequest","adjustForPreview","makePivotTypeImmediate","withPreview","makePivotExpression","makePivotGlobalValue","nestedDict","formatEntityKind","add_1","arg_1","bindExpression_1","mbox","MailboxProcessor","letter","number","Tokenizer","error","qid","_Number$parseFloat","startsWith","precedence","unionRanges","precClimb","activePatternResult6748","whiteAfter","parseExpression","afterComma","activePatternResult6760","activePatternResult6763","prevDotRng","activePatternResult6774","whiteBefore","activePatternResult6792","parseTerm","activePatternResult6813","tryFind_1","getType","ma","choose_1","activePatternResult7033","evaluateDelayedType","isGlobal","typeCheckEntityAsync","activePatternResult7975","offs","offsetToLocation","rangeToLoc","compileExpression","namedArgs","cmd","tfs_2","transformName","activePatternResult8029","op_EqualsGreater","table","sections","rng","escapeIdent","formatSingleExpression","state","dominantWhite","hideMenus","chain_1","event","createChainNodes","collect_1","last_1","insertWhiteAroundSection","closeFirstSection","op_EqualsBangGreater","trigger","triggerWith","patternInput_1","patternInput_2","m_1","patternInput_4","m_2","renderNodeList","renderContextMenu","$var513","patternInput_5","methods","matchValue_2","selected","clickHandler","n_1","n_2","activePatternResult8376","svc","code","getEntity","singleton_1","$var570","activePatternResult8773","$var575","tryGetPreview","getTypeName","model","tupledArg_1","createCompletionProvider","createdEditors","ed","provideTypes","globalEntity","providePivotType","node_1","compile","serializeType","typ","it","TypeError","defined","require$$0","cof","propertyIsEnumerable","IObject","require$$1","ceil","toInteger","toIObject","require$$2","toLength","toAbsoluteIndex","IS_INCLUDES","$this","fromIndex","O","global","module","self","Function","__g","SHARED","store","px","shared","uid","require$$3","arrayIndexOf","IE_PROTO","object","names","$keys","enumBugKeys","core","__e","aFunction","fn","defineProperty","is","S","valueOf","anObject","IE8_DOM_DEFINE","toPrimitive","dP","P","Attributes","bitmap","enumerable","configurable","writable","createDesc","hide","PROTOTYPE","$export","own","out","IS_FORCED","F","IS_GLOBAL","G","IS_STATIC","IS_PROTO","IS_BIND","B","IS_WRAP","W","exports","expProto","C","virtual","R","U","fails","KEY","exp","toObject","default","__esModule","TO_STRING","pos","getKeys","defineProperties","Properties","require$$5","dPs","require$$4","Empty","createDict","iframeDocument","iframe","display","src","contentWindow","open","write","lt","close","USE_SYMBOL","TAG","stat","descriptor","setToStringTag","IteratorPrototype","Constructor","NAME","ObjectProto","LIBRARY","require$$9","require$$8","redefine","require$$7","require$$6","Iterators","$iterCreate","ITERATOR","BUGGY","FF_ITERATOR","KEYS","VALUES","returnThis","Base","DEFAULT","IS_SET","FORCED","getMethod","proto","DEF_VALUES","VALUES_BUG","$native","$default","$entries","$anyNative","entries","values","$at","iterated","_t","point","ArrayProto","$defineProperty","ARG","tryGet","T","callee","classof","getIteratorMethod","SAFE_CLOSING","riter","skipClosing","safe","isArrayIter","createProperty","getIterFn","arrayLike","mapfn","mapping","iterFn","META","setDesc","isExtensible","FREEZE","preventExtensions","setMeta","fastKey","getWeak","onFreeze","meta","NEED","wksExt","$Symbol","getOwnPropertySymbols","gOPS","pIE","getSymbols","symbols","isEnum","hiddenKeys","gOPN","windowNames","getWindowNames","gOPD","getOwnPropertyDescriptor","require$$28","require$$27","DESCRIPTORS","require$$26","require$$25","require$$24","require$$23","$fails","require$$22","require$$21","require$$20","require$$19","wks","require$$18","require$$17","wksDefine","require$$16","enumKeys","require$$15","require$$14","require$$13","require$$12","require$$11","require$$10","_create","gOPNExt","$GOPD","$DP","$JSON","_stringify","HIDDEN","TO_PRIMITIVE","SymbolRegistry","AllSymbols","OPSymbols","USE_NATIVE","QObject","setter","findChild","setSymbolDesc","D","protoDesc","wrap","sym","_k","isSymbol","$defineProperties","$create","$propertyIsEnumerable","E","$getOwnPropertyDescriptor","$getOwnPropertyNames","$getOwnPropertySymbols","IS_OP","$set","es6Symbols","wellKnownSymbols","for","keyFor","useSetter","useSimple","$replacer","instance","$Object","desc","_defineProperty","_defineProperty2","protoProps","staticProps","addToUnscopables","Arguments","TO_STRING_TAG","DOMIterables","Collection","_interopRequireDefault","_iterator","_iterator2","_symbol","_symbol2","_typeof","forbiddenField","BREAK","RETURN","iterable","SPECIES","TYPE","redefineAll","anInstance","forOf","$iterDefine","setSpecies","validate","SIZE","getEntry","entry","_f","getConstructor","wrapper","IS_MAP","ADDER","_l","clear","delete","prev","callbackfn","setStrong","original","speciesConstructor","asc","IS_FILTER","IS_SOME","IS_EVERY","IS_FIND_INDEX","NO_HOLES","each","common","IS_WEAK","_c","IS_ADDER","strong","MAP","toJSON","COLLECTION","of","A","mapFn","nextItem","Map","getIterator","globalObj","__FABLE_CORE__","generics","other","Any","Unit","tmp","Enumerator","MoveNext","Reset","eq","neq","notEquals","lessThan","lte","lessThanOrEqual","gt","greaterThan","gte","greaterThanOrEqual","comp","negate","absolute","sub","multiply","div","divide","mod","modulo","shl","shiftLeft","shr","shiftRight","shru","shiftRightUnsigned","toInt","toNumber","isZero","isNegative","radixLong","rem1","rem","remDiv","intval","getHighBits","getHighBitsUnsigned","getLowBits","getLowBitsUnsigned","getNumBitsAbs","bit","isPositive","isOdd","isEven","thisNeg","otherNeg","not","ONE","addend","a48","a32","a16","a00","b48","b32","b16","b00","c48","c32","c16","c00","subtrahend","multiplier","TWO_PWR_24","divisor","approx","toUnsigned","UONE","NEG_ONE","halfThis","approx_1","log2","log","LN2","delta","approxRes","approxRem","and","or","xor","numBits","toSigned","toBytes","le","toBytesLE","toBytesBE","hi","lo","_Symbol","TWO_PWR_16_DBL","TWO_PWR_24_DBL","caseName","m2","_this","seqCompareWith","kvp1","kvp2","seqMap","callCount","maxTrampolineCallCount","AsyncBuilder","Bind","Combine","computation1","computation2","Delay","generator","For","sequence","While","Return","ReturnFrom","TryFinally","compensation","TryWith","catchHandler","ex2","Using","resource","guard","Zero","Choice","Async","isLocalHost","level","enabledCategories","p2","cookies","xhr","meth","ar","foldMap","$var2","dict_1","ks_1","serializeExpression","serializePattern","serializeStatement","serializeAssignOperator","serializeBinaryOperator","ident","decimals","d2","d1","proj","i1","i2","isSortedUsing","zipSorted","keyName","valueName","seriesName","arg00","SeriesInternals","Async_StartAsFuture_Static","_arg8","newKeys_1","Int32Array","_range","isPreview","v_1","_arg3","v1","Helpers","ChartDataOperations","ScatterChartOptions_get_empty_Static","GeoChartOptions_get_empty_Static","PieChartOptions_get_empty_Static","BarChartOptions_get_empty_Static","ColumnChartOptions_get_empty_Static","LineChartOptions_get_empty_Static","AreaChartOptions_get_empty_Static","nativeIsArray","NONE","domWalk","needle","setAttributeNS","localName","colonPosition","getAttributeNS","removeAttributeNS","hasAttributeNS","getAttribute","hasAttribute","focus","getElementsByClassName","classNames","elems","nodeClassName","nodeClasses","every","getElementsByTagName","contains","element","initEvent","bubbles","cancelable","preventDefault","createDocumentFragment","createEvent","createComment","getElementById","topLevel","minDoc","doccy","undef","nativeSplit","compliantExecNpcg","separator","limit","separator2","match","lastLength","ignoreCase","multiline","extended","sticky","lastLastIndex","propertyName","OneVersionConstraint","MY_VERSION","onNext","onCompleted","OnNext","OnError","OnCompleted","_subscriber","delegates","Add","_addHandler","Trigger","seqIterate","_removeHandler","AddHandler","handler","_dotnetDelegates","RemoveHandler","_subscribeFromObserver","observer","_subscribeFromCallback","title","showKey","withTitle","row","_arg29","_this2","filteredProperties","kv_3","niceNumber","formatAdded","_this3","log10","LOG10E","svg","x1","y1","formatPath","anim","formatColor","_Math$log","calculateMagnitudeAndRange","step_1","generateSteps","fmt","$var85","replaceScales","calculateShapeScale","shape","autoScale","makeSingletonScale","makeSingletonScale_1","getExtremes","LineStyle","generateAxisSteps","FontStyle","generateAxisLabels","shapes","sxs","sys","sxs_1","sys_1","thv","tlv","Scales","project","rhx","rhy","x1_1","y1_1","patternInput_6","x_1","y_1","scaleOne","cats","shv","scaleOneInv","ox_1","oy_1","ox","oy","calculateProjections","shapes_1","sf","Svg","projectCont","hideFill","hideStroke","x_3","y_3","x_4","y_4","x_5","y_5","drawShape","inScales","jse","line_1","mapShape","revX","revY","parent","parent_1","mouseHandler","touchHandler","_arg4","initial","clr","fi","parseColor","activePatternResult3852","getPoints","amin","amax","width","Derived","labels_1","style_1","height","lblStyle","offs_1","rx","ry","py","Internal","tryFindBubble","bub","bub_1","CompostHelpers","points","isBar","inlineLabels","completed","tupledArg_2","loy","hiy","setColor","matchValue_6","patternInput_3","Drawing","guessed","Compost","interactive","min_2","max_1","inRange","$var139","$var141","$var140","$var143","e2","$var145","$var144","tupledArg_3","$var148","$var150","$var149","tupledArg_4","visiblePoints","dc","InteractiveHelpers","filter_1","series","data_2","data_1","_this5","ss","Lazy","factory","isValueCreated","createdValue","dropped","oldFields","oldFields_1","QueueCell","MailboxQueue","itCell","firstAndLast","messages","__processEvents","receive","post","postAndAsyncReply","buildMessage","checkCompletion","reply","formatTokenInfo","tok","formatTypeInfo","members_1","formatMembers","spaces","space","non","ltrim","rtrim","exporter","ALIAS","FORCE","string","$parseFloat","parseFloat","$trim","Infinity","line","createContext","inbox","_arg7","loop","errors","typeCheckProgram","newHeight","waitForActualHeight","_this6","liveState_1","evt_1","oldState","_this7","_evaluate","lines","height_1","ignoreFilter"],"mappings":"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"}